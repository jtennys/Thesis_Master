 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 105
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>              // part specific constants and macros
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0000           ; #include "psocdynamic.h"
 0000           ; #include <stdlib.h>
 0000           ; #include <string.h>
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0000           ; #define               PC_MODE                                         (2)
 0000           ; #define               RX_MODE                                         (1)
 0000           ; #define               TX_MODE                                         (0)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; // These defines are used for the initial probing stage. This module first waits until it hears
 0000           ; // a byte on the bus. Once this happens, this module waits until there is a BUS_CLEAR_TIME
 0000           ; // period of no communication before attempting to probe for modules and assign ID numbers.
 0000           ; // MAX_TIMEOUTS is the number of failed attempts allowed to find an unconfigured module after
 0000           ; // the first module is found. After all of this, this module goes into a PC listening mode.
 0000           ; #define               BUS_CLEAR_TIME                          (100)   // Min time after a byte to assume bus is clear at boot.
 0000           ; #define               BOOT_TIMEOUT                            (300)   // If nothing is heard by this time, we start the init anyway.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; #define               MAX_MODULE_FAIL                         (20)    // Number of module fails before the parent resets.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the master
 0000           ; #define               MAX_MODULES                                     (250)
 0000           ; 
 0000           ; #define               SERVO_START                                     (255)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the
 0000           ; // system configuration between receive and transmit modes for half duplex UART.
 0000           ; void configToggle(int mode);
 0000           ; 
 0000           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; 
 0000           ; // This function assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; 
 0000           ; int validTransmission(void);
 0000           ; 
 0000           ; void decodeTransmission(void);
 0000           ; 
 0000           ; void busListen(void);
 0000           ; 
 0000           ; void sayHello(void);
 0000           ; 
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; 
 0000           ; int clearConfig(int module_id);
 0000           ; // This function checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the slave module controllers.
 0000           ; void initializeSlaves(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; 
 0000           ; // This flag is set if there is a timeout.
 0000           ; int TIMEOUT;
 0000           ; 
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; int MODULE_FAIL;                      // Stores the number of times in a row that modules fail to respond.
 0000           ; 
 0000           ; void main()
 0000           ; {
 0000                   .dbline 107
 0000           ;       // Initialize the number of modules.
 0000           ;       NUM_MODULES = 0;
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 110
 0009           ;       
 0009           ;       // Initialize module failures to 0.
 0009           ;       MODULE_FAIL = 0;
 0009 62D000            mov REG[0xd0],>_MODULE_FAIL
 000C 550100            mov [_MODULE_FAIL+1],0
 000F 550000            mov [_MODULE_FAIL],0
 0012                   .dbline 113
 0012           ;       
 0012           ;       // Activate GPIO ISR.
 0012           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 0012 43E020            or REG[0xe0],32
 0015                   .dbline 116
 0015           ;       
 0015           ;       // Turn on global interrupts for the transmission timeout timer.
 0015           ;       M8C_EnableGInt;
 0015 7101                      or  F, 01h
 0017           
 0017                   .dbline 119
 0017           ;       
 0017           ;       // Block and wait for the bus to be clear.
 0017           ;       busListen();
 0017 7C0C99            xcall _busListen
 001A 8039              xjmp L3
 001C           L2:
 001C                   .dbline 122
 001C           ;       
 001C           ;       while(1)
 001C           ;       {
 001C                   .dbline 123
 001C           ;               if(!NUM_MODULES)
 001C 62D000            mov REG[0xd0],>_NUM_MODULES
 001F 3C0000            cmp [_NUM_MODULES],0
 0022 B00B              jnz L5
 0024 3C0100            cmp [_NUM_MODULES+1],0
 0027 B006              jnz L5
 0029           X1:
 0029                   .dbline 124
 0029           ;               {
 0029                   .dbline 125
 0029           ;                       initializeSlaves();
 0029 7C0CF3            xcall _initializeSlaves
 002C                   .dbline 126
 002C           ;               }
 002C 8027              xjmp L6
 002E           L5:
 002E                   .dbline 127
 002E           ;               else if(COMP_SERIAL_bCmdCheck())                // If there's a computer command, read it.
 002E 10                push X
 002F 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0032 62D000            mov REG[0xd0],>__r0
 0035 20                pop X
 0036 3900              cmp A,0
 0038 A01B              jz L7
 003A                   .dbline 128
 003A           ;               {
 003A                   .dbline 129
 003A           ;                       decodeTransmission();
 003A 9445              xcall _decodeTransmission
 003C                   .dbline 132
 003C           ;                       
 003C           ;                       // If we have failed too much to read module data, reset NUM_MODULES.
 003C           ;                       if(MODULE_FAIL >= MAX_MODULE_FAIL)
 003C 62D000            mov REG[0xd0],>_MODULE_FAIL
 003F 5101              mov A,[_MODULE_FAIL+1]
 0041 1114              sub A,20
 0043 5100              mov A,[_MODULE_FAIL]
 0045 3180              xor A,-128
 0047 1980              sbb A,(0 ^ 0x80)
 0049 C00A              jc L9
 004B           X2:
 004B                   .dbline 133
 004B           ;                       {
 004B                   .dbline 134
 004B           ;                               NUM_MODULES = 0;
 004B 62D000            mov REG[0xd0],>_NUM_MODULES
 004E 550100            mov [_NUM_MODULES+1],0
 0051 550000            mov [_NUM_MODULES],0
 0054                   .dbline 135
 0054           ;                       }
 0054           L9:
 0054                   .dbline 136
 0054           ;               }
 0054           L7:
 0054           L6:
 0054                   .dbline 137
 0054           ;       }
 0054           L3:
 0054                   .dbline 121
 0054 8FC7              xjmp L2
 0056           X0:
 0056                   .dbline -2
 0056           L1:
 0056                   .dbline 0 ; func end
 0056 8FFF              jmp .
 0058                   .dbend
 0058                   .dbfunc e pingModule _pingModule fI
 0058           ;       response -> X+0
 0058           ;      module_id -> X-5
 0058           _pingModule::
 0058                   .dbline -1
 0058 10                push X
 0059 4F                mov X,SP
 005A 3802              add SP,2
 005C                   .dbline 141
 005C           ; }
 005C           ; 
 005C           ; int pingModule(int module_id)
 005C           ; {
 005C                   .dbline 142
 005C           ;       int response = 0;
 005C 560100            mov [X+1],0
 005F 560000            mov [X+0],0
 0062                   .dbline 144
 0062           ;       
 0062           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0062 5000              mov A,0
 0064 08                push A
 0065 08                push A
 0066 7C0B81            xcall _configToggle
 0069 38FE              add SP,-2
 006B                   .dbline 147
 006B           ;                       
 006B           ;       // Transmit a hello.
 006B           ;       TRANSMIT_PutChar(START_TRANSMIT);
 006B 10                push X
 006C 50FC              mov A,-4
 006E 7C0000            xcall _TRANSMIT_PutChar
 0071 20                pop X
 0072                   .dbline 148
 0072           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0072 10                push X
 0073 50FC              mov A,-4
 0075 7C0000            xcall _TRANSMIT_PutChar
 0078 20                pop X
 0079                   .dbline 149
 0079           ;       TRANSMIT_PutChar(MASTER_ID);
 0079 10                push X
 007A 5000              mov A,0
 007C 7C0000            xcall _TRANSMIT_PutChar
 007F 20                pop X
 0080                   .dbline 150
 0080           ;       TRANSMIT_PutChar(module_id);
 0080 62D000            mov REG[0xd0],>__r0
 0083 52FC              mov A,[X-4]
 0085 10                push X
 0086 7C0000            xcall _TRANSMIT_PutChar
 0089 20                pop X
 008A                   .dbline 151
 008A           ;       TRANSMIT_PutChar(PING);
 008A 10                push X
 008B 50CB              mov A,-53
 008D 7C0000            xcall _TRANSMIT_PutChar
 0090 20                pop X
 0091                   .dbline 152
 0091           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0091 10                push X
 0092 50FD              mov A,-3
 0094 7C0000            xcall _TRANSMIT_PutChar
 0097 20                pop X
 0098                   .dbline 153
 0098           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0098 10                push X
 0099 50FD              mov A,-3
 009B 7C0000            xcall _TRANSMIT_PutChar
 009E 20                pop X
 009F           L12:
 009F                   .dbline 156
 009F           ;       
 009F           ;       // Wait for the transmission to finish.
 009F           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 009F           L13:
 009F                   .dbline 156
 009F 10                push X
 00A0 7C0000            xcall _TRANSMIT_bReadTxStatus
 00A3 62D000            mov REG[0xd0],>__r0
 00A6 20                pop X
 00A7 5300              mov [__r0],A
 00A9 470020            tst [__r0],32
 00AC AFF2              jz L12
 00AE                   .dbline 158
 00AE           ;       
 00AE           ;       xmitWait();
 00AE 7C0E70            xcall _xmitWait
 00B1                   .dbline 160
 00B1           ;       
 00B1           ;       configToggle(RX_MODE);  // Listen for the response.
 00B1 5000              mov A,0
 00B3 08                push A
 00B4 5001              mov A,1
 00B6 08                push A
 00B7 7C0B81            xcall _configToggle
 00BA 38FE              add SP,-2
 00BC                   .dbline 162
 00BC           ;       
 00BC           ;       RX_TIMEOUT_Stop();
 00BC 10                push X
 00BD 7C0000            xcall _RX_TIMEOUT_Stop
 00C0 20                pop X
 00C1                   .dbline 163
 00C1           ;       TIMEOUT = 0;
 00C1 62D000            mov REG[0xd0],>_TIMEOUT
 00C4 550100            mov [_TIMEOUT+1],0
 00C7 550000            mov [_TIMEOUT],0
 00CA                   .dbline 164
 00CA           ;       RX_TIMEOUT_Start();
 00CA 10                push X
 00CB 7C0000            xcall _RX_TIMEOUT_Start
 00CE 20                pop X
 00CF 803C              xjmp L16
 00D1           L15:
 00D1                   .dbline 167
 00D1           ;       
 00D1           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 00D1           ;       {
 00D1                   .dbline 168
 00D1           ;               if(validTransmission())
 00D1 92BA              xcall _validTransmission
 00D3 62D000            mov REG[0xd0],>__r0
 00D6 3C0000            cmp [__r0],0
 00D9 B006              jnz X3
 00DB 3C0000            cmp [__r1],0
 00DE A02D              jz L18
 00E0           X3:
 00E0                   .dbline 169
 00E0           ;               {
 00E0                   .dbline 170
 00E0           ;                       if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00E0 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00E3 3C00CB            cmp [_COMMAND_TYPE],-53
 00E6 B025              jnz L20
 00E8                   .dbline 171
 00E8           ;                       {
 00E8                   .dbline 173
 00E8           ;                               // If this is for me, check who it was from.
 00E8           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 00E8 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00EB 3C0000            cmp [_COMMAND_DESTINATION],0
 00EE B01D              jnz L22
 00F0                   .dbline 174
 00F0           ;                               {
 00F0                   .dbline 175
 00F0           ;                                       if(COMMAND_SOURCE == module_id)
 00F0 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00F3 5100              mov A,[_COMMAND_SOURCE]
 00F5 62D000            mov REG[0xd0],>__r0
 00F8 5300              mov [__r1],A
 00FA 5000              mov A,0
 00FC 3BFB              cmp A,[X-5]
 00FE B00D              jnz L24
 0100 5100              mov A,[__r1]
 0102 3BFC              cmp A,[X-4]
 0104 B007              jnz L24
 0106           X4:
 0106                   .dbline 176
 0106           ;                                       {
 0106                   .dbline 177
 0106           ;                                               response = 1;
 0106 560101            mov [X+1],1
 0109 560000            mov [X+0],0
 010C                   .dbline 178
 010C           ;                                       }
 010C           L24:
 010C                   .dbline 179
 010C           ;                               }
 010C           L22:
 010C                   .dbline 180
 010C           ;                       }
 010C           L20:
 010C                   .dbline 181
 010C           ;               }
 010C           L18:
 010C                   .dbline 182
 010C           ;       }
 010C           L16:
 010C                   .dbline 166
 010C 62D000            mov REG[0xd0],>_TIMEOUT
 010F 5101              mov A,[_TIMEOUT+1]
 0111 1105              sub A,5
 0113 5100              mov A,[_TIMEOUT]
 0115 3180              xor A,-128
 0117 1980              sbb A,(0 ^ 0x80)
 0119 D00B              jnc L26
 011B           X5:
 011B 3D0000            cmp [X+0],0
 011E B006              jnz X6
 0120 3D0100            cmp [X+1],0
 0123 AFAD              jz L15
 0125           X6:
 0125           L26:
 0125                   .dbline 184
 0125           ;       
 0125           ;       RX_TIMEOUT_Stop();
 0125 10                push X
 0126 7C0000            xcall _RX_TIMEOUT_Stop
 0129 20                pop X
 012A                   .dbline 185
 012A           ;       TIMEOUT = 0;
 012A 62D000            mov REG[0xd0],>_TIMEOUT
 012D 550100            mov [_TIMEOUT+1],0
 0130 550000            mov [_TIMEOUT],0
 0133                   .dbline 186
 0133           ;       RX_TIMEOUT_Start();
 0133 10                push X
 0134 7C0000            xcall _RX_TIMEOUT_Start
 0137 20                pop X
 0138                   .dbline 188
 0138           ;       
 0138           ;       return response;
 0138 62D000            mov REG[0xd0],>__r0
 013B 5201              mov A,[X+1]
 013D 5300              mov [__r1],A
 013F 5200              mov A,[X+0]
 0141 5300              mov [__r0],A
 0143                   .dbline -2
 0143           L11:
 0143 38FE              add SP,-2
 0145 20                pop X
 0146                   .dbline 0 ; func end
 0146 7F                ret
 0147                   .dbsym l response 0 I
 0147                   .dbsym l module_id -5 I
 0147                   .dbend
 0147                   .dbfunc e assignID _assignID fI
 0147           ;        success -> X+0
 0147           ;    assigned_ID -> X-5
 0147           _assignID::
 0147                   .dbline -1
 0147 10                push X
 0148 4F                mov X,SP
 0149 3802              add SP,2
 014B                   .dbline 192
 014B           ; }
 014B           ; 
 014B           ; int assignID(int assigned_ID)
 014B           ; {
 014B                   .dbline 193
 014B           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 014B 560100            mov [X+1],0
 014E 560000            mov [X+0],0
 0151                   .dbline 195
 0151           ;       
 0151           ;       configToggle(TX_MODE);  // Switch to TX mode.
 0151 5000              mov A,0
 0153 08                push A
 0154 08                push A
 0155 7C0B81            xcall _configToggle
 0158 38FE              add SP,-2
 015A                   .dbline 198
 015A           ; 
 015A           ;       // Transmit the assignment.
 015A           ;       TRANSMIT_PutChar(START_TRANSMIT);
 015A 10                push X
 015B 50FC              mov A,-4
 015D 7C0000            xcall _TRANSMIT_PutChar
 0160 20                pop X
 0161                   .dbline 199
 0161           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0161 10                push X
 0162 50FC              mov A,-4
 0164 7C0000            xcall _TRANSMIT_PutChar
 0167 20                pop X
 0168                   .dbline 200
 0168           ;       TRANSMIT_PutChar(MASTER_ID);
 0168 10                push X
 0169 5000              mov A,0
 016B 7C0000            xcall _TRANSMIT_PutChar
 016E 20                pop X
 016F                   .dbline 201
 016F           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 016F 10                push X
 0170 50FB              mov A,-5
 0172 7C0000            xcall _TRANSMIT_PutChar
 0175 20                pop X
 0176                   .dbline 202
 0176           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0176 10                push X
 0177 50C9              mov A,-55
 0179 7C0000            xcall _TRANSMIT_PutChar
 017C 20                pop X
 017D                   .dbline 203
 017D           ;       TRANSMIT_PutChar(assigned_ID);
 017D 62D000            mov REG[0xd0],>__r0
 0180 52FC              mov A,[X-4]
 0182 10                push X
 0183 7C0000            xcall _TRANSMIT_PutChar
 0186 20                pop X
 0187                   .dbline 204
 0187           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0187 10                push X
 0188 50FD              mov A,-3
 018A 7C0000            xcall _TRANSMIT_PutChar
 018D 20                pop X
 018E                   .dbline 205
 018E           ;       TRANSMIT_PutChar(END_TRANSMIT);
 018E 10                push X
 018F 50FD              mov A,-3
 0191 7C0000            xcall _TRANSMIT_PutChar
 0194 20                pop X
 0195           L28:
 0195                   .dbline 208
 0195           ;       
 0195           ;       // Wait for the transmission to finish.
 0195           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0195           L29:
 0195                   .dbline 208
 0195 10                push X
 0196 7C0000            xcall _TRANSMIT_bReadTxStatus
 0199 62D000            mov REG[0xd0],>__r0
 019C 20                pop X
 019D 5300              mov [__r0],A
 019F 470020            tst [__r0],32
 01A2 AFF2              jz L28
 01A4                   .dbline 210
 01A4           ;       
 01A4           ;       xmitWait();
 01A4 7C0E70            xcall _xmitWait
 01A7                   .dbline 212
 01A7           ;       
 01A7           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 01A7 5000              mov A,0
 01A9 08                push A
 01AA 5001              mov A,1
 01AC 08                push A
 01AD 7C0B81            xcall _configToggle
 01B0 38FE              add SP,-2
 01B2                   .dbline 214
 01B2           ;       
 01B2           ;       RX_TIMEOUT_Stop();
 01B2 10                push X
 01B3 7C0000            xcall _RX_TIMEOUT_Stop
 01B6 20                pop X
 01B7                   .dbline 215
 01B7           ;       TIMEOUT = 0;
 01B7 62D000            mov REG[0xd0],>_TIMEOUT
 01BA 550100            mov [_TIMEOUT+1],0
 01BD 550000            mov [_TIMEOUT],0
 01C0                   .dbline 216
 01C0           ;       RX_TIMEOUT_Start();
 01C0 10                push X
 01C1 7C0000            xcall _RX_TIMEOUT_Start
 01C4 20                pop X
 01C5 803C              xjmp L32
 01C7           L31:
 01C7                   .dbline 219
 01C7           ;       
 01C7           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 01C7           ;       {
 01C7                   .dbline 220
 01C7           ;               if(validTransmission())
 01C7 91C4              xcall _validTransmission
 01C9 62D000            mov REG[0xd0],>__r0
 01CC 3C0000            cmp [__r0],0
 01CF B006              jnz X7
 01D1 3C0000            cmp [__r1],0
 01D4 A02D              jz L34
 01D6           X7:
 01D6                   .dbline 221
 01D6           ;               {
 01D6                   .dbline 222
 01D6           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 01D6 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01D9 3C00CA            cmp [_COMMAND_TYPE],-54
 01DC B025              jnz L36
 01DE                   .dbline 223
 01DE           ;                       {
 01DE                   .dbline 225
 01DE           ;                               // If this is for me, check who it was from.
 01DE           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 01DE 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 01E1 3C0000            cmp [_COMMAND_DESTINATION],0
 01E4 B01D              jnz L38
 01E6                   .dbline 226
 01E6           ;                               {
 01E6                   .dbline 227
 01E6           ;                                       if(COMMAND_SOURCE == assigned_ID)
 01E6 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 01E9 5100              mov A,[_COMMAND_SOURCE]
 01EB 62D000            mov REG[0xd0],>__r0
 01EE 5300              mov [__r1],A
 01F0 5000              mov A,0
 01F2 3BFB              cmp A,[X-5]
 01F4 B00D              jnz L40
 01F6 5100              mov A,[__r1]
 01F8 3BFC              cmp A,[X-4]
 01FA B007              jnz L40
 01FC           X8:
 01FC                   .dbline 228
 01FC           ;                                       {
 01FC                   .dbline 229
 01FC           ;                                               success = 1;
 01FC 560101            mov [X+1],1
 01FF 560000            mov [X+0],0
 0202                   .dbline 230
 0202           ;                                       }
 0202           L40:
 0202                   .dbline 231
 0202           ;                               }
 0202           L38:
 0202                   .dbline 232
 0202           ;                       }
 0202           L36:
 0202                   .dbline 233
 0202           ;               }
 0202           L34:
 0202                   .dbline 234
 0202           ;       }
 0202           L32:
 0202                   .dbline 218
 0202 62D000            mov REG[0xd0],>_TIMEOUT
 0205 5101              mov A,[_TIMEOUT+1]
 0207 1105              sub A,5
 0209 5100              mov A,[_TIMEOUT]
 020B 3180              xor A,-128
 020D 1980              sbb A,(0 ^ 0x80)
 020F D00B              jnc L42
 0211           X9:
 0211 3D0000            cmp [X+0],0
 0214 B006              jnz X10
 0216 3D0100            cmp [X+1],0
 0219 AFAD              jz L31
 021B           X10:
 021B           L42:
 021B                   .dbline 236
 021B           ;       
 021B           ;       RX_TIMEOUT_Stop();
 021B 10                push X
 021C 7C0000            xcall _RX_TIMEOUT_Stop
 021F 20                pop X
 0220                   .dbline 237
 0220           ;       TIMEOUT = 0;
 0220 62D000            mov REG[0xd0],>_TIMEOUT
 0223 550100            mov [_TIMEOUT+1],0
 0226 550000            mov [_TIMEOUT],0
 0229                   .dbline 238
 0229           ;       RX_TIMEOUT_Start();
 0229 10                push X
 022A 7C0000            xcall _RX_TIMEOUT_Start
 022D 20                pop X
 022E                   .dbline 240
 022E           ;       
 022E           ;       return success;
 022E 62D000            mov REG[0xd0],>__r0
 0231 5201              mov A,[X+1]
 0233 5300              mov [__r1],A
 0235 5200              mov A,[X+0]
 0237 5300              mov [__r0],A
 0239                   .dbline -2
 0239           L27:
 0239 38FE              add SP,-2
 023B 20                pop X
 023C                   .dbline 0 ; func end
 023C 7F                ret
 023D                   .dbsym l success 0 I
 023D                   .dbsym l assigned_ID -5 I
 023D                   .dbend
 023D                   .dbfunc e clearConfig _clearConfig fI
 023D           ;       response -> X+0
 023D           ;      module_id -> X-5
 023D           _clearConfig::
 023D                   .dbline -1
 023D 10                push X
 023E 4F                mov X,SP
 023F 3802              add SP,2
 0241                   .dbline 244
 0241           ; }
 0241           ; 
 0241           ; int clearConfig(int module_id)
 0241           ; {
 0241                   .dbline 245
 0241           ;       int response = 0;
 0241 560100            mov [X+1],0
 0244 560000            mov [X+0],0
 0247                   .dbline 247
 0247           ;       
 0247           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0247 5000              mov A,0
 0249 08                push A
 024A 08                push A
 024B 7C0B81            xcall _configToggle
 024E 38FE              add SP,-2
 0250                   .dbline 250
 0250           ;                       
 0250           ;       // Transmit a hello.
 0250           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0250 10                push X
 0251 50FC              mov A,-4
 0253 7C0000            xcall _TRANSMIT_PutChar
 0256 20                pop X
 0257                   .dbline 251
 0257           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0257 10                push X
 0258 50FC              mov A,-4
 025A 7C0000            xcall _TRANSMIT_PutChar
 025D 20                pop X
 025E                   .dbline 252
 025E           ;       TRANSMIT_PutChar(MASTER_ID);
 025E 10                push X
 025F 5000              mov A,0
 0261 7C0000            xcall _TRANSMIT_PutChar
 0264 20                pop X
 0265                   .dbline 253
 0265           ;       TRANSMIT_PutChar(module_id);
 0265 62D000            mov REG[0xd0],>__r0
 0268 52FC              mov A,[X-4]
 026A 10                push X
 026B 7C0000            xcall _TRANSMIT_PutChar
 026E 20                pop X
 026F                   .dbline 254
 026F           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 026F 10                push X
 0270 50CC              mov A,-52
 0272 7C0000            xcall _TRANSMIT_PutChar
 0275 20                pop X
 0276                   .dbline 255
 0276           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0276 10                push X
 0277 50FD              mov A,-3
 0279 7C0000            xcall _TRANSMIT_PutChar
 027C 20                pop X
 027D                   .dbline 256
 027D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 027D 10                push X
 027E 50FD              mov A,-3
 0280 7C0000            xcall _TRANSMIT_PutChar
 0283 20                pop X
 0284           L44:
 0284                   .dbline 259
 0284           ;       
 0284           ;       // Wait for the transmission to finish.
 0284           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0284           L45:
 0284                   .dbline 259
 0284 10                push X
 0285 7C0000            xcall _TRANSMIT_bReadTxStatus
 0288 62D000            mov REG[0xd0],>__r0
 028B 20                pop X
 028C 5300              mov [__r0],A
 028E 470020            tst [__r0],32
 0291 AFF2              jz L44
 0293                   .dbline 261
 0293           ;       
 0293           ;       xmitWait();
 0293 7C0E70            xcall _xmitWait
 0296                   .dbline 263
 0296           ;       
 0296           ;       configToggle(RX_MODE);  // Listen for the response.
 0296 5000              mov A,0
 0298 08                push A
 0299 5001              mov A,1
 029B 08                push A
 029C 7C0B81            xcall _configToggle
 029F 38FE              add SP,-2
 02A1                   .dbline 265
 02A1           ;       
 02A1           ;       if(module_id != BROADCAST)
 02A1 3DFB00            cmp [X-5],0
 02A4 B006              jnz X11
 02A6 3DFCFE            cmp [X-4],-2
 02A9 A07D              jz L47
 02AB           X11:
 02AB                   .dbline 266
 02AB           ;       {
 02AB                   .dbline 267
 02AB           ;               RX_TIMEOUT_Stop();
 02AB 10                push X
 02AC 7C0000            xcall _RX_TIMEOUT_Stop
 02AF 20                pop X
 02B0                   .dbline 268
 02B0           ;               TIMEOUT = 0;
 02B0 62D000            mov REG[0xd0],>_TIMEOUT
 02B3 550100            mov [_TIMEOUT+1],0
 02B6 550000            mov [_TIMEOUT],0
 02B9                   .dbline 269
 02B9           ;               RX_TIMEOUT_Start();
 02B9 10                push X
 02BA 7C0000            xcall _RX_TIMEOUT_Start
 02BD 20                pop X
 02BE 803C              xjmp L50
 02C0           L49:
 02C0                   .dbline 272
 02C0           ;               
 02C0           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 02C0           ;               {
 02C0                   .dbline 273
 02C0           ;                       if(validTransmission())
 02C0 90CB              xcall _validTransmission
 02C2 62D000            mov REG[0xd0],>__r0
 02C5 3C0000            cmp [__r0],0
 02C8 B006              jnz X12
 02CA 3C0000            cmp [__r1],0
 02CD A02D              jz L52
 02CF           X12:
 02CF                   .dbline 274
 02CF           ;                       {
 02CF                   .dbline 275
 02CF           ;                               if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 02CF 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02D2 3C00CD            cmp [_COMMAND_TYPE],-51
 02D5 B025              jnz L54
 02D7                   .dbline 276
 02D7           ;                               {
 02D7                   .dbline 278
 02D7           ;                                       // If this is for me, check who it was from.
 02D7           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 02D7 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 02DA 3C0000            cmp [_COMMAND_DESTINATION],0
 02DD B01D              jnz L56
 02DF                   .dbline 279
 02DF           ;                                       {
 02DF                   .dbline 280
 02DF           ;                                               if(COMMAND_SOURCE == module_id)
 02DF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02E2 5100              mov A,[_COMMAND_SOURCE]
 02E4 62D000            mov REG[0xd0],>__r0
 02E7 5300              mov [__r1],A
 02E9 5000              mov A,0
 02EB 3BFB              cmp A,[X-5]
 02ED B00D              jnz L58
 02EF 5100              mov A,[__r1]
 02F1 3BFC              cmp A,[X-4]
 02F3 B007              jnz L58
 02F5           X13:
 02F5                   .dbline 281
 02F5           ;                                               {
 02F5                   .dbline 282
 02F5           ;                                                       response = 1;
 02F5 560101            mov [X+1],1
 02F8 560000            mov [X+0],0
 02FB                   .dbline 283
 02FB           ;                                               }
 02FB           L58:
 02FB                   .dbline 284
 02FB           ;                                       }
 02FB           L56:
 02FB                   .dbline 285
 02FB           ;                               }
 02FB           L54:
 02FB                   .dbline 286
 02FB           ;                       }
 02FB           L52:
 02FB                   .dbline 287
 02FB           ;               }
 02FB           L50:
 02FB                   .dbline 271
 02FB 62D000            mov REG[0xd0],>_TIMEOUT
 02FE 5101              mov A,[_TIMEOUT+1]
 0300 1105              sub A,5
 0302 5100              mov A,[_TIMEOUT]
 0304 3180              xor A,-128
 0306 1980              sbb A,(0 ^ 0x80)
 0308 D00B              jnc L60
 030A           X14:
 030A 3D0000            cmp [X+0],0
 030D B006              jnz X15
 030F 3D0100            cmp [X+1],0
 0312 AFAD              jz L49
 0314           X15:
 0314           L60:
 0314                   .dbline 289
 0314           ;               
 0314           ;               RX_TIMEOUT_Stop();
 0314 10                push X
 0315 7C0000            xcall _RX_TIMEOUT_Stop
 0318 20                pop X
 0319                   .dbline 290
 0319           ;               TIMEOUT = 0;
 0319 62D000            mov REG[0xd0],>_TIMEOUT
 031C 550100            mov [_TIMEOUT+1],0
 031F 550000            mov [_TIMEOUT],0
 0322                   .dbline 291
 0322           ;               RX_TIMEOUT_Start();
 0322 10                push X
 0323 7C0000            xcall _RX_TIMEOUT_Start
 0326 20                pop X
 0327                   .dbline 292
 0327           ;       }
 0327           L47:
 0327                   .dbline 294
 0327           ;       
 0327           ;       return response;
 0327 62D000            mov REG[0xd0],>__r0
 032A 5201              mov A,[X+1]
 032C 5300              mov [__r1],A
 032E 5200              mov A,[X+0]
 0330 5300              mov [__r0],A
 0332                   .dbline -2
 0332           L43:
 0332 38FE              add SP,-2
 0334 20                pop X
 0335                   .dbline 0 ; func end
 0335 7F                ret
 0336                   .dbsym l response 0 I
 0336                   .dbsym l module_id -5 I
 0336                   .dbend
 0336                   .dbfunc e sayHello _sayHello fV
 0336           _sayHello::
 0336                   .dbline -1
 0336                   .dbline 299
 0336           ; }
 0336           ; 
 0336           ; // This function transmits a hello message.
 0336           ; void sayHello(void)
 0336           ; {
 0336                   .dbline 300
 0336           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 0336 5000              mov A,0
 0338 08                push A
 0339 08                push A
 033A 7C0B81            xcall _configToggle
 033D 38FE              add SP,-2
 033F                   .dbline 303
 033F           ;                       
 033F           ;       // Transmit a hello.
 033F           ;       TRANSMIT_PutChar(START_TRANSMIT);
 033F 10                push X
 0340 50FC              mov A,-4
 0342 7C0000            xcall _TRANSMIT_PutChar
 0345 20                pop X
 0346                   .dbline 304
 0346           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0346 10                push X
 0347 50FC              mov A,-4
 0349 7C0000            xcall _TRANSMIT_PutChar
 034C 20                pop X
 034D                   .dbline 305
 034D           ;       TRANSMIT_PutChar(MASTER_ID);
 034D 10                push X
 034E 5000              mov A,0
 0350 7C0000            xcall _TRANSMIT_PutChar
 0353 20                pop X
 0354                   .dbline 306
 0354           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0354 10                push X
 0355 50FB              mov A,-5
 0357 7C0000            xcall _TRANSMIT_PutChar
 035A 20                pop X
 035B                   .dbline 307
 035B           ;       TRANSMIT_PutChar(HELLO_BYTE);
 035B 10                push X
 035C 50C8              mov A,-56
 035E 7C0000            xcall _TRANSMIT_PutChar
 0361 20                pop X
 0362                   .dbline 308
 0362           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0362 10                push X
 0363 50FD              mov A,-3
 0365 7C0000            xcall _TRANSMIT_PutChar
 0368 20                pop X
 0369                   .dbline 309
 0369           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0369 10                push X
 036A 50FD              mov A,-3
 036C 7C0000            xcall _TRANSMIT_PutChar
 036F 20                pop X
 0370           L62:
 0370                   .dbline 312
 0370           ;       
 0370           ;       // Wait for the transmission to finish.
 0370           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0370           L63:
 0370                   .dbline 312
 0370 10                push X
 0371 7C0000            xcall _TRANSMIT_bReadTxStatus
 0374 62D000            mov REG[0xd0],>__r0
 0377 20                pop X
 0378 5300              mov [__r0],A
 037A 470020            tst [__r0],32
 037D AFF2              jz L62
 037F                   .dbline 314
 037F           ;       
 037F           ;       xmitWait();
 037F 7C0E70            xcall _xmitWait
 0382                   .dbline 316
 0382           ;       
 0382           ;       configToggle(RX_MODE);                          // Listen for the response.
 0382 5000              mov A,0
 0384 08                push A
 0385 5001              mov A,1
 0387 08                push A
 0388 97F7              xcall _configToggle
 038A 38FE              add SP,-2
 038C                   .dbline -2
 038C           L61:
 038C                   .dbline 0 ; func end
 038C 7F                ret
 038D                   .dbend
 038D                   .dbfunc e validTransmission _validTransmission fI
 038D           ; valid_transmit -> X+3
 038D           ;              i -> X+1
 038D           ;       tempByte -> X+0
 038D           _validTransmission::
 038D                   .dbline -1
 038D 10                push X
 038E 4F                mov X,SP
 038F 3805              add SP,5
 0391                   .dbline 321
 0391           ; }
 0391           ; 
 0391           ; // This function returns whether or not a valid transmission has been received.
 0391           ; int validTransmission(void)
 0391           ; {
 0391                   .dbline 322
 0391           ;       int valid_transmit = 0;
 0391 560400            mov [X+4],0
 0394 560300            mov [X+3],0
 0397                   .dbline 323
 0397           ;       int i = 0;
 0397 560200            mov [X+2],0
 039A 560100            mov [X+1],0
 039D                   .dbline 324
 039D           ;       char tempByte = 0;
 039D 560000            mov [X+0],0
 03A0 80C2              xjmp L67
 03A2           L66:
 03A2                   .dbline 327
 03A2           ;       
 03A2           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03A2           ;       {
 03A2                   .dbline 328
 03A2           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 03A2 10                push X
 03A3 7C0000            xcall _RECEIVE_cReadChar
 03A6 62D000            mov REG[0xd0],>__r0
 03A9 20                pop X
 03AA 39FC              cmp A,-4
 03AC B0B6              jnz L69
 03AE                   .dbline 329
 03AE           ;               {
 03AE 80A5              xjmp L72
 03B0           L71:
 03B0                   .dbline 331
 03B0           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03B0           ;                       {
 03B0                   .dbline 332
 03B0           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 03B0 10                push X
 03B1 7C0000            xcall _RECEIVE_cReadChar
 03B4 62D000            mov REG[0xd0],>__r0
 03B7 20                pop X
 03B8 39FC              cmp A,-4
 03BA B099              jnz L74
 03BC                   .dbline 333
 03BC           ;                               {
 03BC 8088              xjmp L77
 03BE           L76:
 03BE                   .dbline 335
 03BE           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03BE           ;                                       {
 03BE                   .dbline 336
 03BE           ;                                               if(tempByte = RECEIVE_cReadChar())
 03BE 10                push X
 03BF 7C0000            xcall _RECEIVE_cReadChar
 03C2 20                pop X
 03C3 5400              mov [X+0],A
 03C5 3900              cmp A,0
 03C7 A07D              jz L79
 03C9                   .dbline 337
 03C9           ;                                               {
 03C9                   .dbline 338
 03C9           ;                                                       COMMAND_SOURCE = tempByte;
 03C9 5200              mov A,[X+0]
 03CB 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 03CE 5300              mov [_COMMAND_SOURCE],A
 03D0 8065              xjmp L82
 03D2           L81:
 03D2                   .dbline 341
 03D2           ;                                                       
 03D2           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03D2           ;                                                       {
 03D2                   .dbline 342
 03D2           ;                                                               if(tempByte = RECEIVE_cReadChar())
 03D2 10                push X
 03D3 7C0000            xcall _RECEIVE_cReadChar
 03D6 62D000            mov REG[0xd0],>__r0
 03D9 20                pop X
 03DA 5400              mov [X+0],A
 03DC 3900              cmp A,0
 03DE A057              jz L84
 03E0                   .dbline 343
 03E0           ;                                                               {
 03E0                   .dbline 344
 03E0           ;                                                                       if(tempByte >= HELLO_BYTE)
 03E0 3D00C8            cmp [X+0],-56
 03E3 C052              jc L86
 03E5           X16:
 03E5                   .dbline 345
 03E5           ;                                                                       {
 03E5                   .dbline 346
 03E5           ;                                                                               COMMAND_TYPE = tempByte;
 03E5 5200              mov A,[X+0]
 03E7 62D000            mov REG[0xd0],>_COMMAND_TYPE
 03EA 5300              mov [_COMMAND_TYPE],A
 03EC 803A              xjmp L89
 03EE           L88:
 03EE                   .dbline 349
 03EE           ;                                                                               
 03EE           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 03EE           ;                                                                               {
 03EE                   .dbline 350
 03EE           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 03EE 10                push X
 03EF 7C0000            xcall _RECEIVE_cReadChar
 03F2 62D000            mov REG[0xd0],>__r0
 03F5 20                pop X
 03F6 5400              mov [X+0],A
 03F8 3900              cmp A,0
 03FA A02C              jz L91
 03FC                   .dbline 351
 03FC           ;                                                                                       {
 03FC                   .dbline 352
 03FC           ;                                                                                               if(tempByte != END_TRANSMIT)
 03FC 3D00FD            cmp [X+0],-3
 03FF A018              jz L93
 0401                   .dbline 353
 0401           ;                                                                                               {
 0401                   .dbline 354
 0401           ;                                                                                                       PARAM[i] = tempByte;
 0401 5202              mov A,[X+2]
 0403 0100              add A,<_PARAM
 0405 5300              mov [__r1],A
 0407 5201              mov A,[X+1]
 0409 0900              adc A,>_PARAM
 040B 60D5              mov REG[0xd5],A
 040D 5200              mov A,[X+0]
 040F 3F00              mvi [__r1],A
 0411                   .dbline 355
 0411           ;                                                                                                       i++;
 0411 7702              inc [X+2]
 0413 0F0100            adc [X+1],0
 0416                   .dbline 356
 0416           ;                                                                                               }
 0416 8010              xjmp L94
 0418           L93:
 0418                   .dbline 358
 0418           ;                                                                                               else
 0418           ;                                                                                               {
 0418                   .dbline 359
 0418           ;                                                                                                       valid_transmit = 1;
 0418 560401            mov [X+4],1
 041B 560300            mov [X+3],0
 041E                   .dbline 360
 041E           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 041E 62D000            mov REG[0xd0],>_TIMEOUT
 0421 550105            mov [_TIMEOUT+1],5
 0424 550000            mov [_TIMEOUT],0
 0427                   .dbline 361
 0427           ;                                                                                               }
 0427           L94:
 0427                   .dbline 362
 0427           ;                                                                                       }
 0427           L91:
 0427                   .dbline 363
 0427           ;                                                                               }
 0427           L89:
 0427                   .dbline 348
 0427 62D000            mov REG[0xd0],>_TIMEOUT
 042A 5101              mov A,[_TIMEOUT+1]
 042C 1105              sub A,5
 042E 5100              mov A,[_TIMEOUT]
 0430 3180              xor A,-128
 0432 1980              sbb A,(0 ^ 0x80)
 0434 CFB9              jc L88
 0436           X17:
 0436                   .dbline 364
 0436           ;                                                                       }
 0436           L86:
 0436                   .dbline 365
 0436           ;                                                               }
 0436           L84:
 0436                   .dbline 366
 0436           ;                                                       }
 0436           L82:
 0436                   .dbline 340
 0436 62D000            mov REG[0xd0],>_TIMEOUT
 0439 5101              mov A,[_TIMEOUT+1]
 043B 1105              sub A,5
 043D 5100              mov A,[_TIMEOUT]
 043F 3180              xor A,-128
 0441 1980              sbb A,(0 ^ 0x80)
 0443 CF8E              jc L81
 0445           X18:
 0445                   .dbline 367
 0445           ;                                               }
 0445           L79:
 0445                   .dbline 368
 0445           ;                                       }
 0445           L77:
 0445                   .dbline 334
 0445 62D000            mov REG[0xd0],>_TIMEOUT
 0448 5101              mov A,[_TIMEOUT+1]
 044A 1105              sub A,5
 044C 5100              mov A,[_TIMEOUT]
 044E 3180              xor A,-128
 0450 1980              sbb A,(0 ^ 0x80)
 0452 CF6B              jc L76
 0454           X19:
 0454                   .dbline 369
 0454           ;                               }
 0454           L74:
 0454                   .dbline 370
 0454           ;                       }
 0454           L72:
 0454                   .dbline 330
 0454 62D000            mov REG[0xd0],>_TIMEOUT
 0457 5101              mov A,[_TIMEOUT+1]
 0459 1105              sub A,5
 045B 5100              mov A,[_TIMEOUT]
 045D 3180              xor A,-128
 045F 1980              sbb A,(0 ^ 0x80)
 0461 CF4E              jc L71
 0463           X20:
 0463                   .dbline 371
 0463           ;               }
 0463           L69:
 0463                   .dbline 372
 0463           ;       }
 0463           L67:
 0463                   .dbline 326
 0463 62D000            mov REG[0xd0],>_TIMEOUT
 0466 5101              mov A,[_TIMEOUT+1]
 0468 1105              sub A,5
 046A 5100              mov A,[_TIMEOUT]
 046C 3180              xor A,-128
 046E 1980              sbb A,(0 ^ 0x80)
 0470 CF31              jc L66
 0472           X21:
 0472                   .dbline 374
 0472           ;       
 0472           ;       return valid_transmit;
 0472 62D000            mov REG[0xd0],>__r0
 0475 5204              mov A,[X+4]
 0477 5300              mov [__r1],A
 0479 5203              mov A,[X+3]
 047B 5300              mov [__r0],A
 047D                   .dbline -2
 047D           L65:
 047D 38FB              add SP,-5
 047F 20                pop X
 0480                   .dbline 0 ; func end
 0480 7F                ret
 0481                   .dbsym l valid_transmit 3 I
 0481                   .dbsym l i 1 I
 0481                   .dbsym l tempByte 0 c
 0481                   .dbend
 0481                   .dbfunc e decodeTransmission _decodeTransmission fV
 0481           ;       tempByte -> X+7
 0481           ;          angle -> X+5
 0481           ;             ID -> X+4
 0481           ;          total -> X+2
 0481           ;          param -> X+0
 0481           _decodeTransmission::
 0481                   .dbline -1
 0481 10                push X
 0482 4F                mov X,SP
 0483 3808              add SP,8
 0485                   .dbline 379
 0485           ; }
 0485           ; 
 0485           ; // This function decodes the transmission and takes the correct action.
 0485           ; void decodeTransmission(void)
 0485           ; {
 0485                   .dbline 384
 0485           ;       char* param;
 0485           ;       char ID;
 0485           ;       char tempByte;
 0485           ;       char angle[2];
 0485           ;       int total = 0;
 0485 560300            mov [X+3],0
 0488 560200            mov [X+2],0
 048B                   .dbline 386
 048B           ;       
 048B           ;       if(param = COMP_SERIAL_szGetParam())
 048B 10                push X
 048C 7C0000            xcall _COMP_SERIAL_szGetParam
 048F 62D000            mov REG[0xd0],>__r0
 0492 5300              mov [__r0],A
 0494 5A00              mov [__r1],X
 0496 20                pop X
 0497 5100              mov A,[__r1]
 0499 5401              mov [X+1],A
 049B 5100              mov A,[__r0]
 049D 5400              mov [X+0],A
 049F 3C0000            cmp [__r0],0
 04A2 B006              jnz X22
 04A4 3C0000            cmp [__r1],0
 04A7 A557              jz L96
 04A9           X22:
 04A9                   .dbline 387
 04A9           ;       {
 04A9                   .dbline 388
 04A9           ;               if((param[0] == 'n') || (param[0] == 'N'))
 04A9 62D000            mov REG[0xd0],>__r0
 04AC 5201              mov A,[X+1]
 04AE 5300              mov [__r1],A
 04B0 5200              mov A,[X+0]
 04B2 60D4              mov REG[0xd4],A
 04B4 3E00              mvi A,[__r1]
 04B6 5300              mov [__r1],A
 04B8 550000            mov [__r0],0
 04BB 3C0000            cmp [__r0],0
 04BE B005              jnz X23
 04C0 396E              cmp A,110
 04C2 A00E              jz L100
 04C4           X23:
 04C4 62D000            mov REG[0xd0],>__r0
 04C7 3C0000            cmp [__r0],0
 04CA B03A              jnz L98
 04CC 3C004E            cmp [__r1],78
 04CF B035              jnz L98
 04D1           X24:
 04D1           L100:
 04D1                   .dbline 389
 04D1           ;               {
 04D1                   .dbline 390
 04D1           ;                       COMP_SERIAL_CmdReset();
 04D1 10                push X
 04D2 7C0000            xcall _COMP_SERIAL_CmdReset
 04D5 20                pop X
 04D6                   .dbline 391
 04D6           ;                       itoa(param,NUM_MODULES,10);
 04D6 5000              mov A,0
 04D8 08                push A
 04D9 500A              mov A,10
 04DB 08                push A
 04DC 62D000            mov REG[0xd0],>_NUM_MODULES
 04DF 5100              mov A,[_NUM_MODULES]
 04E1 08                push A
 04E2 5101              mov A,[_NUM_MODULES+1]
 04E4 08                push A
 04E5 5200              mov A,[X+0]
 04E7 08                push A
 04E8 5201              mov A,[X+1]
 04EA 08                push A
 04EB 7C0000            xcall _itoa
 04EE 38FA              add SP,-6
 04F0                   .dbline 392
 04F0           ;                       COMP_SERIAL_PutString(param);
 04F0 10                push X
 04F1 5200              mov A,[X+0]
 04F3 08                push A
 04F4 5201              mov A,[X+1]
 04F6 5C                mov X,A
 04F7 18                pop A
 04F8 7C0000            xcall _COMP_SERIAL_PutString
 04FB 20                pop X
 04FC                   .dbline 393
 04FC           ;                       COMP_SERIAL_PutChar('\n');
 04FC 10                push X
 04FD 500A              mov A,10
 04FF 7C0000            xcall _COMP_SERIAL_PutChar
 0502 20                pop X
 0503                   .dbline 394
 0503           ;               }
 0503 84FB              xjmp L99
 0505           L98:
 0505                   .dbline 395
 0505           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 0505 62D000            mov REG[0xd0],>__r0
 0508 5201              mov A,[X+1]
 050A 5300              mov [__r1],A
 050C 5200              mov A,[X+0]
 050E 60D4              mov REG[0xd4],A
 0510 3E00              mvi A,[__r1]
 0512 5300              mov [__r1],A
 0514 550000            mov [__r0],0
 0517 3C0000            cmp [__r0],0
 051A B005              jnz X25
 051C 3977              cmp A,119
 051E A00E              jz L103
 0520           X25:
 0520 62D000            mov REG[0xd0],>__r0
 0523 3C0000            cmp [__r0],0
 0526 B16B              jnz L101
 0528 3C0057            cmp [__r1],87
 052B B166              jnz L101
 052D           X26:
 052D           L103:
 052D                   .dbline 396
 052D           ;               {
 052D                   .dbline 397
 052D           ;                       if(param = COMP_SERIAL_szGetParam())
 052D 10                push X
 052E 7C0000            xcall _COMP_SERIAL_szGetParam
 0531 62D000            mov REG[0xd0],>__r0
 0534 5300              mov [__r0],A
 0536 5A00              mov [__r1],X
 0538 20                pop X
 0539 5100              mov A,[__r1]
 053B 5401              mov [X+1],A
 053D 5100              mov A,[__r0]
 053F 5400              mov [X+0],A
 0541 3C0000            cmp [__r0],0
 0544 B006              jnz X27
 0546 3C0000            cmp [__r1],0
 0549 A4B5              jz L102
 054B           X27:
 054B                   .dbline 398
 054B           ;                       {
 054B                   .dbline 399
 054B           ;                               ID = atoi(param);
 054B 5200              mov A,[X+0]
 054D 08                push A
 054E 5201              mov A,[X+1]
 0550 08                push A
 0551 7C0000            xcall _atoi
 0554 38FE              add SP,-2
 0556 62D000            mov REG[0xd0],>__r0
 0559 5100              mov A,[__r1]
 055B 5404              mov [X+4],A
 055D                   .dbline 400
 055D           ;                               if(param = COMP_SERIAL_szGetParam())
 055D 10                push X
 055E 7C0000            xcall _COMP_SERIAL_szGetParam
 0561 62D000            mov REG[0xd0],>__r0
 0564 5300              mov [__r0],A
 0566 5A00              mov [__r1],X
 0568 20                pop X
 0569 5100              mov A,[__r1]
 056B 5401              mov [X+1],A
 056D 5100              mov A,[__r0]
 056F 5400              mov [X+0],A
 0571 3C0000            cmp [__r0],0
 0574 B006              jnz X28
 0576 3C0000            cmp [__r1],0
 0579 A485              jz L102
 057B           X28:
 057B                   .dbline 401
 057B           ;                               {
 057B                   .dbline 402
 057B           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 057B 62D000            mov REG[0xd0],>__r0
 057E 5201              mov A,[X+1]
 0580 5300              mov [__r1],A
 0582 5200              mov A,[X+0]
 0584 60D4              mov REG[0xd4],A
 0586 3E00              mvi A,[__r1]
 0588 5300              mov [__r1],A
 058A 550000            mov [__r0],0
 058D 3C0000            cmp [__r0],0
 0590 B005              jnz X29
 0592 3961              cmp A,97
 0594 A00E              jz L110
 0596           X29:
 0596 62D000            mov REG[0xd0],>__r0
 0599 3C0000            cmp [__r0],0
 059C B089              jnz L108
 059E 3C0041            cmp [__r1],65
 05A1 B084              jnz L108
 05A3           X30:
 05A3           L110:
 05A3                   .dbline 403
 05A3           ;                                       {
 05A3                   .dbline 404
 05A3           ;                                               if(param = COMP_SERIAL_szGetParam())
 05A3 10                push X
 05A4 7C0000            xcall _COMP_SERIAL_szGetParam
 05A7 62D000            mov REG[0xd0],>__r0
 05AA 5300              mov [__r0],A
 05AC 5A00              mov [__r1],X
 05AE 20                pop X
 05AF 5100              mov A,[__r1]
 05B1 5401              mov [X+1],A
 05B3 5100              mov A,[__r0]
 05B5 5400              mov [X+0],A
 05B7 3C0000            cmp [__r0],0
 05BA B006              jnz X31
 05BC 3C0000            cmp [__r1],0
 05BF A43F              jz L102
 05C1           X31:
 05C1                   .dbline 405
 05C1           ;                                               {
 05C1                   .dbline 406
 05C1           ;                                                       COMP_SERIAL_CmdReset();
 05C1 10                push X
 05C2 7C0000            xcall _COMP_SERIAL_CmdReset
 05C5 20                pop X
 05C6                   .dbline 407
 05C6           ;                                                       total = atoi(param);
 05C6 5200              mov A,[X+0]
 05C8 08                push A
 05C9 5201              mov A,[X+1]
 05CB 08                push A
 05CC 7C0000            xcall _atoi
 05CF 38FE              add SP,-2
 05D1 62D000            mov REG[0xd0],>__r0
 05D4 5100              mov A,[__r1]
 05D6 5403              mov [X+3],A
 05D8 5100              mov A,[__r0]
 05DA 5402              mov [X+2],A
 05DC                   .dbline 408
 05DC           ;                                                       angle[0] = total%256;
 05DC 5001              mov A,1
 05DE 08                push A
 05DF 5000              mov A,0
 05E1 08                push A
 05E2 5202              mov A,[X+2]
 05E4 08                push A
 05E5 5203              mov A,[X+3]
 05E7 08                push A
 05E8 7C0000            xcall __divmod_16X16_16
 05EB 38FE              add SP,-2
 05ED 18                pop A
 05EE 5300              mov [__r1],A
 05F0 18                pop A
 05F1 5100              mov A,[__r1]
 05F3 5405              mov [X+5],A
 05F5                   .dbline 409
 05F5           ;                                                       angle[1] = total/256;
 05F5 5001              mov A,1
 05F7 08                push A
 05F8 5000              mov A,0
 05FA 08                push A
 05FB 5202              mov A,[X+2]
 05FD 08                push A
 05FE 5203              mov A,[X+3]
 0600 08                push A
 0601 7C0000            xcall __divmod_16X16_16
 0604 18                pop A
 0605 5300              mov [__r1],A
 0607 18                pop A
 0608 38FE              add SP,-2
 060A 5100              mov A,[__r1]
 060C 5406              mov [X+6],A
 060E                   .dbline 410
 060E           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 060E 5206              mov A,[X+6]
 0610 08                push A
 0611 5205              mov A,[X+5]
 0613 08                push A
 0614 501E              mov A,30
 0616 08                push A
 0617 5003              mov A,3
 0619 08                push A
 061A 5005              mov A,5
 061C 08                push A
 061D 5204              mov A,[X+4]
 061F 08                push A
 0620 94AE              xcall _longServoInstruction
 0622 38FA              add SP,-6
 0624                   .dbline 411
 0624           ;                                               }
 0624                   .dbline 412
 0624           ;                                       }
 0624 83DA              xjmp L102
 0626           L108:
 0626                   .dbline 413
 0626           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 0626 62D000            mov REG[0xd0],>__r0
 0629 5201              mov A,[X+1]
 062B 5300              mov [__r1],A
 062D 5200              mov A,[X+0]
 062F 60D4              mov REG[0xd4],A
 0631 3E00              mvi A,[__r1]
 0633 5300              mov [__r1],A
 0635 550000            mov [__r0],0
 0638 3C0000            cmp [__r0],0
 063B B005              jnz X32
 063D 3970              cmp A,112
 063F A00E              jz L117
 0641           X32:
 0641 62D000            mov REG[0xd0],>__r0
 0644 3C0000            cmp [__r0],0
 0647 B3B7              jnz L102
 0649 3C0050            cmp [__r1],80
 064C B3B2              jnz L102
 064E           X33:
 064E           L117:
 064E                   .dbline 414
 064E           ;                                       {
 064E                   .dbline 415
 064E           ;                                               if(param = COMP_SERIAL_szGetParam())
 064E 10                push X
 064F 7C0000            xcall _COMP_SERIAL_szGetParam
 0652 62D000            mov REG[0xd0],>__r0
 0655 5300              mov [__r0],A
 0657 5A00              mov [__r1],X
 0659 20                pop X
 065A 5100              mov A,[__r1]
 065C 5401              mov [X+1],A
 065E 5100              mov A,[__r0]
 0660 5400              mov [X+0],A
 0662 3C0000            cmp [__r0],0
 0665 B006              jnz X34
 0667 3C0000            cmp [__r1],0
 066A A394              jz L102
 066C           X34:
 066C                   .dbline 416
 066C           ;                                               {
 066C                   .dbline 417
 066C           ;                                                       COMP_SERIAL_CmdReset();
 066C 10                push X
 066D 7C0000            xcall _COMP_SERIAL_CmdReset
 0670 20                pop X
 0671                   .dbline 418
 0671           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0671 5200              mov A,[X+0]
 0673 08                push A
 0674 5201              mov A,[X+1]
 0676 08                push A
 0677 7C0000            xcall _atoi
 067A 62D000            mov REG[0xd0],>__r0
 067D 5100              mov A,[__r1]
 067F 08                push A
 0680 5018              mov A,24
 0682 08                push A
 0683 5003              mov A,3
 0685 08                push A
 0686 5004              mov A,4
 0688 08                push A
 0689 5204              mov A,[X+4]
 068B 08                push A
 068C 939F              xcall _servoInstruction
 068E 38F9              add SP,-7
 0690                   .dbline 419
 0690           ;                                               }
 0690                   .dbline 420
 0690           ;                                       }
 0690                   .dbline 421
 0690           ;                               }
 0690                   .dbline 422
 0690           ;                       }
 0690                   .dbline 423
 0690           ;               }
 0690 836E              xjmp L102
 0692           L101:
 0692                   .dbline 424
 0692           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 0692 62D000            mov REG[0xd0],>__r0
 0695 5201              mov A,[X+1]
 0697 5300              mov [__r1],A
 0699 5200              mov A,[X+0]
 069B 60D4              mov REG[0xd4],A
 069D 3E00              mvi A,[__r1]
 069F 5300              mov [__r1],A
 06A1 550000            mov [__r0],0
 06A4 3C0000            cmp [__r0],0
 06A7 B005              jnz X35
 06A9 3972              cmp A,114
 06AB A00E              jz L122
 06AD           X35:
 06AD 62D000            mov REG[0xd0],>__r0
 06B0 3C0000            cmp [__r0],0
 06B3 B34B              jnz L120
 06B5 3C0052            cmp [__r1],82
 06B8 B346              jnz L120
 06BA           X36:
 06BA           L122:
 06BA                   .dbline 425
 06BA           ;               {                       
 06BA                   .dbline 426
 06BA           ;                       if(param = COMP_SERIAL_szGetParam())
 06BA 10                push X
 06BB 7C0000            xcall _COMP_SERIAL_szGetParam
 06BE 62D000            mov REG[0xd0],>__r0
 06C1 5300              mov [__r0],A
 06C3 5A00              mov [__r1],X
 06C5 20                pop X
 06C6 5100              mov A,[__r1]
 06C8 5401              mov [X+1],A
 06CA 5100              mov A,[__r0]
 06CC 5400              mov [X+0],A
 06CE 3C0000            cmp [__r0],0
 06D1 B006              jnz X37
 06D3 3C0000            cmp [__r1],0
 06D6 A328              jz L123
 06D8           X37:
 06D8                   .dbline 427
 06D8           ;                       {
 06D8                   .dbline 428
 06D8           ;                               ID = atoi(param);
 06D8 5200              mov A,[X+0]
 06DA 08                push A
 06DB 5201              mov A,[X+1]
 06DD 08                push A
 06DE 7C0000            xcall _atoi
 06E1 38FE              add SP,-2
 06E3 62D000            mov REG[0xd0],>__r0
 06E6 5100              mov A,[__r1]
 06E8 5404              mov [X+4],A
 06EA                   .dbline 429
 06EA           ;                               if(param = COMP_SERIAL_szGetParam())
 06EA 10                push X
 06EB 7C0000            xcall _COMP_SERIAL_szGetParam
 06EE 62D000            mov REG[0xd0],>__r0
 06F1 5300              mov [__r0],A
 06F3 5A00              mov [__r1],X
 06F5 20                pop X
 06F6 5100              mov A,[__r1]
 06F8 5401              mov [X+1],A
 06FA 5100              mov A,[__r0]
 06FC 5400              mov [X+0],A
 06FE 3C0000            cmp [__r0],0
 0701 B006              jnz X38
 0703 3C0000            cmp [__r1],0
 0706 A2F8              jz L125
 0708           X38:
 0708                   .dbline 430
 0708           ;                               {
 0708                   .dbline 431
 0708           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0708 62D000            mov REG[0xd0],>__r0
 070B 5201              mov A,[X+1]
 070D 5300              mov [__r1],A
 070F 5200              mov A,[X+0]
 0711 60D4              mov REG[0xd4],A
 0713 3E00              mvi A,[__r1]
 0715 5300              mov [__r1],A
 0717 550000            mov [__r0],0
 071A 3C0000            cmp [__r0],0
 071D B005              jnz X39
 071F 3961              cmp A,97
 0721 A00E              jz L129
 0723           X39:
 0723 62D000            mov REG[0xd0],>__r0
 0726 3C0000            cmp [__r0],0
 0729 B0D2              jnz L127
 072B 3C0041            cmp [__r1],65
 072E B0CD              jnz L127
 0730           X40:
 0730           L129:
 0730                   .dbline 432
 0730           ;                                       {
 0730                   .dbline 433
 0730           ;                                               COMP_SERIAL_CmdReset();
 0730 10                push X
 0731 7C0000            xcall _COMP_SERIAL_CmdReset
 0734 20                pop X
 0735                   .dbline 434
 0735           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 0735 5002              mov A,2
 0737 08                push A
 0738 5024              mov A,36
 073A 08                push A
 073B 5002              mov A,2
 073D 08                push A
 073E 5004              mov A,4
 0740 08                push A
 0741 5204              mov A,[X+4]
 0743 08                push A
 0744 92E7              xcall _servoInstruction
 0746                   .dbline 435
 0746           ;                                               configToggle(RX_MODE);
 0746 5000              mov A,0
 0748 08                push A
 0749 5001              mov A,1
 074B 08                push A
 074C 9433              xcall _configToggle
 074E 38F9              add SP,-7
 0750 809A              xjmp L131
 0752           L130:
 0752                   .dbline 439
 0752           ;                                                       
 0752           ;                                               // Loop until we read a response or time out.
 0752           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0752           ;                                               {
 0752                   .dbline 440
 0752           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0752 10                push X
 0753 7C0000            xcall _RECEIVE_cReadChar
 0756 62D000            mov REG[0xd0],>__r0
 0759 20                pop X
 075A 39FF              cmp A,-1
 075C B08E              jnz L133
 075E                   .dbline 441
 075E           ;                                                       {
 075E                   .dbline 442
 075E           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 075E 10                push X
 075F 7C0000            xcall _RECEIVE_cGetChar
 0762 62D000            mov REG[0xd0],>__r0
 0765 20                pop X
 0766 39FF              cmp A,-1
 0768 B082              jnz L135
 076A                   .dbline 443
 076A           ;                                                               {
 076A                   .dbline 444
 076A           ;                                                                       if(RECEIVE_cGetChar() == ID)
 076A 10                push X
 076B 7C0000            xcall _RECEIVE_cGetChar
 076E 62D000            mov REG[0xd0],>__r0
 0771 20                pop X
 0772 3B04              cmp A,[X+4]
 0774 B076              jnz L137
 0776                   .dbline 445
 0776           ;                                                                       {
 0776                   .dbline 446
 0776           ;                                                                               if(RECEIVE_cGetChar() == 4)
 0776 10                push X
 0777 7C0000            xcall _RECEIVE_cGetChar
 077A 62D000            mov REG[0xd0],>__r0
 077D 20                pop X
 077E 3904              cmp A,4
 0780 B06A              jnz L139
 0782                   .dbline 447
 0782           ;                                                                               {
 0782                   .dbline 448
 0782           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0782 10                push X
 0783 7C0000            xcall _RECEIVE_cGetChar
 0786 20                pop X
 0787 3900              cmp A,0
 0789 B061              jnz L141
 078B                   .dbline 449
 078B           ;                                                                                       {
 078B                   .dbline 451
 078B           ;                                                                                               // Reset module fails.
 078B           ;                                                                                               MODULE_FAIL = 0;
 078B 62D000            mov REG[0xd0],>_MODULE_FAIL
 078E 550100            mov [_MODULE_FAIL+1],0
 0791 550000            mov [_MODULE_FAIL],0
 0794                   .dbline 453
 0794           ;                                                                                               
 0794           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 0794 10                push X
 0795 7C0000            xcall _RECEIVE_cGetChar
 0798 62D000            mov REG[0xd0],>__r0
 079B 20                pop X
 079C 5405              mov [X+5],A
 079E                   .dbline 454
 079E           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 079E 10                push X
 079F 7C0000            xcall _RECEIVE_cGetChar
 07A2 62D000            mov REG[0xd0],>__r0
 07A5 20                pop X
 07A6 5406              mov [X+6],A
 07A8                   .dbline 456
 07A8           ;                                                                                               
 07A8           ;                                                                                               configToggle(PC_MODE);
 07A8 5000              mov A,0
 07AA 08                push A
 07AB 5002              mov A,2
 07AD 08                push A
 07AE 93D1              xcall _configToggle
 07B0                   .dbline 458
 07B0           ;                                                                                               
 07B0           ;                                                                                               total = ((angle[1])*256) + angle[0];
 07B0 5205              mov A,[X+5]
 07B2 5403              mov [X+3],A
 07B4 5206              mov A,[X+6]
 07B6 5402              mov [X+2],A
 07B8                   .dbline 459
 07B8           ;                                                                                               itoa(param,total,10);
 07B8 5000              mov A,0
 07BA 08                push A
 07BB 500A              mov A,10
 07BD 08                push A
 07BE 5202              mov A,[X+2]
 07C0 08                push A
 07C1 5203              mov A,[X+3]
 07C3 08                push A
 07C4 5200              mov A,[X+0]
 07C6 08                push A
 07C7 5201              mov A,[X+1]
 07C9 08                push A
 07CA 7C0000            xcall _itoa
 07CD 38F8              add SP,-8
 07CF                   .dbline 460
 07CF           ;                                                                                               COMP_SERIAL_PutString(param);
 07CF 10                push X
 07D0 5200              mov A,[X+0]
 07D2 08                push A
 07D3 5201              mov A,[X+1]
 07D5 5C                mov X,A
 07D6 18                pop A
 07D7 7C0000            xcall _COMP_SERIAL_PutString
 07DA 20                pop X
 07DB                   .dbline 461
 07DB           ;                                                                                               COMP_SERIAL_PutChar('\n');
 07DB 10                push X
 07DC 500A              mov A,10
 07DE 7C0000            xcall _COMP_SERIAL_PutChar
 07E1 20                pop X
 07E2                   .dbline 463
 07E2           ; 
 07E2           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 07E2 62D000            mov REG[0xd0],>_TIMEOUT
 07E5 550105            mov [_TIMEOUT+1],5
 07E8 550000            mov [_TIMEOUT],0
 07EB                   .dbline 464
 07EB           ;                                                                                       }
 07EB           L141:
 07EB                   .dbline 465
 07EB           ;                                                                               }
 07EB           L139:
 07EB                   .dbline 466
 07EB           ;                                                                       }
 07EB           L137:
 07EB                   .dbline 467
 07EB           ;                                                               }
 07EB           L135:
 07EB                   .dbline 468
 07EB           ;                                                       }
 07EB           L133:
 07EB                   .dbline 469
 07EB           ;                                               }
 07EB           L131:
 07EB                   .dbline 438
 07EB 62D000            mov REG[0xd0],>_TIMEOUT
 07EE 5101              mov A,[_TIMEOUT+1]
 07F0 1105              sub A,5
 07F2 5100              mov A,[_TIMEOUT]
 07F4 3180              xor A,-128
 07F6 1980              sbb A,(0 ^ 0x80)
 07F8 CF59              jc L130
 07FA           X41:
 07FA                   .dbline 470
 07FA           ;                                       }
 07FA 8204              xjmp L128
 07FC           L127:
 07FC                   .dbline 471
 07FC           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07FC 62D000            mov REG[0xd0],>__r0
 07FF 5201              mov A,[X+1]
 0801 5300              mov [__r1],A
 0803 5200              mov A,[X+0]
 0805 60D4              mov REG[0xd4],A
 0807 3E00              mvi A,[__r1]
 0809 5300              mov [__r1],A
 080B 550000            mov [__r0],0
 080E 3C0000            cmp [__r0],0
 0811 B005              jnz X42
 0813 3970              cmp A,112
 0815 A00E              jz L147
 0817           X42:
 0817 62D000            mov REG[0xd0],>__r0
 081A 3C0000            cmp [__r0],0
 081D B0CF              jnz L145
 081F 3C0050            cmp [__r1],80
 0822 B0CA              jnz L145
 0824           X43:
 0824           L147:
 0824                   .dbline 472
 0824           ;                                       {
 0824                   .dbline 473
 0824           ;                                               COMP_SERIAL_CmdReset();
 0824 10                push X
 0825 7C0000            xcall _COMP_SERIAL_CmdReset
 0828 20                pop X
 0829                   .dbline 474
 0829           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 0829 5001              mov A,1
 082B 08                push A
 082C 5018              mov A,24
 082E 08                push A
 082F 5002              mov A,2
 0831 08                push A
 0832 5004              mov A,4
 0834 08                push A
 0835 5204              mov A,[X+4]
 0837 08                push A
 0838 91F3              xcall _servoInstruction
 083A                   .dbline 475
 083A           ;                                               configToggle(RX_MODE);
 083A 5000              mov A,0
 083C 08                push A
 083D 5001              mov A,1
 083F 08                push A
 0840 933F              xcall _configToggle
 0842 38F9              add SP,-7
 0844 8097              xjmp L149
 0846           L148:
 0846                   .dbline 479
 0846           ;                                                       
 0846           ;                                               // Loop until we read a response or time out.
 0846           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0846           ;                                               {
 0846                   .dbline 480
 0846           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0846 10                push X
 0847 7C0000            xcall _RECEIVE_cReadChar
 084A 62D000            mov REG[0xd0],>__r0
 084D 20                pop X
 084E 39FF              cmp A,-1
 0850 B08B              jnz L151
 0852                   .dbline 481
 0852           ;                                                       {
 0852                   .dbline 482
 0852           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0852 10                push X
 0853 7C0000            xcall _RECEIVE_cGetChar
 0856 62D000            mov REG[0xd0],>__r0
 0859 20                pop X
 085A 39FF              cmp A,-1
 085C B07F              jnz L153
 085E                   .dbline 483
 085E           ;                                                               {
 085E                   .dbline 484
 085E           ;                                                                       if(RECEIVE_cGetChar() == ID)
 085E 10                push X
 085F 7C0000            xcall _RECEIVE_cGetChar
 0862 62D000            mov REG[0xd0],>__r0
 0865 20                pop X
 0866 3B04              cmp A,[X+4]
 0868 B073              jnz L155
 086A                   .dbline 485
 086A           ;                                                                       {
 086A                   .dbline 487
 086A           ;                                                                               // Check the length of the packet.
 086A           ;                                                                               if(RECEIVE_cGetChar() == 3)
 086A 10                push X
 086B 7C0000            xcall _RECEIVE_cGetChar
 086E 62D000            mov REG[0xd0],>__r0
 0871 20                pop X
 0872 3903              cmp A,3
 0874 B067              jnz L157
 0876                   .dbline 488
 0876           ;                                                                               {
 0876                   .dbline 490
 0876           ;                                                                                       // Check to see that there were no errors.
 0876           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0876 10                push X
 0877 7C0000            xcall _RECEIVE_cGetChar
 087A 20                pop X
 087B 3900              cmp A,0
 087D B05E              jnz L159
 087F                   .dbline 491
 087F           ;                                                                                       {
 087F                   .dbline 493
 087F           ;                                                                                               // Reset module fails.
 087F           ;                                                                                               MODULE_FAIL = 0;
 087F 62D000            mov REG[0xd0],>_MODULE_FAIL
 0882 550100            mov [_MODULE_FAIL+1],0
 0885 550000            mov [_MODULE_FAIL],0
 0888                   .dbline 495
 0888           ;                                                                                               
 0888           ;                                                                                               tempByte = RECEIVE_cGetChar();
 0888 10                push X
 0889 7C0000            xcall _RECEIVE_cGetChar
 088C 62D000            mov REG[0xd0],>__r0
 088F 20                pop X
 0890 5407              mov [X+7],A
 0892                   .dbline 497
 0892           ;                                                                                               
 0892           ;                                                                                               configToggle(PC_MODE);
 0892 5000              mov A,0
 0894 08                push A
 0895 5002              mov A,2
 0897 08                push A
 0898 92E7              xcall _configToggle
 089A                   .dbline 500
 089A           ;                                                                                               
 089A           ;                                                                                               // Convert tempByte to an ascii value and send.
 089A           ;                                                                                               total = tempByte + 48;
 089A 62D000            mov REG[0xd0],>__r0
 089D 5207              mov A,[X+7]
 089F 0130              add A,48
 08A1 5403              mov [X+3],A
 08A3 5000              mov A,0
 08A5 0900              adc A,0
 08A7 5402              mov [X+2],A
 08A9                   .dbline 501
 08A9           ;                                                                                               itoa(param,total,10);
 08A9 5000              mov A,0
 08AB 08                push A
 08AC 500A              mov A,10
 08AE 08                push A
 08AF 5202              mov A,[X+2]
 08B1 08                push A
 08B2 5203              mov A,[X+3]
 08B4 08                push A
 08B5 5200              mov A,[X+0]
 08B7 08                push A
 08B8 5201              mov A,[X+1]
 08BA 08                push A
 08BB 7C0000            xcall _itoa
 08BE 38F8              add SP,-8
 08C0                   .dbline 502
 08C0           ;                                                                                               COMP_SERIAL_PutString(param);
 08C0 10                push X
 08C1 5200              mov A,[X+0]
 08C3 08                push A
 08C4 5201              mov A,[X+1]
 08C6 5C                mov X,A
 08C7 18                pop A
 08C8 7C0000            xcall _COMP_SERIAL_PutString
 08CB 20                pop X
 08CC                   .dbline 503
 08CC           ;                                                                                               COMP_SERIAL_PutChar('\n');
 08CC 10                push X
 08CD 500A              mov A,10
 08CF 7C0000            xcall _COMP_SERIAL_PutChar
 08D2 20                pop X
 08D3                   .dbline 505
 08D3           ; 
 08D3           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 08D3 62D000            mov REG[0xd0],>_TIMEOUT
 08D6 550105            mov [_TIMEOUT+1],5
 08D9 550000            mov [_TIMEOUT],0
 08DC                   .dbline 506
 08DC           ;                                                                                       }
 08DC           L159:
 08DC                   .dbline 507
 08DC           ;                                                                               }
 08DC           L157:
 08DC                   .dbline 508
 08DC           ;                                                                       }
 08DC           L155:
 08DC                   .dbline 509
 08DC           ;                                                               }
 08DC           L153:
 08DC                   .dbline 510
 08DC           ;                                                       }
 08DC           L151:
 08DC                   .dbline 511
 08DC           ;                                               }
 08DC           L149:
 08DC                   .dbline 478
 08DC 62D000            mov REG[0xd0],>_TIMEOUT
 08DF 5101              mov A,[_TIMEOUT+1]
 08E1 1105              sub A,5
 08E3 5100              mov A,[_TIMEOUT]
 08E5 3180              xor A,-128
 08E7 1980              sbb A,(0 ^ 0x80)
 08E9 CF5C              jc L148
 08EB           X44:
 08EB                   .dbline 512
 08EB           ;                                       }
 08EB 8113              xjmp L146
 08ED           L145:
 08ED                   .dbline 513
 08ED           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 08ED 62D000            mov REG[0xd0],>__r0
 08F0 5201              mov A,[X+1]
 08F2 5300              mov [__r1],A
 08F4 5200              mov A,[X+0]
 08F6 60D4              mov REG[0xd4],A
 08F8 3E00              mvi A,[__r1]
 08FA 5300              mov [__r1],A
 08FC 550000            mov [__r0],0
 08FF 3C0000            cmp [__r0],0
 0902 B005              jnz X45
 0904 3974              cmp A,116
 0906 A00E              jz L163
 0908           X45:
 0908 62D000            mov REG[0xd0],>__r0
 090B 3C0000            cmp [__r0],0
 090E B068              jnz L161
 0910 3C0054            cmp [__r1],84
 0913 B063              jnz L161
 0915           X46:
 0915           L163:
 0915                   .dbline 514
 0915           ;                                       {
 0915                   .dbline 515
 0915           ;                                               COMP_SERIAL_CmdReset();
 0915 10                push X
 0916 7C0000            xcall _COMP_SERIAL_CmdReset
 0919 20                pop X
 091A                   .dbline 516
 091A           ;                                               if(pingModule(ID))
 091A 62D000            mov REG[0xd0],>__r0
 091D 5204              mov A,[X+4]
 091F 5300              mov [__r1],A
 0921 5000              mov A,0
 0923 08                push A
 0924 5100              mov A,[__r1]
 0926 08                push A
 0927 7C0058            xcall _pingModule
 092A 38FE              add SP,-2
 092C 62D000            mov REG[0xd0],>__r0
 092F 3C0000            cmp [__r0],0
 0932 B006              jnz X47
 0934 3C0000            cmp [__r1],0
 0937 A0C7              jz L162
 0939           X47:
 0939                   .dbline 517
 0939           ;                                               {
 0939                   .dbline 518
 0939           ;                                                       configToggle(PC_MODE);
 0939 5000              mov A,0
 093B 08                push A
 093C 5002              mov A,2
 093E 08                push A
 093F 9240              xcall _configToggle
 0941                   .dbline 520
 0941           ;                                                                                               
 0941           ;                                                       total = PARAM[0];
 0941 62D000            mov REG[0xd0],>_PARAM
 0944 5100              mov A,[_PARAM]
 0946 5403              mov [X+3],A
 0948 560200            mov [X+2],0
 094B                   .dbline 521
 094B           ;                                                       itoa(param,total,10);
 094B 5000              mov A,0
 094D 08                push A
 094E 500A              mov A,10
 0950 08                push A
 0951 5202              mov A,[X+2]
 0953 08                push A
 0954 5203              mov A,[X+3]
 0956 08                push A
 0957 5200              mov A,[X+0]
 0959 08                push A
 095A 5201              mov A,[X+1]
 095C 08                push A
 095D 7C0000            xcall _itoa
 0960 38F8              add SP,-8
 0962                   .dbline 522
 0962           ;                                                       COMP_SERIAL_PutString(param);
 0962 10                push X
 0963 5200              mov A,[X+0]
 0965 08                push A
 0966 5201              mov A,[X+1]
 0968 5C                mov X,A
 0969 18                pop A
 096A 7C0000            xcall _COMP_SERIAL_PutString
 096D 20                pop X
 096E                   .dbline 523
 096E           ;                                                       COMP_SERIAL_PutChar('\n');
 096E 10                push X
 096F 500A              mov A,10
 0971 7C0000            xcall _COMP_SERIAL_PutChar
 0974 20                pop X
 0975                   .dbline 524
 0975           ;                                               }
 0975                   .dbline 525
 0975           ;                                       }
 0975 8089              xjmp L162
 0977           L161:
 0977                   .dbline 526
 0977           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0977 62D000            mov REG[0xd0],>__r0
 097A 5201              mov A,[X+1]
 097C 5300              mov [__r1],A
 097E 5200              mov A,[X+0]
 0980 60D4              mov REG[0xd4],A
 0982 3E00              mvi A,[__r1]
 0984 5300              mov [__r1],A
 0986 550000            mov [__r0],0
 0989 3C0000            cmp [__r0],0
 098C B005              jnz X48
 098E 3963              cmp A,99
 0990 A00E              jz L168
 0992           X48:
 0992 62D000            mov REG[0xd0],>__r0
 0995 3C0000            cmp [__r0],0
 0998 B066              jnz L166
 099A 3C0043            cmp [__r1],67
 099D B061              jnz L166
 099F           X49:
 099F           L168:
 099F                   .dbline 527
 099F           ;                                       {
 099F                   .dbline 528
 099F           ;                                               COMP_SERIAL_CmdReset();
 099F 10                push X
 09A0 7C0000            xcall _COMP_SERIAL_CmdReset
 09A3 20                pop X
 09A4                   .dbline 529
 09A4           ;                                               if(pingModule(ID))
 09A4 62D000            mov REG[0xd0],>__r0
 09A7 5204              mov A,[X+4]
 09A9 5300              mov [__r1],A
 09AB 5000              mov A,0
 09AD 08                push A
 09AE 5100              mov A,[__r1]
 09B0 08                push A
 09B1 7C0058            xcall _pingModule
 09B4 38FE              add SP,-2
 09B6 62D000            mov REG[0xd0],>__r0
 09B9 3C0000            cmp [__r0],0
 09BC B006              jnz X50
 09BE 3C0000            cmp [__r1],0
 09C1 A03D              jz L169
 09C3           X50:
 09C3                   .dbline 530
 09C3           ;                                               {       
 09C3                   .dbline 531
 09C3           ;                                                       configToggle(PC_MODE);
 09C3 5000              mov A,0
 09C5 08                push A
 09C6 5002              mov A,2
 09C8 08                push A
 09C9 91B6              xcall _configToggle
 09CB                   .dbline 533
 09CB           ;                                                       
 09CB           ;                                                       total = PARAM[1];
 09CB 62D000            mov REG[0xd0],>_PARAM
 09CE 5101              mov A,[_PARAM+1]
 09D0 5403              mov [X+3],A
 09D2 560200            mov [X+2],0
 09D5                   .dbline 534
 09D5           ;                                                       itoa(param,total,10);
 09D5 5000              mov A,0
 09D7 08                push A
 09D8 500A              mov A,10
 09DA 08                push A
 09DB 5202              mov A,[X+2]
 09DD 08                push A
 09DE 5203              mov A,[X+3]
 09E0 08                push A
 09E1 5200              mov A,[X+0]
 09E3 08                push A
 09E4 5201              mov A,[X+1]
 09E6 08                push A
 09E7 7C0000            xcall _itoa
 09EA 38F8              add SP,-8
 09EC                   .dbline 535
 09EC           ;                                                       COMP_SERIAL_PutString(param);
 09EC 10                push X
 09ED 5200              mov A,[X+0]
 09EF 08                push A
 09F0 5201              mov A,[X+1]
 09F2 5C                mov X,A
 09F3 18                pop A
 09F4 7C0000            xcall _COMP_SERIAL_PutString
 09F7 20                pop X
 09F8                   .dbline 536
 09F8           ;                                                       COMP_SERIAL_PutChar('\n');
 09F8 10                push X
 09F9 500A              mov A,10
 09FB 7C0000            xcall _COMP_SERIAL_PutChar
 09FE 20                pop X
 09FF                   .dbline 537
 09FF           ;                                               }
 09FF           L169:
 09FF                   .dbline 538
 09FF           ;                                       }
 09FF           L166:
 09FF           L162:
 09FF           L146:
 09FF           L128:
 09FF                   .dbline 539
 09FF           ;                               }
 09FF           L125:
 09FF                   .dbline 540
 09FF           ;                       }
 09FF           L123:
 09FF                   .dbline 541
 09FF           ;               }
 09FF           L120:
 09FF           L102:
 09FF           L99:
 09FF                   .dbline 549
 09FF           ; //            else
 09FF           ; //            {
 09FF           ; //                    COMP_SERIAL_CmdReset();
 09FF           ; //                    // Echo back what was sent in.
 09FF           ; //                    COMP_SERIAL_PutString(param);
 09FF           ; //                    COMP_SERIAL_PutChar('\n');
 09FF           ; //            }
 09FF           ;       }
 09FF           L96:
 09FF                   .dbline 551
 09FF           ;       
 09FF           ;       if(STATE != PC_MODE)
 09FF 62D000            mov REG[0xd0],>_STATE
 0A02 3C0000            cmp [_STATE],0
 0A05 B006              jnz X51
 0A07 3C0102            cmp [_STATE+1],2
 0A0A A00D              jz L172
 0A0C           X51:
 0A0C                   .dbline 552
 0A0C           ;       {
 0A0C                   .dbline 553
 0A0C           ;               configToggle(PC_MODE);
 0A0C 5000              mov A,0
 0A0E 08                push A
 0A0F 5002              mov A,2
 0A11 08                push A
 0A12 916D              xcall _configToggle
 0A14 38FE              add SP,-2
 0A16                   .dbline 554
 0A16           ;       }
 0A16 800A              xjmp L173
 0A18           L172:
 0A18                   .dbline 556
 0A18           ;       else
 0A18           ;       {
 0A18                   .dbline 557
 0A18           ;               TIMEOUT = 0;
 0A18 62D000            mov REG[0xd0],>_TIMEOUT
 0A1B 550100            mov [_TIMEOUT+1],0
 0A1E 550000            mov [_TIMEOUT],0
 0A21                   .dbline 558
 0A21           ;       }
 0A21           L173:
 0A21                   .dbline 561
 0A21           ;       
 0A21           ;       // Get closer to failing out.
 0A21           ;       MODULE_FAIL++;
 0A21 62D000            mov REG[0xd0],>_MODULE_FAIL
 0A24 7601              inc [_MODULE_FAIL+1]
 0A26 0E0000            adc [_MODULE_FAIL],0
 0A29                   .dbline -2
 0A29           L95:
 0A29 38F8              add SP,-8
 0A2B 20                pop X
 0A2C                   .dbline 0 ; func end
 0A2C 7F                ret
 0A2D                   .dbsym l tempByte 7 c
 0A2D                   .dbsym l angle 5 A[2:2]c
 0A2D                   .dbsym l ID 4 c
 0A2D                   .dbsym l total 2 I
 0A2D                   .dbsym l param 0 pc
 0A2D                   .dbend
 0A2D                   .dbfunc e servoInstruction _servoInstruction fV
 0A2D           ;          total -> X+1
 0A2D           ;       checksum -> X+0
 0A2D           ;          value -> X-8
 0A2D           ;        address -> X-7
 0A2D           ;    instruction -> X-6
 0A2D           ;         length -> X-5
 0A2D           ;             id -> X-4
 0A2D           _servoInstruction::
 0A2D                   .dbline -1
 0A2D 10                push X
 0A2E 4F                mov X,SP
 0A2F 3803              add SP,3
 0A31                   .dbline 567
 0A31           ; }
 0A31           ; 
 0A31           ; // This function receives a destination, command length, instruction type, address, and value.
 0A31           ; // With these parameters, the function sends a packet to the communication bus.
 0A31           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0A31           ; {
 0A31                   .dbline 571
 0A31           ;       char checksum;
 0A31           ;       int total;
 0A31           ;       
 0A31           ;       total = id + length + instruction + address + value;
 0A31 62D000            mov REG[0xd0],>__r0
 0A34 52FB              mov A,[X-5]
 0A36 5300              mov [__r1],A
 0A38 550000            mov [__r0],0
 0A3B 52FC              mov A,[X-4]
 0A3D 0200              add A,[__r1]
 0A3F 5300              mov [__r1],A
 0A41 5000              mov A,0
 0A43 0A00              adc A,[__r0]
 0A45 5300              mov [__r0],A
 0A47 52FA              mov A,[X-6]
 0A49 0400              add [__r1],A
 0A4B 0E0000            adc [__r0],0
 0A4E 52F9              mov A,[X-7]
 0A50 0400              add [__r1],A
 0A52 0E0000            adc [__r0],0
 0A55 52F8              mov A,[X-8]
 0A57 5300              mov [__r3],A
 0A59 550000            mov [__r2],0
 0A5C 5100              mov A,[__r1]
 0A5E 0200              add A,[__r3]
 0A60 5402              mov [X+2],A
 0A62 5100              mov A,[__r0]
 0A64 0A00              adc A,[__r2]
 0A66 5401              mov [X+1],A
 0A68                   .dbline 574
 0A68           ;       
 0A68           ;       // Calculate the checksum value for our servo communication.
 0A68           ;       checksum = 255-(total%256);
 0A68 5001              mov A,1
 0A6A 08                push A
 0A6B 5000              mov A,0
 0A6D 08                push A
 0A6E 5201              mov A,[X+1]
 0A70 08                push A
 0A71 5202              mov A,[X+2]
 0A73 08                push A
 0A74 7C0000            xcall __divmod_16X16_16
 0A77 38FE              add SP,-2
 0A79 18                pop A
 0A7A 5300              mov [__r1],A
 0A7C 18                pop A
 0A7D 50FF              mov A,-1
 0A7F 1200              sub A,[__r1]
 0A81 5400              mov [X+0],A
 0A83                   .dbline 577
 0A83           ;       
 0A83           ;       // Talk to the servo.
 0A83           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0A83 10                push X
 0A84 50FF              mov A,-1
 0A86 7C0000            xcall _TX_REPEATER_PutChar
 0A89 20                pop X
 0A8A                   .dbline 578
 0A8A           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0A8A 10                push X
 0A8B 50FF              mov A,-1
 0A8D 7C0000            xcall _TX_REPEATER_PutChar
 0A90 20                pop X
 0A91                   .dbline 579
 0A91           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0A91 10                push X
 0A92 52FC              mov A,[X-4]
 0A94 7C0000            xcall _TX_REPEATER_PutChar
 0A97 20                pop X
 0A98                   .dbline 580
 0A98           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0A98 10                push X
 0A99 52FB              mov A,[X-5]
 0A9B 7C0000            xcall _TX_REPEATER_PutChar
 0A9E 20                pop X
 0A9F                   .dbline 581
 0A9F           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0A9F 10                push X
 0AA0 52FA              mov A,[X-6]
 0AA2 7C0000            xcall _TX_REPEATER_PutChar
 0AA5 20                pop X
 0AA6                   .dbline 582
 0AA6           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0AA6 10                push X
 0AA7 52F9              mov A,[X-7]
 0AA9 7C0000            xcall _TX_REPEATER_PutChar
 0AAC 20                pop X
 0AAD                   .dbline 583
 0AAD           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0AAD 10                push X
 0AAE 52F8              mov A,[X-8]
 0AB0 7C0000            xcall _TX_REPEATER_PutChar
 0AB3 20                pop X
 0AB4                   .dbline 584
 0AB4           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0AB4 10                push X
 0AB5 5200              mov A,[X+0]
 0AB7 7C0000            xcall _TX_REPEATER_PutChar
 0ABA 20                pop X
 0ABB           L175:
 0ABB                   .dbline 587
 0ABB           ;       
 0ABB           ;       // Wait for the transmission to finish.
 0ABB           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0ABB           L176:
 0ABB                   .dbline 587
 0ABB 10                push X
 0ABC 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0ABF 62D000            mov REG[0xd0],>__r0
 0AC2 20                pop X
 0AC3 5300              mov [__r0],A
 0AC5 470020            tst [__r0],32
 0AC8 AFF2              jz L175
 0ACA                   .dbline 590
 0ACA           ;       
 0ACA           ;       // Make completely sure we're done.
 0ACA           ;       xmitWait();
 0ACA 93A4              xcall _xmitWait
 0ACC                   .dbline -2
 0ACC           L174:
 0ACC 38FD              add SP,-3
 0ACE 20                pop X
 0ACF                   .dbline 0 ; func end
 0ACF 7F                ret
 0AD0                   .dbsym l total 1 I
 0AD0                   .dbsym l checksum 0 c
 0AD0                   .dbsym l value -8 c
 0AD0                   .dbsym l address -7 c
 0AD0                   .dbsym l instruction -6 c
 0AD0                   .dbsym l length -5 c
 0AD0                   .dbsym l id -4 c
 0AD0                   .dbend
 0AD0                   .dbfunc e longServoInstruction _longServoInstruction fV
 0AD0           ;          total -> X+1
 0AD0           ;       checksum -> X+0
 0AD0           ;         value2 -> X-9
 0AD0           ;         value1 -> X-8
 0AD0           ;        address -> X-7
 0AD0           ;    instruction -> X-6
 0AD0           ;         length -> X-5
 0AD0           ;             id -> X-4
 0AD0           _longServoInstruction::
 0AD0                   .dbline -1
 0AD0 10                push X
 0AD1 4F                mov X,SP
 0AD2 3803              add SP,3
 0AD4                   .dbline 595
 0AD4           ; }
 0AD4           ; 
 0AD4           ; // This function receives a destination, command length, instruction type, address, and two values.
 0AD4           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0AD4           ; {
 0AD4                   .dbline 599
 0AD4           ;       char checksum;
 0AD4           ;       int total;
 0AD4           ;       
 0AD4           ;       total = id + length + instruction + address + value1 + value2;
 0AD4 62D000            mov REG[0xd0],>__r0
 0AD7 52FB              mov A,[X-5]
 0AD9 5300              mov [__r1],A
 0ADB 550000            mov [__r0],0
 0ADE 52FC              mov A,[X-4]
 0AE0 0200              add A,[__r1]
 0AE2 5300              mov [__r1],A
 0AE4 5000              mov A,0
 0AE6 0A00              adc A,[__r0]
 0AE8 5300              mov [__r0],A
 0AEA 52FA              mov A,[X-6]
 0AEC 0400              add [__r1],A
 0AEE 0E0000            adc [__r0],0
 0AF1 52F9              mov A,[X-7]
 0AF3 0400              add [__r1],A
 0AF5 0E0000            adc [__r0],0
 0AF8 52F8              mov A,[X-8]
 0AFA 0400              add [__r1],A
 0AFC 0E0000            adc [__r0],0
 0AFF 52F7              mov A,[X-9]
 0B01 5300              mov [__r3],A
 0B03 550000            mov [__r2],0
 0B06 5100              mov A,[__r1]
 0B08 0200              add A,[__r3]
 0B0A 5402              mov [X+2],A
 0B0C 5100              mov A,[__r0]
 0B0E 0A00              adc A,[__r2]
 0B10 5401              mov [X+1],A
 0B12                   .dbline 602
 0B12           ;       
 0B12           ;       // Calculate the checksum value for our servo communication.
 0B12           ;       checksum = 255-(total%256);
 0B12 5001              mov A,1
 0B14 08                push A
 0B15 5000              mov A,0
 0B17 08                push A
 0B18 5201              mov A,[X+1]
 0B1A 08                push A
 0B1B 5202              mov A,[X+2]
 0B1D 08                push A
 0B1E 7C0000            xcall __divmod_16X16_16
 0B21 38FE              add SP,-2
 0B23 18                pop A
 0B24 5300              mov [__r1],A
 0B26 18                pop A
 0B27 50FF              mov A,-1
 0B29 1200              sub A,[__r1]
 0B2B 5400              mov [X+0],A
 0B2D                   .dbline 605
 0B2D           ;       
 0B2D           ;       // Talk to the servo.
 0B2D           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0B2D 10                push X
 0B2E 50FF              mov A,-1
 0B30 7C0000            xcall _TX_REPEATER_PutChar
 0B33 20                pop X
 0B34                   .dbline 606
 0B34           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0B34 10                push X
 0B35 50FF              mov A,-1
 0B37 7C0000            xcall _TX_REPEATER_PutChar
 0B3A 20                pop X
 0B3B                   .dbline 607
 0B3B           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0B3B 10                push X
 0B3C 52FC              mov A,[X-4]
 0B3E 7C0000            xcall _TX_REPEATER_PutChar
 0B41 20                pop X
 0B42                   .dbline 608
 0B42           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0B42 10                push X
 0B43 52FB              mov A,[X-5]
 0B45 7C0000            xcall _TX_REPEATER_PutChar
 0B48 20                pop X
 0B49                   .dbline 609
 0B49           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0B49 10                push X
 0B4A 52FA              mov A,[X-6]
 0B4C 7C0000            xcall _TX_REPEATER_PutChar
 0B4F 20                pop X
 0B50                   .dbline 610
 0B50           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0B50 10                push X
 0B51 52F9              mov A,[X-7]
 0B53 7C0000            xcall _TX_REPEATER_PutChar
 0B56 20                pop X
 0B57                   .dbline 611
 0B57           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0B57 10                push X
 0B58 52F8              mov A,[X-8]
 0B5A 7C0000            xcall _TX_REPEATER_PutChar
 0B5D 20                pop X
 0B5E                   .dbline 612
 0B5E           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0B5E 10                push X
 0B5F 52F7              mov A,[X-9]
 0B61 7C0000            xcall _TX_REPEATER_PutChar
 0B64 20                pop X
 0B65                   .dbline 613
 0B65           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0B65 10                push X
 0B66 5200              mov A,[X+0]
 0B68 7C0000            xcall _TX_REPEATER_PutChar
 0B6B 20                pop X
 0B6C           L179:
 0B6C                   .dbline 616
 0B6C           ;       
 0B6C           ;       // Wait for the transmission to finish.
 0B6C           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0B6C           L180:
 0B6C                   .dbline 616
 0B6C 10                push X
 0B6D 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0B70 62D000            mov REG[0xd0],>__r0
 0B73 20                pop X
 0B74 5300              mov [__r0],A
 0B76 470020            tst [__r0],32
 0B79 AFF2              jz L179
 0B7B                   .dbline 619
 0B7B           ;       
 0B7B           ;       // Make completely sure we're done.
 0B7B           ;       xmitWait();
 0B7B 92F3              xcall _xmitWait
 0B7D                   .dbline -2
 0B7D           L178:
 0B7D 38FD              add SP,-3
 0B7F 20                pop X
 0B80                   .dbline 0 ; func end
 0B80 7F                ret
 0B81                   .dbsym l total 1 I
 0B81                   .dbsym l checksum 0 c
 0B81                   .dbsym l value2 -9 c
 0B81                   .dbsym l value1 -8 c
 0B81                   .dbsym l address -7 c
 0B81                   .dbsym l instruction -6 c
 0B81                   .dbsym l length -5 c
 0B81                   .dbsym l id -4 c
 0B81                   .dbend
 0B81                   .dbfunc e configToggle _configToggle fV
 0B81           ;           mode -> X-5
 0B81           _configToggle::
 0B81                   .dbline -1
 0B81 10                push X
 0B82 4F                mov X,SP
 0B83                   .dbline 625
 0B83           ; }
 0B83           ; 
 0B83           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0B83           ; // half duplex UART serial communication line.
 0B83           ; void configToggle(int mode)
 0B83           ; {
 0B83                   .dbline 627
 0B83           ;       // Disconnect from the global bus and leave the pin high.
 0B83           ;       PRT0DR |= 0b11111111;
 0B83 4300FF            or REG[0],-1
 0B86                   .dbline 628
 0B86           ;       PRT0GS &= 0b01000000;
 0B86 410240            and REG[0x2],64
 0B89                   .dbline 632
 0B89           ; 
 0B89           ;       // Unload the configuration of the current state.
 0B89           ;       // If there is no state, blindly wipe all configurations.
 0B89           ;       if(STATE)
 0B89 62D000            mov REG[0xd0],>_STATE
 0B8C 3C0000            cmp [_STATE],0
 0B8F B006              jnz X52
 0B91 3C0100            cmp [_STATE+1],0
 0B94 A010              jz L183
 0B96           X52:
 0B96                   .dbline 633
 0B96           ;       {
 0B96                   .dbline 634
 0B96           ;               unloadConfig(STATE);
 0B96 62D000            mov REG[0xd0],>_STATE
 0B99 5100              mov A,[_STATE]
 0B9B 08                push A
 0B9C 5101              mov A,[_STATE+1]
 0B9E 08                push A
 0B9F 90C9              xcall _unloadConfig
 0BA1 38FE              add SP,-2
 0BA3                   .dbline 635
 0BA3           ;       }
 0BA3 8003              xjmp L184
 0BA5           L183:
 0BA5                   .dbline 637
 0BA5           ;       else
 0BA5           ;       {
 0BA5                   .dbline 638
 0BA5           ;               unloadAllConfigs();
 0BA5 90B9              xcall _unloadAllConfigs
 0BA7                   .dbline 639
 0BA7           ;       }
 0BA7           L184:
 0BA7                   .dbline 641
 0BA7           ;       
 0BA7           ;       if(mode == PC_MODE)
 0BA7 3DFB00            cmp [X-5],0
 0BAA B037              jnz L185
 0BAC 3DFC02            cmp [X-4],2
 0BAF B032              jnz L185
 0BB1           X53:
 0BB1                   .dbline 642
 0BB1           ;       {
 0BB1                   .dbline 643
 0BB1           ;               LoadConfig_pc_listener();
 0BB1 7C0000            xcall _LoadConfig_pc_listener
 0BB4                   .dbline 645
 0BB4           ; 
 0BB4           ;               COMP_SERIAL_CmdReset();                                                 // Initialize the buffer.
 0BB4 10                push X
 0BB5 7C0000            xcall _COMP_SERIAL_CmdReset
 0BB8 20                pop X
 0BB9                   .dbline 646
 0BB9           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0BB9 10                push X
 0BBA 5001              mov A,1
 0BBC 7C0000            xcall _COMP_SERIAL_IntCntl
 0BBF 20                pop X
 0BC0                   .dbline 647
 0BC0           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0BC0 10                push X
 0BC1 5000              mov A,0
 0BC3 7C0000            xcall _COMP_SERIAL_Start
 0BC6 20                pop X
 0BC7                   .dbline 649
 0BC7           ;               
 0BC7           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0BC7 10                push X
 0BC8 5000              mov A,0
 0BCA 7C0000            xcall _TX_REPEATER_Start
 0BCD 20                pop X
 0BCE                   .dbline 651
 0BCE           ;               
 0BCE           ;               TIMEOUT = 0;
 0BCE 62D000            mov REG[0xd0],>_TIMEOUT
 0BD1 550100            mov [_TIMEOUT+1],0
 0BD4 550000            mov [_TIMEOUT],0
 0BD7                   .dbline 652
 0BD7           ;               STATE = PC_MODE;
 0BD7 62D000            mov REG[0xd0],>_STATE
 0BDA 550102            mov [_STATE+1],2
 0BDD 550000            mov [_STATE],0
 0BE0                   .dbline 653
 0BE0           ;       }
 0BE0 807A              xjmp L186
 0BE2           L185:
 0BE2                   .dbline 654
 0BE2           ;       else if(mode == RX_MODE)
 0BE2 3DFB00            cmp [X-5],0
 0BE5 B02C              jnz L187
 0BE7 3DFC01            cmp [X-4],1
 0BEA B027              jnz L187
 0BEC           X54:
 0BEC                   .dbline 655
 0BEC           ;       {
 0BEC                   .dbline 656
 0BEC           ;               LoadConfig_receiver_config();
 0BEC 7C0000            xcall _LoadConfig_receiver_config
 0BEF                   .dbline 659
 0BEF           ;               
 0BEF           ;               // Start the receiver.
 0BEF           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0BEF 10                push X
 0BF0 5000              mov A,0
 0BF2 7C0000            xcall _RECEIVE_Start
 0BF5 20                pop X
 0BF6                   .dbline 662
 0BF6           ;               
 0BF6           ;               // Start response timeout timer and enable its interrupt routine.
 0BF6           ;               TIMEOUT = 0;
 0BF6 62D000            mov REG[0xd0],>_TIMEOUT
 0BF9 550100            mov [_TIMEOUT+1],0
 0BFC 550000            mov [_TIMEOUT],0
 0BFF                   .dbline 663
 0BFF           ;               RX_TIMEOUT_EnableInt();
 0BFF 10                push X
 0C00 7C0000            xcall _RX_TIMEOUT_EnableInt
 0C03                   .dbline 664
 0C03           ;               RX_TIMEOUT_Start();
 0C03 7C0000            xcall _RX_TIMEOUT_Start
 0C06 20                pop X
 0C07                   .dbline 666
 0C07           ;               
 0C07           ;               STATE = RX_MODE;
 0C07 62D000            mov REG[0xd0],>_STATE
 0C0A 550101            mov [_STATE+1],1
 0C0D 550000            mov [_STATE],0
 0C10                   .dbline 667
 0C10           ;       }
 0C10 804A              xjmp L188
 0C12           L187:
 0C12                   .dbline 668
 0C12           ;       else if(mode == TX_MODE)
 0C12 3DFB00            cmp [X-5],0
 0C15 B045              jnz L189
 0C17 3DFC00            cmp [X-4],0
 0C1A B040              jnz L189
 0C1C           X55:
 0C1C                   .dbline 669
 0C1C           ;       {
 0C1C                   .dbline 670
 0C1C           ;               LoadConfig_transmitter_config();
 0C1C 7C0000            xcall _LoadConfig_transmitter_config
 0C1F                   .dbline 672
 0C1F           ;               // Start the transmitter.
 0C1F           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0C1F 10                push X
 0C20 5000              mov A,0
 0C22 7C0000            xcall _TRANSMIT_Start
 0C25 20                pop X
 0C26                   .dbline 674
 0C26           ;               
 0C26           ;               TIMEOUT = 0;
 0C26 62D000            mov REG[0xd0],>_TIMEOUT
 0C29 550100            mov [_TIMEOUT+1],0
 0C2C 550000            mov [_TIMEOUT],0
 0C2F                   .dbline 675
 0C2F           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0C2F 10                push X
 0C30 7C0000            xcall _TX_TIMEOUT_EnableInt
 0C33                   .dbline 676
 0C33           ;               TX_TIMEOUT_Start();             // Start the timer.
 0C33 7C0000            xcall _TX_TIMEOUT_Start
 0C36 20                pop X
 0C37           L191:
 0C37                   .dbline 679
 0C37           ;               
 0C37           ;               while(!TIMEOUT)
 0C37           ;               {
 0C37                   .dbline 682
 0C37           ;                       // Do nothing while we wait for one timeout period.
 0C37           ;                       // This is to allow everyone to get in the right configuration.
 0C37           ;               }
 0C37           L192:
 0C37                   .dbline 678
 0C37 62D000            mov REG[0xd0],>_TIMEOUT
 0C3A 3C0000            cmp [_TIMEOUT],0
 0C3D B006              jnz X56
 0C3F 3C0100            cmp [_TIMEOUT+1],0
 0C42 AFF4              jz L191
 0C44           X56:
 0C44                   .dbline 684
 0C44           ;               
 0C44           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0C44 10                push X
 0C45 7C0000            xcall _TX_TIMEOUT_Stop
 0C48 20                pop X
 0C49                   .dbline 685
 0C49           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0C49 62D000            mov REG[0xd0],>_TIMEOUT
 0C4C 550100            mov [_TIMEOUT+1],0
 0C4F 550000            mov [_TIMEOUT],0
 0C52                   .dbline 687
 0C52           ;               
 0C52           ;               STATE = TX_MODE;
 0C52 62D000            mov REG[0xd0],>_STATE
 0C55 550100            mov [_STATE+1],0
 0C58 550000            mov [_STATE],0
 0C5B                   .dbline 688
 0C5B           ;       }
 0C5B           L189:
 0C5B           L188:
 0C5B           L186:
 0C5B                   .dbline 691
 0C5B           ;       
 0C5B           ;       // Reconnect to the global bus.
 0C5B           ;       PRT0GS |= 0b10111111;
 0C5B 4302BF            or REG[0x2],-65
 0C5E                   .dbline -2
 0C5E           L182:
 0C5E 20                pop X
 0C5F                   .dbline 0 ; func end
 0C5F 7F                ret
 0C60                   .dbsym l mode -5 I
 0C60                   .dbend
 0C60                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0C60           _unloadAllConfigs::
 0C60                   .dbline -1
 0C60                   .dbline 697
 0C60           ; }
 0C60           ; 
 0C60           ; // This function blindly unloads all user configurations. This will be called once,
 0C60           ; // when the system initially has no known state.
 0C60           ; void unloadAllConfigs(void)
 0C60           ; {
 0C60                   .dbline 698
 0C60           ;       UnloadConfig_pc_listener();
 0C60 7C0000            xcall _UnloadConfig_pc_listener
 0C63                   .dbline 699
 0C63           ;       UnloadConfig_receiver_config();
 0C63 7C0000            xcall _UnloadConfig_receiver_config
 0C66                   .dbline 700
 0C66           ;       UnloadConfig_transmitter_config();
 0C66 7C0000            xcall _UnloadConfig_transmitter_config
 0C69                   .dbline -2
 0C69           L194:
 0C69                   .dbline 0 ; func end
 0C69 7F                ret
 0C6A                   .dbend
 0C6A                   .dbfunc e unloadConfig _unloadConfig fV
 0C6A           ;     config_num -> X-5
 0C6A           _unloadConfig::
 0C6A                   .dbline -1
 0C6A 10                push X
 0C6B 4F                mov X,SP
 0C6C                   .dbline 706
 0C6C           ; }
 0C6C           ; 
 0C6C           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C6C           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C6C           ; void unloadConfig(int config_num)
 0C6C           ; {
 0C6C                   .dbline 707
 0C6C           ;       if(config_num == PC_MODE)
 0C6C 3DFB00            cmp [X-5],0
 0C6F B00B              jnz L196
 0C71 3DFC02            cmp [X-4],2
 0C74 B006              jnz L196
 0C76           X57:
 0C76                   .dbline 708
 0C76           ;       {
 0C76                   .dbline 709
 0C76           ;               UnloadConfig_pc_listener();
 0C76 7C0000            xcall _UnloadConfig_pc_listener
 0C79                   .dbline 710
 0C79           ;       }
 0C79 801D              xjmp L197
 0C7B           L196:
 0C7B                   .dbline 711
 0C7B           ;       else if(config_num == RX_MODE)
 0C7B 3DFB00            cmp [X-5],0
 0C7E B00B              jnz L198
 0C80 3DFC01            cmp [X-4],1
 0C83 B006              jnz L198
 0C85           X58:
 0C85                   .dbline 712
 0C85           ;       {
 0C85                   .dbline 713
 0C85           ;               UnloadConfig_receiver_config();
 0C85 7C0000            xcall _UnloadConfig_receiver_config
 0C88                   .dbline 714
 0C88           ;       }
 0C88 800E              xjmp L199
 0C8A           L198:
 0C8A                   .dbline 715
 0C8A           ;       else if(config_num == TX_MODE)
 0C8A 3DFB00            cmp [X-5],0
 0C8D B009              jnz L200
 0C8F 3DFC00            cmp [X-4],0
 0C92 B004              jnz L200
 0C94           X59:
 0C94                   .dbline 716
 0C94           ;       {
 0C94                   .dbline 717
 0C94           ;               UnloadConfig_transmitter_config();
 0C94 7C0000            xcall _UnloadConfig_transmitter_config
 0C97                   .dbline 718
 0C97           ;       }
 0C97           L200:
 0C97           L199:
 0C97           L197:
 0C97                   .dbline -2
 0C97           L195:
 0C97 20                pop X
 0C98                   .dbline 0 ; func end
 0C98 7F                ret
 0C99                   .dbsym l config_num -5 I
 0C99                   .dbend
 0C99                   .dbfunc e busListen _busListen fV
 0C99           _busListen::
 0C99                   .dbline -1
 0C99                   .dbline 722
 0C99           ; }
 0C99           ; 
 0C99           ; void busListen(void)
 0C99           ; {
 0C99                   .dbline 723
 0C99           ;       configToggle(RX_MODE);
 0C99 5000              mov A,0
 0C9B 08                push A
 0C9C 5001              mov A,1
 0C9E 08                push A
 0C9F 9EE0              xcall _configToggle
 0CA1 38FE              add SP,-2
 0CA3 8013              xjmp L204
 0CA5           L203:
 0CA5                   .dbline 727
 0CA5           ; 
 0CA5           ;       // Wait for the first byte.
 0CA5           ;       while(TIMEOUT < BOOT_TIMEOUT)
 0CA5           ;       {       
 0CA5                   .dbline 728
 0CA5           ;               if(RECEIVE_cGetChar())
 0CA5 10                push X
 0CA6 7C0000            xcall _RECEIVE_cGetChar
 0CA9 20                pop X
 0CAA 3900              cmp A,0
 0CAC A00A              jz L206
 0CAE                   .dbline 729
 0CAE           ;               {
 0CAE                   .dbline 730
 0CAE           ;                       TIMEOUT = BOOT_TIMEOUT;
 0CAE 62D000            mov REG[0xd0],>_TIMEOUT
 0CB1 55012C            mov [_TIMEOUT+1],44
 0CB4 550001            mov [_TIMEOUT],1
 0CB7                   .dbline 731
 0CB7           ;               }
 0CB7           L206:
 0CB7                   .dbline 732
 0CB7           ;       }
 0CB7           L204:
 0CB7                   .dbline 726
 0CB7 62D000            mov REG[0xd0],>_TIMEOUT
 0CBA 5101              mov A,[_TIMEOUT+1]
 0CBC 112C              sub A,44
 0CBE 5100              mov A,[_TIMEOUT]
 0CC0 3180              xor A,-128
 0CC2 1981              sbb A,(1 ^ 0x80)
 0CC4 CFE0              jc L203
 0CC6           X60:
 0CC6                   .dbline 735
 0CC6           ;       
 0CC6           ;       // Clear the timeout flag.
 0CC6           ;       TIMEOUT = 0;
 0CC6 62D000            mov REG[0xd0],>_TIMEOUT
 0CC9 550100            mov [_TIMEOUT+1],0
 0CCC 550000            mov [_TIMEOUT],0
 0CCF 8013              xjmp L209
 0CD1           L208:
 0CD1                   .dbline 739
 0CD1           ;       
 0CD1           ;       // Wait for BUS_CLEAR_TIME to pass without hearing a byte.
 0CD1           ;       while(TIMEOUT < BUS_CLEAR_TIME)
 0CD1           ;       {       
 0CD1                   .dbline 740
 0CD1           ;               if(RECEIVE_cReadChar())
 0CD1 10                push X
 0CD2 7C0000            xcall _RECEIVE_cReadChar
 0CD5 20                pop X
 0CD6 3900              cmp A,0
 0CD8 A00A              jz L211
 0CDA                   .dbline 741
 0CDA           ;               {
 0CDA                   .dbline 742
 0CDA           ;                       TIMEOUT = 0;    
 0CDA 62D000            mov REG[0xd0],>_TIMEOUT
 0CDD 550100            mov [_TIMEOUT+1],0
 0CE0 550000            mov [_TIMEOUT],0
 0CE3                   .dbline 743
 0CE3           ;               }
 0CE3           L211:
 0CE3                   .dbline 744
 0CE3           ;       }
 0CE3           L209:
 0CE3                   .dbline 738
 0CE3 62D000            mov REG[0xd0],>_TIMEOUT
 0CE6 5101              mov A,[_TIMEOUT+1]
 0CE8 1164              sub A,100
 0CEA 5100              mov A,[_TIMEOUT]
 0CEC 3180              xor A,-128
 0CEE 1980              sbb A,(0 ^ 0x80)
 0CF0 CFE0              jc L208
 0CF2           X61:
 0CF2                   .dbline -2
 0CF2           L202:
 0CF2                   .dbline 0 ; func end
 0CF2 7F                ret
 0CF3                   .dbend
 0CF3                   .dbfunc e initializeSlaves _initializeSlaves fV
 0CF3           ;   num_timeouts -> X+4
 0CF3           ;     ping_tries -> X+2
 0CF3           ;              i -> X+0
 0CF3           _initializeSlaves::
 0CF3                   .dbline -1
 0CF3 10                push X
 0CF4 4F                mov X,SP
 0CF5 3806              add SP,6
 0CF7                   .dbline 748
 0CF7           ; }
 0CF7           ; 
 0CF7           ; void initializeSlaves(void)
 0CF7           ; {
 0CF7                   .dbline 749
 0CF7           ;       int num_timeouts = 0;   // The number of consecutive timeouts.
 0CF7 560500            mov [X+5],0
 0CFA 560400            mov [X+4],0
 0CFD                   .dbline 750
 0CFD           ;       int ping_tries = 5;             // The number of times to try a ping on an unregistered module.
 0CFD 560305            mov [X+3],5
 0D00 560200            mov [X+2],0
 0D03                   .dbline 751
 0D03           ;       int i = 0;                              // An iterator for looping.
 0D03 560100            mov [X+1],0
 0D06 560000            mov [X+0],0
 0D09                   .dbline 754
 0D09           ;       
 0D09           ;       // Set num modules to zero.
 0D09           ;       NUM_MODULES = 0;
 0D09 62D000            mov REG[0xd0],>_NUM_MODULES
 0D0C 550100            mov [_NUM_MODULES+1],0
 0D0F 550000            mov [_NUM_MODULES],0
 0D12                   .dbline 756
 0D12           ;       
 0D12           ;       sayHello();
 0D12 7C0336            xcall _sayHello
 0D15 80D7              xjmp L215
 0D17           L214:
 0D17                   .dbline 761
 0D17           ;       
 0D17           ;       // This loop continuously probes and listens at intervals
 0D17           ;       // set by the RX_TIMEOUT_DURATION variable.
 0D17           ;       while(num_timeouts < MAX_TIMEOUTS)
 0D17           ;       {       
 0D17                   .dbline 762
 0D17           ;               if(validTransmission())
 0D17 7C038D            xcall _validTransmission
 0D1A 62D000            mov REG[0xd0],>__r0
 0D1D 3C0000            cmp [__r0],0
 0D20 B006              jnz X62
 0D22 3C0000            cmp [__r1],0
 0D25 A0A1              jz L217
 0D27           X62:
 0D27                   .dbline 763
 0D27           ;               {
 0D27                   .dbline 764
 0D27           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0D27 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0D2A 3C00C8            cmp [_COMMAND_TYPE],-56
 0D2D B0BF              jnz L218
 0D2F                   .dbline 765
 0D2F           ;                       {
 0D2F                   .dbline 767
 0D2F           ;                               // If this is for me, assign them an ID.
 0D2F           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0D2F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0D32 3C0000            cmp [_COMMAND_DESTINATION],0
 0D35 B0B7              jnz L218
 0D37                   .dbline 768
 0D37           ;                               {
 0D37                   .dbline 769
 0D37           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0D37 62D000            mov REG[0xd0],>_NUM_MODULES
 0D3A 7601              inc [_NUM_MODULES+1]
 0D3C 0E0000            adc [_NUM_MODULES],0
 0D3F                   .dbline 770
 0D3F           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0D3F 560500            mov [X+5],0
 0D42 560400            mov [X+4],0
 0D45                   .dbline 772
 0D45           ;               
 0D45           ;                                       if(!assignID(NUM_MODULES))
 0D45 5100              mov A,[_NUM_MODULES]
 0D47 08                push A
 0D48 5101              mov A,[_NUM_MODULES+1]
 0D4A 08                push A
 0D4B 7C0147            xcall _assignID
 0D4E 38FE              add SP,-2
 0D50 62D000            mov REG[0xd0],>__r0
 0D53 3C0000            cmp [__r0],0
 0D56 B096              jnz L218
 0D58 3C0000            cmp [__r1],0
 0D5B B091              jnz L218
 0D5D           X63:
 0D5D                   .dbline 773
 0D5D           ;                                       {
 0D5D                   .dbline 777
 0D5D           ;                                               // If the module did not respond that the ID was assigned,
 0D5D           ;                                               // make an effort to ping it in case that transmission was lost
 0D5D           ;                                               // before ultimately deciding that the module didn't configure.
 0D5D           ;                                               for(i = 0; i < ping_tries; i++)
 0D5D 560100            mov [X+1],0
 0D60 560000            mov [X+0],0
 0D63 8038              xjmp L228
 0D65           L225:
 0D65                   .dbline 778
 0D65           ;                                               {       
 0D65                   .dbline 779
 0D65           ;                                                       if(pingModule(NUM_MODULES))
 0D65 62D000            mov REG[0xd0],>_NUM_MODULES
 0D68 5100              mov A,[_NUM_MODULES]
 0D6A 08                push A
 0D6B 5101              mov A,[_NUM_MODULES+1]
 0D6D 08                push A
 0D6E 7C0058            xcall _pingModule
 0D71 38FE              add SP,-2
 0D73 62D000            mov REG[0xd0],>__r0
 0D76 3C0000            cmp [__r0],0
 0D79 B006              jnz X64
 0D7B 3C0000            cmp [__r1],0
 0D7E A018              jz L229
 0D80           X64:
 0D80                   .dbline 780
 0D80           ;                                                       {
 0D80                   .dbline 781
 0D80           ;                                                               i = ping_tries*2;
 0D80 62D000            mov REG[0xd0],>__r0
 0D83 5203              mov A,[X+3]
 0D85 5300              mov [__r1],A
 0D87 5202              mov A,[X+2]
 0D89 5300              mov [__r0],A
 0D8B 6500              asl [__r1]
 0D8D 6B00              rlc [__r0]
 0D8F 5100              mov A,[__r1]
 0D91 5401              mov [X+1],A
 0D93 5100              mov A,[__r0]
 0D95 5400              mov [X+0],A
 0D97                   .dbline 782
 0D97           ;                                                       }
 0D97           L229:
 0D97                   .dbline 783
 0D97           ;                                               }
 0D97           L226:
 0D97                   .dbline 777
 0D97 7701              inc [X+1]
 0D99 0F0000            adc [X+0],0
 0D9C           L228:
 0D9C                   .dbline 777
 0D9C 5201              mov A,[X+1]
 0D9E 1303              sub A,[X+3]
 0DA0 5202              mov A,[X+2]
 0DA2 3180              xor A,-128
 0DA4 62D000            mov REG[0xd0],>__r0
 0DA7 5300              mov [__rX],A
 0DA9 5200              mov A,[X+0]
 0DAB 3180              xor A,-128
 0DAD 1A00              sbb A,[__rX]
 0DAF CFB5              jc L225
 0DB1           X65:
 0DB1                   .dbline 786
 0DB1           ;                                               
 0DB1           ;                                               // If we landed right at ping_tries, we failed.
 0DB1           ;                                               if(i == ping_tries)
 0DB1 5200              mov A,[X+0]
 0DB3 3B02              cmp A,[X+2]
 0DB5 B037              jnz L218
 0DB7 5201              mov A,[X+1]
 0DB9 3B03              cmp A,[X+3]
 0DBB B031              jnz L218
 0DBD           X66:
 0DBD                   .dbline 787
 0DBD           ;                                               {
 0DBD                   .dbline 788
 0DBD           ;                                                       NUM_MODULES--;
 0DBD 62D000            mov REG[0xd0],>_NUM_MODULES
 0DC0 7A01              dec [_NUM_MODULES+1]
 0DC2 1E0000            sbb [_NUM_MODULES],0
 0DC5                   .dbline 789
 0DC5           ;                                               }
 0DC5                   .dbline 790
 0DC5           ;                                       }
 0DC5                   .dbline 791
 0DC5           ;                               }
 0DC5                   .dbline 792
 0DC5           ;                       }
 0DC5                   .dbline 793
 0DC5           ;               }
 0DC5 8027              xjmp L218
 0DC7           L217:
 0DC7                   .dbline 794
 0DC7           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0DC7 62D000            mov REG[0xd0],>_TIMEOUT
 0DCA 5101              mov A,[_TIMEOUT+1]
 0DCC 1105              sub A,5
 0DCE 5100              mov A,[_TIMEOUT]
 0DD0 3180              xor A,-128
 0DD2 1980              sbb A,(0 ^ 0x80)
 0DD4 C018              jc L233
 0DD6           X67:
 0DD6                   .dbline 795
 0DD6           ;               {       
 0DD6                   .dbline 796
 0DD6           ;                       num_timeouts++;
 0DD6 7705              inc [X+5]
 0DD8 0F0400            adc [X+4],0
 0DDB                   .dbline 799
 0DDB           ;                       
 0DDB           ;                       // If we are not maxed out on modules, look for more.
 0DDB           ;                       if(NUM_MODULES < MAX_MODULES)
 0DDB 62D000            mov REG[0xd0],>_NUM_MODULES
 0DDE 5101              mov A,[_NUM_MODULES+1]
 0DE0 11FA              sub A,-6
 0DE2 5100              mov A,[_NUM_MODULES]
 0DE4 3180              xor A,-128
 0DE6 1980              sbb A,(0 ^ 0x80)
 0DE8 D004              jnc L235
 0DEA           X68:
 0DEA                   .dbline 800
 0DEA           ;                       {
 0DEA                   .dbline 801
 0DEA           ;                               sayHello();
 0DEA 7C0336            xcall _sayHello
 0DED                   .dbline 802
 0DED           ;                       }
 0DED           L235:
 0DED                   .dbline 803
 0DED           ;               }
 0DED           L233:
 0DED           L218:
 0DED                   .dbline 804
 0DED           ;       }
 0DED           L215:
 0DED                   .dbline 760
 0DED 5205              mov A,[X+5]
 0DEF 1132              sub A,50
 0DF1 5204              mov A,[X+4]
 0DF3 3180              xor A,-128
 0DF5 1980              sbb A,(0 ^ 0x80)
 0DF7 CF1F              jc L214
 0DF9           X69:
 0DF9                   .dbline 807
 0DF9           ;       
 0DF9           ;       // If we didn't find any new modules, check to see if some already exist.
 0DF9           ;       if(!NUM_MODULES)
 0DF9 62D000            mov REG[0xd0],>_NUM_MODULES
 0DFC 3C0000            cmp [_NUM_MODULES],0
 0DFF B062              jnz L237
 0E01 3C0100            cmp [_NUM_MODULES+1],0
 0E04 B05D              jnz L237
 0E06           X70:
 0E06                   .dbline 808
 0E06           ;       {
 0E06                   .dbline 810
 0E06           ;               // Try to ping the next module up from our current number ping_tries times.
 0E06           ;               for(i = 0; i < ping_tries; i++)
 0E06 560100            mov [X+1],0
 0E09 560000            mov [X+0],0
 0E0C 8040              xjmp L242
 0E0E           L239:
 0E0E                   .dbline 811
 0E0E           ;               {       
 0E0E                   .dbline 812
 0E0E           ;                       if(pingModule(NUM_MODULES+1))
 0E0E 62D000            mov REG[0xd0],>_NUM_MODULES
 0E11 5101              mov A,[_NUM_MODULES+1]
 0E13 0101              add A,1
 0E15 62D000            mov REG[0xd0],>__r0
 0E18 5300              mov [__r1],A
 0E1A 62D000            mov REG[0xd0],>_NUM_MODULES
 0E1D 5100              mov A,[_NUM_MODULES]
 0E1F 0900              adc A,0
 0E21 62D000            mov REG[0xd0],>__r0
 0E24 08                push A
 0E25 5100              mov A,[__r1]
 0E27 08                push A
 0E28 7C0058            xcall _pingModule
 0E2B 38FE              add SP,-2
 0E2D 62D000            mov REG[0xd0],>__r0
 0E30 3C0000            cmp [__r0],0
 0E33 B006              jnz X71
 0E35 3C0000            cmp [__r1],0
 0E38 A00F              jz L243
 0E3A           X71:
 0E3A                   .dbline 813
 0E3A           ;                       {
 0E3A                   .dbline 814
 0E3A           ;                               NUM_MODULES++;
 0E3A 62D000            mov REG[0xd0],>_NUM_MODULES
 0E3D 7601              inc [_NUM_MODULES+1]
 0E3F 0E0000            adc [_NUM_MODULES],0
 0E42                   .dbline 815
 0E42           ;                               i = 0;
 0E42 560100            mov [X+1],0
 0E45 560000            mov [X+0],0
 0E48                   .dbline 816
 0E48           ;                       }
 0E48           L243:
 0E48                   .dbline 817
 0E48           ;               }
 0E48           L240:
 0E48                   .dbline 810
 0E48 7701              inc [X+1]
 0E4A 0F0000            adc [X+0],0
 0E4D           L242:
 0E4D                   .dbline 810
 0E4D 5201              mov A,[X+1]
 0E4F 1303              sub A,[X+3]
 0E51 5202              mov A,[X+2]
 0E53 3180              xor A,-128
 0E55 62D000            mov REG[0xd0],>__r0
 0E58 5300              mov [__rX],A
 0E5A 5200              mov A,[X+0]
 0E5C 3180              xor A,-128
 0E5E 1A00              sbb A,[__rX]
 0E60 CFAD              jc L239
 0E62           X72:
 0E62                   .dbline 818
 0E62           ;       }
 0E62           L237:
 0E62                   .dbline 821
 0E62           ;       
 0E62           ;       // Switch back to PC mode.
 0E62           ;       configToggle(PC_MODE);
 0E62 5000              mov A,0
 0E64 08                push A
 0E65 5002              mov A,2
 0E67 08                push A
 0E68 9D17              xcall _configToggle
 0E6A 38FE              add SP,-2
 0E6C                   .dbline -2
 0E6C           L213:
 0E6C 38FA              add SP,-6
 0E6E 20                pop X
 0E6F                   .dbline 0 ; func end
 0E6F 7F                ret
 0E70                   .dbsym l num_timeouts 4 I
 0E70                   .dbsym l ping_tries 2 I
 0E70                   .dbsym l i 0 I
 0E70                   .dbend
 0E70                   .dbfunc e xmitWait _xmitWait fV
 0E70           ;              i -> X+0
 0E70           _xmitWait::
 0E70                   .dbline -1
 0E70 10                push X
 0E71 4F                mov X,SP
 0E72 3802              add SP,2
 0E74                   .dbline 825
 0E74           ; }
 0E74           ; 
 0E74           ; void xmitWait(void)
 0E74           ; {
 0E74                   .dbline 828
 0E74           ;       int i;
 0E74           ;       
 0E74           ;       for(i = 0; i < 25; i++)
 0E74 560100            mov [X+1],0
 0E77 560000            mov [X+0],0
 0E7A           L246:
 0E7A                   .dbline 829
 0E7A           ;       {
 0E7A                   .dbline 831
 0E7A           ;               // Sit here and spin for about 50 microseconds.
 0E7A           ;       }
 0E7A           L247:
 0E7A                   .dbline 828
 0E7A 7701              inc [X+1]
 0E7C 0F0000            adc [X+0],0
 0E7F                   .dbline 828
 0E7F 5201              mov A,[X+1]
 0E81 1119              sub A,25
 0E83 5200              mov A,[X+0]
 0E85 3180              xor A,-128
 0E87 1980              sbb A,(0 ^ 0x80)
 0E89 CFF0              jc L246
 0E8B           X73:
 0E8B                   .dbline -2
 0E8B           L245:
 0E8B 38FE              add SP,-2
 0E8D 20                pop X
 0E8E                   .dbline 0 ; func end
 0E8E 7F                ret
 0E8F                   .dbsym l i 0 I
 0E8F                   .dbend
 0E8F                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0E8F           _TX_TIMEOUT_ISR::
 0E8F                   .dbline -1
 0E8F 71C0              or F,-64
 0E91 08                push A
 0E92 5DD0              mov A,REG[0xd0]
 0E94 08                push A
 0E95                   .dbline 835
 0E95           ; }
 0E95           ; 
 0E95           ; void TX_TIMEOUT_ISR(void)
 0E95           ; {     
 0E95                   .dbline 836
 0E95           ;       TIMEOUT++;
 0E95 62D000            mov REG[0xd0],>_TIMEOUT
 0E98 7601              inc [_TIMEOUT+1]
 0E9A 0E0000            adc [_TIMEOUT],0
 0E9D                   .dbline 838
 0E9D           ;       
 0E9D           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0E9D 62DAFD            mov REG[0xda],-3
 0EA0                   .dbline -2
 0EA0           L250:
 0EA0 18                pop A
 0EA1 60D0              mov REG[208],A
 0EA3 18                pop A
 0EA4                   .dbline 0 ; func end
 0EA4 7E                reti
 0EA5                   .dbend
 0EA5                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0EA5           _RX_TIMEOUT_ISR::
 0EA5                   .dbline -1
 0EA5 71C0              or F,-64
 0EA7 08                push A
 0EA8 5DD0              mov A,REG[0xd0]
 0EAA 08                push A
 0EAB                   .dbline 842
 0EAB           ; }
 0EAB           ; 
 0EAB           ; void RX_TIMEOUT_ISR(void)
 0EAB           ; {     
 0EAB                   .dbline 843
 0EAB           ;       TIMEOUT++;
 0EAB 62D000            mov REG[0xd0],>_TIMEOUT
 0EAE 7601              inc [_TIMEOUT+1]
 0EB0 0E0000            adc [_TIMEOUT],0
 0EB3                   .dbline 845
 0EB3           ;       
 0EB3           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0EB3 62DAFD            mov REG[0xda],-3
 0EB6                   .dbline -2
 0EB6           L251:
 0EB6 18                pop A
 0EB7 60D0              mov REG[208],A
 0EB9 18                pop A
 0EBA                   .dbline 0 ; func end
 0EBA 7E                reti
 0EBB                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _MODULE_FAIL::
 0000 0000              .byte 0,0
 0002                   .dbsym e MODULE_FAIL _MODULE_FAIL I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
