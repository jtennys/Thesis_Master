0000: 80 7F    JMP   0x0080
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0117) ; Generated by PSoC Designer 5.0.985.0
                                   (0118) ;
                                   (0119) ;@Id: boot.tpl#884 @
0004: 30       HALT                (0120) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0121) ;  FILENAME:   boot.asm
                                   (0122) ;  VERSION:    1.00
                                   (0123) ;  DATE:       05 March 2009
0008: 7E       RETI                (0124) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0125) ;  DESCRIPTION:
                                   (0126) ;  M8C Boot Code for CY8C28xxx microcontroller devices.
                                   (0127) ;
000C: 7E       RETI                (0128) ;  Copyright (C) Cypress Semiconductors 2009. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0129) ;
                                   (0130) ; NOTES:
                                   (0131) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0132) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0133) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0134) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0135) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0136) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0137) ;
                                   (0138) ;=============================================================================
                                   (0139) 
0018: 7E       RETI                (0140) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0141) include "m8c.inc"			;Part specific file
                                   (0142) include "m8ssc.inc"			;Part specific file
                                   (0143) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0144) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0145) ;--------------------------------------
                                   (0146) ; Export Declarations
                                   (0147) ;--------------------------------------
0020: 7E       RETI                (0148) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0149) export __Start
                                   (0150) IF	(TOOLCHAIN & HITECH)
0024: 7D 22 EF LJMP  Dispatch_INTERRUPT_9(0151) ELSE
0027: 7E       RETI                (0152) export __bss_start
                                   (0153) export __data_start
                                   (0154) export __idata_start
0028: 7D 22 73 LJMP  Dispatch_INTERRUPT_10(0155) export __func_lit_start
002B: 7E       RETI                (0156) export __text_start
                                   (0157) ENDIF
                                   (0158) export  _bGetPowerSetting
002C: 7D 22 92 LJMP  Dispatch_INTERRUPT_11(0159) export   bGetPowerSetting	
002F: 7E       RETI                (0160) 
                                   (0161) 
                                   (0162) ;--------------------------------------
                                   (0163) ; Optimization flags
0030: 7E       RETI                (0164) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0165) ;
                                   (0166) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0167) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0168) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0169) 
                                   (0170) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 22 B1 LJMP  Dispatch_INTERRUPT_14(0171) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0172) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0173) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0174) ;
003C: 7D 22 D0 LJMP  Dispatch_INTERRUPT_15(0175) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0176) ; The C compiler will customize the startup code - it's not required here
                                   (0177) 
                                   (0178) C_LANGUAGE_SUPPORT:              equ 0
                                   (0179) ELSE
0040: 7E       RETI                (0180) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0181) ENDIF
                                   (0182) 
                                   (0183) 
0044: 7E       RETI                (0184) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0185) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0186) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0187) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0188) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0189) ;
                                   (0190) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0191) ;                invoking main
004C: 7E       RETI                (0192) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
0050: 30       HALT  
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
0054: 30       HALT  
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
0058: 30       HALT  
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
005C: 30       HALT  
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0193) ;               the time code in main starts executing.
                                   (0194) ;
                                   (0195) WAIT_FOR_32K:                    equ 1
0060: 7E       RETI                (0196) 
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0197) 
                                   (0198) 
                                   (0199) ; For historical reasons, by default the boot code uses an lcall instruction
0064: 7E       RETI                (0200) ; to invoke the user's _main code. If _main executes a return instruction,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0201) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0202) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0203) ; bytes on the stack which are otherwise required for the return address. If
0068: 7E       RETI                (0204) ; this option is enabled, _main must not return. (Beginning with the 4.2
0069: 30       HALT  
006A: 30       HALT  
006B: 30       HALT  
                                   (0205) ; release, the C compiler automatically places an infinite loop at the end
                                   (0206) ; of main, rather than a return instruction.)
                                   (0207) ;
006C: 7E       RETI                (0208) ENABLE_LJMP_TO_MAIN:             equ 0
006D: 30       HALT  
006E: 30       HALT  
006F: 30       HALT  
                                   (0209) 
                                   (0210) 
                                   (0211) ;-----------------------------------------------------------------------------
0070: 7E       RETI                (0212) ; Interrupt Vector Table
0071: 30       HALT  
0072: 30       HALT  
0073: 30       HALT  
                                   (0213) ;-----------------------------------------------------------------------------
                                   (0214) ;
                                   (0215) ; Interrupt vector table entries are 4 bytes long.  Each one contains
0074: 7E       RETI                (0216) ; a jump instruction to an ISR (Interrupt Service Routine), although
0075: 30       HALT  
0076: 30       HALT  
0077: 30       HALT  
0078: 30       HALT  
0079: 30       HALT  
007A: 30       HALT  
007B: 30       HALT  
                                   (0217) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0218) ; vector jump targets are modified automatically according to the user
                                   (0219) ; modules selected. This occurs when the 'Generate Application' opera-
007C: 7E       RETI                (0220) ; tion is run causing PSoC Designer to create boot.asm and the other
007D: 30       HALT  
007E: 30       HALT  
007F: 30       HALT  
                                   (0221) ; configuration files. If you need to hard code a vector, update the
                                   (0222) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0223) ; of this file.
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) 
                                   (0226)     AREA TOP (ROM, ABS, CON)
                                   (0227) 
                                   (0228)     org   0                        ;Reset Interrupt Vector
                                   (0229) IF	(TOOLCHAIN & HITECH)
                                   (0230) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0231) ELSE
                                   (0232)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0233) ENDIF
                                   (0234) 
                                   (0235)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0236)     halt                           ;Stop execution if power falls too low
                                   (0237) 
                                   (0238)     org   08h                      ;Analog Column 0 / Decimator 0 Interrupt Vector
                                   (0239)     // call	void_handler
0080: 71 10    OR    F,16          (0240)     reti
0082: 62 E3 87 MOV   REG[227],135  (0241) 
0085: 70 EF    AND   F,239         (0242)     org   0Ch                      ;Analog Column 1 / Decimator 1 Interrupt Vector
                                   (0243)     // call	void_handler
                                   (0244)     reti
                                   (0245) 
                                   (0246)     org   10h                      ;Analog Column 2 / Decimator 2 Interrupt Vector
                                   (0247)     // call	void_handler
                                   (0248)     reti
                                   (0249) 
                                   (0250)     org   14h                      ;Analog Column 3 / Decimator 3 Interrupt Vector
0087: 41 FE FB AND   REG[254],251  (0251)     // call	void_handler
                                   (0252)     reti
                                   (0253)     
                                   (0254)     org   18h                      ;VC3 Interrupt Vector
                                   (0255)     // call	void_handler
                                   (0256)     reti
                                   (0257) 
                                   (0258)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0259)     // call	void_handler
                                   (0260)     reti
008A: 50 80    MOV   A,128         (0261) 
008C: 4E       SWAP  SP,A          (0262)     org   20h                      ;PSoC Block DBC00 Interrupt Vector
                                   (0263)     // call	void_handler
                                   (0264)     reti
                                   (0265) 
                                   (0266)     org   24h                      ;PSoC Block DBC01 Interrupt Vector
                                   (0267)     ljmp	Dispatch_INTERRUPT_9
                                   (0268)     reti
                                   (0269) 
                                   (0270)     org   28h                      ;PSoC Block DCC02 Interrupt Vector
                                   (0271)     ljmp	Dispatch_INTERRUPT_10
                                   (0272)     reti
                                   (0273) 
                                   (0274)     org   2Ch                      ;PSoC Block DCC03 Interrupt Vector
                                   (0275)     ljmp	Dispatch_INTERRUPT_11
                                   (0276)     reti
                                   (0277)     
                                   (0278)     org   30h                      ;PSoC Block DBC10 Interrupt Vector
                                   (0279)     // call	void_handler
                                   (0280)     reti
                                   (0281) 
                                   (0282)     org   34h                      ;PSoC Block DBC11 Interrupt Vector
                                   (0283)     // call	void_handler
                                   (0284)     reti
                                   (0285) 
                                   (0286)     org   38h                      ;PSoC Block DCC12 Interrupt Vector
                                   (0287)     ljmp	Dispatch_INTERRUPT_14
                                   (0288)     reti
                                   (0289) 
                                   (0290)     org   3Ch                      ;PSoC Block DCC13 Interrupt Vector
                                   (0291)     ljmp	Dispatch_INTERRUPT_15
                                   (0292)     reti
                                   (0293) 
008D: 55 F8 00 MOV   [248],0       (0294) 	org   40h                      ;PSoC Block DBC20 Interrupt Vector
0090: 55 F9 00 MOV   [249],0       (0295)     // call	void_handler
                                   (0296)     reti
                                   (0297) 	
                                   (0298) 	org   44h                      ;PSoC Block DBC21 Interrupt Vector
                                   (0299)     // call	void_handler
                                   (0300)     reti
                                   (0301) 	
                                   (0302) 	org   48h                      ;PSoC Block DCC22 Interrupt Vector
                                   (0303)     // call	void_handler
                                   (0304)     reti
                                   (0305) 	
                                   (0306) 	org   4Ch                      ;PSoC Block DCC23 Interrupt Vector
                                   (0307)     // call	void_handler
                                   (0308)     reti
                                   (0309) 	 
                                   (0310)     org   60h                      ;PSoC I2C0 Interrupt Vector
                                   (0311)     // call	void_handler
                                   (0312)     reti
                                   (0313) 
                                   (0314) 	org   64h                      ;PSoC I2C1 Interrupt Vector
                                   (0315)     // call	void_handler
                                   (0316)     reti
                                   (0317) 	
0093: 71 10    OR    F,16          (0318) 	org   68h                      ;PSoC SARADC Interrupt Vector
0095: 62 E0 1A MOV   REG[224],26   (0319)     // call	void_handler
0098: 70 EF    AND   F,239         (0320)     reti
009A: 62 E3 38 MOV   REG[227],56   (0321) 	
                                   (0322) 	org   6Ch                      ;PSoC RTC Interrupt Vector
                                   (0323)     // call	void_handler
                                   (0324)     reti
                                   (0325) 	
                                   (0326) 	org   70h                      ;Analog Column 4 Interrupt Vector
                                   (0327)     // call	void_handler
                                   (0328)     reti
                                   (0329) 	
                                   (0330) 	org   74h                      ;Analog Column 5 Interrupt Vector
                                   (0331)     // call	void_handler
                                   (0332)     reti
                                   (0333) 	
                                   (0334)     org   7Ch                      ;Sleep Timer Interrupt Vector
                                   (0335)     // call	void_handler
                                   (0336)     reti
                                   (0337) 
                                   (0338) ;-----------------------------------------------------------------------------
                                   (0339) ;  Start of Execution.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0342) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0343) ;
                                   (0344) 
                                   (0345) IF	(TOOLCHAIN & HITECH)
                                   (0346)  	AREA PD_startup(CODE, REL, CON)
                                   (0347) ELSE
                                   (0348)     org 80h
                                   (0349) ENDIF
                                   (0350) __Start:
                                   (0351) 
009D: 62 71 05 MOV   REG[113],5    (0352)     ; initialize SMP values for voltage stabilization, if required,
00A0: 62 72 05 MOV   REG[114],5    (0353)     ; leaving power-on reset (POR) level at the default (low) level, at
00A3: 62 73 05 MOV   REG[115],5    (0354)     ; least for now. 
00A6: 62 74 05 MOV   REG[116],5    (0355)     ;
                                   (0356)     M8C_SetBank1
                                   (0357)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0358)     M8C_SetBank0
                                   (0359) 
                                   (0360) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0361)     M8C_EnableWatchDog
                                   (0362) ENDIF
                                   (0363) 
                                   (0364) IF ( SELECT_32K )
                                   (0365)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0366) ELSE
                                   (0367)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0368) ENDIF
                                   (0369) 
                                   (0370)     ;---------------------------
                                   (0371)     ; Set up the Temporary stack
                                   (0372)     ;---------------------------
                                   (0373)     ; A temporary stack is set up for the SSC instructions.
                                   (0374)     ; The real stack start will be assigned later.
                                   (0375)     ;
                                   (0376) _stack_start:          equ 80h
                                   (0377)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0378)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0379) 
                                   (0380)     ;------------------------
                                   (0381)     ; Set Power-related Trim 
                                   (0382)     ;------------------------
                                   (0383) 
00A9: 62 D1 03 MOV   REG[209],3    (0384) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00AC: 50 00    MOV   A,0           (0385)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00AE: 4E       SWAP  SP,A          (0386)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00AF: 62 D3 03 MOV   REG[211],3    (0387)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00B2: 62 D0 00 MOV   REG[208],0    (0388) ELSE
00B5: 62 D5 00 MOV   REG[213],0    (0389) 	IF ( AGND_BYPASS )
00B8: 62 D4 00 MOV   REG[212],0    (0390)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0391)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0392)     ; bit in the write-only BDG_TR register. Recalculate the register
00BB: 71 C0    OR    F,192         (0393)     ; value using the proper trim values.
                                   (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0396)   ENDIF
                                   (0397)  ENDIF
                                   (0398) ENDIF ; 5.0 V Operation
                                   (0399) 
                                   (0400) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0401)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0402)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0403)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0404)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0405)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0406)  ENDIF
                                   (0407) ENDIF ; 3.3 Volt Operation
                                   (0408) 
                                   (0409) 
                                   (0410)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00BD: 7C 06 28 LCALL 0x0628        (0411)     mov  [bSSC_KEYSP], 0
00C0: 70 EF    AND   F,239         (0412) 
                                   (0413)     ;---------------------------------------
                                   (0414)     ; Initialize Crystal Oscillator and PLL
                                   (0415)     ;---------------------------------------
                                   (0416) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0417)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0418)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0419)     ; is left off.  The SleepTimer period is set to 1 sec to time the wait for
                                   (0420)     ; the ECO to stabilize.
                                   (0421)     ;
                                   (0422)     M8C_SetBank1
                                   (0423)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0424)     M8C_SetBank0
                                   (0425)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0426)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0427)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0428) .WaitFor1s:
                                   (0429)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0430)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0431)                                           ;  since interrupts are not globally enabled
                                   (0432) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0433)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0434)     M8C_SetBank1
                                   (0435)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0436)     M8C_SetBank0
                                   (0437)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0438) 
                                   (0439) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0440) 
                                   (0441) IF ( PLL_MODE )
                                   (0442)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                   (0443)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
00C2: 62 D0 00 MOV   REG[208],0    (0444)     ;
                                   (0445)     M8C_SetBank1
                                   (0446)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0447)     M8C_SetBank0
                                   (0448)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0449)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                   (0450) 
00C5: 50 06    MOV   A,6           (0451) .WaitFor16ms:
00C7: 57 26    MOV   X,38          (0452)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00C9: 08       PUSH  A             (0453)     jz   .WaitFor16ms
00CA: 28       ROMX                (0454)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00CB: 53 9D    MOV   [__r0],A      (0455)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00CD: 18       POP   A             (0456)     M8C_SetBank0
00CE: 75       INC   X             (0457) 
00CF: 09 00    ADC   A,0           (0458) IF      ( WAIT_FOR_32K )
00D1: 28       ROMX                (0459) ELSE ; !( WAIT_FOR_32K )
00D2: 4B       SWAP  A,X           (0460)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
00D3: 51 9D    MOV   A,[157]       (0461)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                   (0462) ENDIF ;(WAIT_FOR_32K)
00D5: 80 04    JMP   0x00DA        (0463) ENDIF ;(PLL_MODE)
                                   (0464) 
                                   (0465)     ;------------------------
                                   (0466)     ; Close CT leakage path.
                                   (0467)     ;------------------------
                                   (0468)     mov   reg[0x71], 05h
                                   (0469)     mov   reg[0x72], 05h
                                   (0470)     mov   reg[0x73], 05h
                                   (0471)     mov   reg[0x74], 05h
                                   (0472) 
                                   (0473) 
                                   (0474) 
                                   (0475) IF	(TOOLCHAIN & HITECH)
                                   (0476)     ;---------------------------------------------
                                   (0477)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0478)     ;---------------------------------------------
                                   (0479) 	global		__Lstackps
                                   (0480) 	mov     a,low __Lstackps
00D7: 75       INC   X             (0481) 	swap    a,sp
00D8: 09 00    ADC   A,0           (0482) 
                                   (0483) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0484)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0485)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0486)     RAM_SETPAGE_CUR 0
00DA: 62 E3 00 MOV   REG[227],0    (0487)     RAM_SETPAGE_MVW 0
00DD: 08       PUSH  A             (0488)     RAM_SETPAGE_MVR 0
00DE: 28       ROMX                (0489)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00DF: 60 D5    MOV   REG[213],A    (0490)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00E1: 74       INC   A             (0491)     ELSE
00E2: A0 4B    JZ    0x012E        (0492)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00E4: 18       POP   A             (0493)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00E5: 75       INC   X             (0494) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00E6: 09 00    ADC   A,0           (0495) ELSE
00E8: 08       PUSH  A             (0496)     ;---------------------------------------------
00E9: 28       ROMX                (0497)     ; ImageCraft Enter the Large Memory Model, if applicable
00EA: 53 9D    MOV   [__r0],A      (0498)     ;---------------------------------------------
00EC: 18       POP   A             (0499) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00ED: 75       INC   X             (0500)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00EE: 09 00    ADC   A,0           (0501)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00F0: 08       PUSH  A             (0502)     swap  A, SP
00F1: 28       ROMX                (0503)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00F2: A0 1C    JZ    0x010F        (0504)     RAM_SETPAGE_CUR 0
00F4: 53 9C    MOV   [__r1],A      (0505)     RAM_SETPAGE_MVW 0
00F6: 18       POP   A             (0506)     RAM_SETPAGE_MVR 0
                                   (0507) 
                                   (0508)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0509)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0510)   ELSE
                                   (0511)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0512)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0513) ELSE
00F7: 75       INC   X             (0514)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00F8: 09 00    ADC   A,0           (0515)     swap  SP, A
00FA: 08       PUSH  A             (0516) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00FB: 28       ROMX                (0517) ENDIF ;	TOOLCHAIN
00FC: 3F 9D    MVI   [__r0],A      (0518) 
00FE: 47 9D FF TST   [157],255     (0519)     ;-------------------------
0101: B0 06    JNZ   0x0108        (0520)     ; Load Base Configuration
0103: 5D D5    MOV   A,REG[213]    (0521)     ;-------------------------
0105: 74       INC   A             (0522)     ; Load global parameter settings and load the user modules in the
0106: 60 D5    MOV   REG[213],A    (0523)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0524)     ; to minimize start up time; (2) We may still need to play with the
0108: 18       POP   A             (0525)     ; Sleep Timer.
0109: 7A 9C    DEC   [__r1]        (0526)     ;
010B: BF EB    JNZ   0x00F7        (0527)     lcall LoadConfigInit
010D: 8F C9    JMP   0x00D7        (0528)     M8C_SetBank0
                                   (0529) 
                                   (0530)     ;-----------------------------------
010F: 18       POP   A             (0531)     ; Initialize C Run-Time Environment
0110: 75       INC   X             (0532)     ;-----------------------------------
0111: 09 00    ADC   A,0           (0533) IF ( C_LANGUAGE_SUPPORT )
0113: 08       PUSH  A             (0534) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0114: 28       ROMX                (0535)     mov  A,0                           ; clear the 'bss' segment to zero
0115: 53 9C    MOV   [__r1],A      (0536)     mov  [__r0],<__bss_start
0117: 50 00    MOV   A,0           (0537) BssLoop:
                                   (0538)     cmp  [__r0],<__bss_end
                                   (0539)     jz   BssDone
                                   (0540)     mvi  [__r0],A
                                   (0541)     jmp  BssLoop
                                   (0542) BssDone:
0119: 3F 9D    MVI   [__r0],A      (0543)     mov  A,>__idata_start              ; copy idata to data segment
011B: 47 9D FF TST   [157],255     (0544)     mov  X,<__idata_start
011E: B0 08    JNZ   0x0127        (0545)     mov  [__r0],<__data_start
0120: 5D D5    MOV   A,REG[213]    (0546) IDataLoop:
0122: 74       INC   A             (0547)     cmp  [__r0],<__data_end
0123: 60 D5    MOV   REG[213],A    (0548)     jz   C_RTE_Done
0125: 50 00    MOV   A,0           (0549)     push A
                                   (0550)     romx
0127: 7A 9C    DEC   [__r1]        (0551)     mvi  [__r0],A
0129: BF EF    JNZ   0x0119        (0552)     pop  A
012B: 18       POP   A             (0553)     inc  X
012C: 8F AA    JMP   0x00D7        (0554)     adc  A,0
                                   (0555)     jmp  IDataLoop
                                   (0556) 
012E: 18       POP   A             (0557) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0558) 
                                   (0559) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0560)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0561)                                        ; to use the Virtual Register page.
                                   (0562) 
                                   (0563)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0564)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0565)     ; text segment and may have been relocated by the Code Compressor.
                                   (0566)     ;
                                   (0567)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0568)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0569)     push  A
                                   (0570)     romx                               ; get the MSB of xidata's address
                                   (0571)     mov   [__r0], A
                                   (0572)     pop   A
                                   (0573)     inc   X
                                   (0574)     adc   A, 0
                                   (0575)     romx                               ; get the LSB of xidata's address
                                   (0576)     swap  A, X
                                   (0577)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0578)                                        ;   XIData structure list in flash
                                   (0579)     jmp   .AccessStruct
                                   (0580) 
                                   (0581)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0582)     ; values of C variables. Each structure contains 3 member elements.
                                   (0583)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0584)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0585)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0586)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0587)     ; value in the second member element, an unsigned byte:
                                   (0588)     ; (1) If the value of the second element is non-zero, it represents
                                   (0589)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0590)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0591)     ; the bytes are copied to the block of RAM.
                                   (0592)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0593)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0594)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0595) 
                                   (0596) .AccessNextStructLoop:
                                   (0597)     inc   X                            ; pXIData++
                                   (0598)     adc   A, 0
                                   (0599) .AccessStruct:                         ; Entry point for first block
                                   (0600)     ;
                                   (0601)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0602)     ;
                                   (0603)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0604)     push  A
                                   (0605)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0606)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
                                   (0607)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0608)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0609)     pop   A                            ; restore pXIData to [A,X]
                                   (0610)     inc   X                            ; pXIData++
                                   (0611)     adc   A, 0
012F: 71 10    OR    F,16          (0612)     push  A
                                   (0613)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0614)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0615)     pop   A                            ; restore pXIData to [A,X]
                                   (0616)     inc   X                            ; pXIData++ (point to size)
                                   (0617)     adc   A, 0
                                   (0618)     push  A
                                   (0619)     romx                               ; Get the size (CPU.A <- *pXIData)
0131: 43 E3 20 OR    REG[227],32   (0620)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
                                   (0621)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0622)     pop   A                            ; restore pXIData to [A,X]
                                   (0623) 
                                   (0624) .CopyNextByteLoop:
0134: 70 EF    AND   F,239         (0625)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0626)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0627)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0628)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0629)     ;
                                   (0630)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0631)     adc   A, 0
                                   (0632)     push  A
                                   (0633)     romx                               ; Get the data value (CPU.A <- *pXIData)
0136: 62 E0 00 MOV   REG[224],0    (0634)     mvi   [__r0], A                    ; Transfer the data to RAM
                                   (0635)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0636)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0637)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0139: 71 10    OR    F,16          (0638)     inc   A
013B: 62 E0 1B MOV   REG[224],27   (0639)     mov   reg[ MVW_PP], A
013E: 43 E2 00 OR    REG[226],0    (0640) .CopyLoopTail:
0141: 70 EF    AND   F,239         (0641)     pop   A                            ; restore pXIData to [A,X]
                                   (0642)     dec   [__r1]                       ; End of this array in flash?
                                   (0643)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0644)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0645) 
                                   (0646) .ClearRAMBlockToZero:
0143: 62 E2 00 MOV   REG[226],0    (0647)     pop   A                            ; restore pXIData to [A,X]
                                   (0648)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0649)     adc   A, 0
                                   (0650)     push  A
                                   (0651)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0652)     mov   [__r1], A                    ; Initialize downcounter
                                   (0653)     mov   A, 0                         ; Initialize source data
                                   (0654) 
0146: 7C 12 00 LCALL __text_start  (0655) .ClearRAMBlockLoop:
                                   (0656)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
0149: 8F FF    JMP   0x0149        (0657)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0658)     ;
                                   (0659)     mvi   [__r0], A                    ; Clear a byte
                                   (0660)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0661)     jnz   .ClearLoopTail               ;   No crossing, keep going
                                   (0662)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0663)     inc   A
                                   (0664)     mov   reg[ MVW_PP], A
                                   (0665)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0666) .ClearLoopTail:
                                   (0667)     dec   [__r1]                       ; Was this the last byte?
                                   (0668)     jnz   .ClearRAMBlockLoop           ;   No,  continue
                                   (0669)     pop   A                            ;   Yes, restore pXIData to [A,X] and
                                   (0670)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0671) 
                                   (0672) .C_RTE_WrapUp:
014B: 50 10    MOV   A,16          (0673)     pop   A                            ; balance stack
                                   (0674) 
0365: 71 10    OR    F,16          (0675) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL

FILE: lib\psocconfigtbl.asm
0367: 62 00 00 MOV   REG[0],0      (0341) ; Generated by PSoC Designer 5.0.985.0
036A: 62 01 FF MOV   REG[1],255    (0342) ;
036D: 70 EF    AND   F,239         (0343) include "m8c.inc"
036F: 62 03 E1 MOV   REG[3],225    (0344) ;  Personalization tables 
0372: 62 02 1E MOV   REG[2],30     (0345) export LoadConfigTBL_receiver_config_Bank1
0375: 71 10    OR    F,16          (0346) export LoadConfigTBL_receiver_config_Bank0
0377: 62 02 00 MOV   REG[2],0      (0347) export LoadConfigTBL_receiver_config_Ordered
037A: 62 03 00 MOV   REG[3],0      (0348) export UnloadConfigTBL_receiver_config_Bank1
037D: 70 EF    AND   F,239         (0349) export UnloadConfigTBL_receiver_config_Bank0
037F: 62 01 00 MOV   REG[1],0      (0350) export ReloadConfigTBL_receiver_config_Bank1
0382: 71 10    OR    F,16          (0351) export ReloadConfigTBL_receiver_config_Bank0
0384: 62 04 00 MOV   REG[4],0      (0352) export LoadConfigTBL_pc_listener_Bank1
0387: 62 05 FF MOV   REG[5],255    (0353) export LoadConfigTBL_pc_listener_Bank0
038A: 70 EF    AND   F,239         (0354) export UnloadConfigTBL_pc_listener_Bank1
038C: 62 07 FF MOV   REG[7],255    (0355) export UnloadConfigTBL_pc_listener_Bank0
038F: 62 06 00 MOV   REG[6],0      (0356) export UnloadConfigTBL_Total_Bank1
0392: 71 10    OR    F,16          (0357) export UnloadConfigTBL_Total_Bank0
0394: 62 06 00 MOV   REG[6],0      (0358) AREA lit(rom, rel)
0397: 62 07 00 MOV   REG[7],0      (0359) LoadConfigTBL_pc_listener_Bank0:
039A: 70 EF    AND   F,239         (0360) ;  Instance name COMP_SERIAL, User Module UART
039C: 62 05 00 MOV   REG[5],0      (0361) ;       Instance name COMP_SERIAL, Block Name RX(DCC13)
039F: 71 10    OR    F,16          (0362) 	db		3fh, 00h		;COMP_SERIAL_RX_CONTROL_REG(DCC13CR0)
03A1: 62 08 00 MOV   REG[8],0      (0363) 	db		3dh, 00h		;COMP_SERIAL_(DCC13DR1)
03A4: 62 09 FF MOV   REG[9],255    (0364) 	db		3eh, 00h		;COMP_SERIAL_RX_BUFFER_REG (DCC13DR2)
03A7: 70 EF    AND   F,239         (0365) ;       Instance name COMP_SERIAL, Block Name TX(DCC12)
03A9: 62 0B FF MOV   REG[11],255   (0366) 	db		3bh, 00h		;COMP_SERIAL_TX_CONTROL_REG(DCC12CR0)
03AC: 62 0A 00 MOV   REG[10],0     (0367) 	db		39h, 00h		;COMP_SERIAL_TX_BUFFER_REG (DCC12DR1)
03AF: 71 10    OR    F,16          (0368) 	db		3ah, 00h		;COMP_SERIAL_(DCC12DR2)
03B1: 62 0A 00 MOV   REG[10],0     (0369) ;  Instance name TX_REPEATER_14, User Module TX8
03B4: 62 0B 00 MOV   REG[11],0     (0370) ;       Instance name TX_REPEATER_14, Block Name TX8(DCC02)
03B7: 70 EF    AND   F,239         (0371) 	db		2bh, 00h		;TX_REPEATER_14_CONTROL_REG  (DCC02CR0)
03B9: 62 09 00 MOV   REG[9],0      (0372) 	db		29h, 00h		;TX_REPEATER_14_TX_BUFFER_REG(DCC02DR1)
03BC: 71 10    OR    F,16          (0373) 	db		2ah, 00h		;TX_REPEATER_14_(DCC02DR2)
03BE: 62 0C 00 MOV   REG[12],0     (0374) ;  Instance name TX_REPEATER_23, User Module TX8
03C1: 62 0D 00 MOV   REG[13],0     (0375) ;       Instance name TX_REPEATER_23, Block Name TX8(DCC03)
03C4: 70 EF    AND   F,239         (0376) 	db		2fh, 00h		;TX_REPEATER_23_CONTROL_REG  (DCC03CR0)
03C6: 62 0F 00 MOV   REG[15],0     (0377) 	db		2dh, 00h		;TX_REPEATER_23_TX_BUFFER_REG(DCC03DR1)
03C9: 62 0E 00 MOV   REG[14],0     (0378) 	db		2eh, 00h		;TX_REPEATER_23_(DCC03DR2)
03CC: 71 10    OR    F,16          (0379) ;  Instance name TX_TIMEOUT, User Module Timer16
03CE: 62 0E 00 MOV   REG[14],0     (0380) ;       Instance name TX_TIMEOUT, Block Name TIMER16_LSB(DBC00)
03D1: 62 0F 00 MOV   REG[15],0     (0381) 	db		23h, 00h		;TX_TIMEOUT_CONTROL_LSB_REG(DBC00CR0)
03D4: 70 EF    AND   F,239         (0382) 	db		21h, 40h		;TX_TIMEOUT_PERIOD_LSB_REG(DBC00DR1)
03D6: 62 0D 00 MOV   REG[13],0     (0383) 	db		22h, 00h		;TX_TIMEOUT_COMPARE_LSB_REG(DBC00DR2)
03D9: 71 10    OR    F,16          (0384) ;       Instance name TX_TIMEOUT, Block Name TIMER16_MSB(DBC01)
03DB: 62 10 00 MOV   REG[16],0     (0385) 	db		27h, 04h		;TX_TIMEOUT_CONTROL_MSB_REG(DBC01CR0)
03DE: 62 11 00 MOV   REG[17],0     (0386) 	db		25h, 1fh		;TX_TIMEOUT_PERIOD_MSB_REG(DBC01DR1)
03E1: 70 EF    AND   F,239         (0387) 	db		26h, 00h		;TX_TIMEOUT_COMPARE_MSB_REG(DBC01DR2)
03E3: 62 13 00 MOV   REG[19],0     (0388) 	db		ffh
03E6: 62 12 00 MOV   REG[18],0     (0389) LoadConfigTBL_pc_listener_Bank1:
03E9: 71 10    OR    F,16          (0390) ;  Instance name COMP_SERIAL, User Module UART
03EB: 62 12 00 MOV   REG[18],0     (0391) ;       Instance name COMP_SERIAL, Block Name RX(DCC13)
03EE: 62 13 00 MOV   REG[19],0     (0392) 	db		3fh, 00h		;COMP_SERIAL_(DCC13CR1)
03F1: 70 EF    AND   F,239         (0393) 	db		3ch, 05h		;COMP_SERIAL_RX_FUNC_REG   (DCC13FN)
03F3: 62 11 00 MOV   REG[17],0     (0394) 	db		3dh, f6h		;COMP_SERIAL_RX_INPUT_REG  (DCC13IN)
03F6: 62 15 00 MOV   REG[21],0     (0395) 	db		3eh, 80h		;COMP_SERIAL_RX_OUTPUT_REG (DCC13OU)
03F9: 62 16 00 MOV   REG[22],0     (0396) ;       Instance name COMP_SERIAL, Block Name TX(DCC12)
03FC: 62 17 00 MOV   REG[23],0     (0397) 	db		3bh, 00h		;COMP_SERIAL_(DCC12CR1)
03FF: 71 10    OR    F,16          (0398) 	db		38h, 1dh		;COMP_SERIAL_TX_FUNC_REG   (DCC12FN)
0401: 62 15 00 MOV   REG[21],0     (0399) 	db		39h, 06h		;COMP_SERIAL_TX_INPUT_REG  (DCC12IN)
0404: 62 14 00 MOV   REG[20],0     (0400) 	db		3ah, 85h		;COMP_SERIAL_TX_OUTPUT_REG (DCC12OU)
0407: 62 16 00 MOV   REG[22],0     (0401) ;  Instance name TX_REPEATER_14, User Module TX8
040A: 62 17 00 MOV   REG[23],0     (0402) ;       Instance name TX_REPEATER_14, Block Name TX8(DCC02)
0628: 62 D0 00 MOV   REG[208],0    (0403) 	db		2bh, 00h		;TX_REPEATER_14_(DCC02CR1)

FILE: lib\psocconfig.asm
062B: 55 08 00 MOV   [8],0         (0070) ; Generated by PSoC Designer 5.0.985.0
                                   (0071) ;
062E: 7C 06 35 LCALL 0x0635        (0072) INCLUDE "PSoCDynamic.inc"
0631: 7C 03 65 LCALL 0x0365        (0073) ;==========================================================================
                                   (0074) ;  PSoCConfig.asm
                                   (0075) ;  @PSOC_VERSION
                                   (0076) ;
0634: 7F       RET                 (0077) ;  Version: 0.85
                                   (0078) ;  Revised: June 22, 2004
                                   (0079) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0080) ;
                                   (0081) ;  This file is generated by the Device Editor on Application Generation.
                                   (0082) ;  It contains code which loads the configuration data table generated in
                                   (0083) ;  the file PSoCConfigTBL.asm
                                   (0084) ;
                                   (0085) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0086) ;  Edits to this file will not be preserved.
                                   (0087) ;==========================================================================
                                   (0088) ;
                                   (0089) include "m8c.inc"
                                   (0090) include "memory.inc"
                                   (0091) include "GlobalParams.inc"
                                   (0092) 
                                   (0093) export LoadConfigInit
                                   (0094) export _LoadConfigInit
                                   (0095) export LoadConfig_receiver_config
                                   (0096) export _LoadConfig_receiver_config
                                   (0097) export UnloadConfig_receiver_config
                                   (0098) export _UnloadConfig_receiver_config
                                   (0099) export ReloadConfig_receiver_config
                                   (0100) export _ReloadConfig_receiver_config
0635: 71 10    OR    F,16          (0101) export LoadConfig_pc_listener
                                   (0102) export _LoadConfig_pc_listener
0637: 10       PUSH  X             (0103) export UnloadConfig_pc_listener
0638: 70 EF    AND   F,239         (0104) export _UnloadConfig_pc_listener
063A: 50 00    MOV   A,0           (0105) export UnloadConfig_Total
063C: 67       ASR   A             (0106) export _UnloadConfig_Total
                                   (0107) export ACTIVE_CONFIG_STATUS
063D: 50 02    MOV   A,2           (0108) 
063F: 57 25    MOV   X,37          (0109) export NO_SHADOW
0641: 7C 07 8A LCALL 0x078A        (0110) export _NO_SHADOW
                                   (0111) 
0644: 50 01    MOV   A,1           (0112) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
0646: 67       ASR   A             (0113) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0114) 
0647: 50 02    MOV   A,2           (0115) AREA psoc_config(rom, rel)
0649: 57 AC    MOV   X,172         (0116) 
064B: 7C 07 8A LCALL 0x078A        (0117) ;---------------------------------------------------------------------------
                                   (0118) ; LoadConfigInit - Establish the start-up configuration (except for a few
064E: 62 D0 00 MOV   REG[208],0    (0119) ;                  parameters handled by boot code, like CPU speed). This
                                   (0120) ;                  function can be called from user code, but typically it
0651: 2E 08 01 OR    [8],1         (0121) ;                  is only called from boot.
0654: 70 EF    AND   F,239         (0122) ;
0656: 20       POP   X             (0123) ;       INPUTS: None.
                                   (0124) ;      RETURNS: Nothing.
                                   (0125) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
0657: 7F       RET                 (0126) ;               In the large memory model currently only the page
                                   (0127) ;               pointer registers listed below are modified.  This does
                                   (0128) ;               not guarantee that in future implementations of this
                                   (0129) ;               function other page pointer registers will not be
                                   (0130) ;               modified.
                                   (0131) ;          
                                   (0132) ;               Page Pointer Registers Modified: 
                                   (0133) ;               CUR_PP
                                   (0134) ;
                                   (0135) _LoadConfigInit:
                                   (0136)  LoadConfigInit:
                                   (0137)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0138)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0139) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0140) 
                                   (0141) 	lcall	LoadConfig_receiver_config
                                   (0142) 	lcall	LoadConfigTBL_receiver_config_Ordered
                                   (0143) 
                                   (0144) 
                                   (0145)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0146)     ret
                                   (0147) 
                                   (0148) ;---------------------------------------------------------------------------
                                   (0149) ; Load Configuration receiver_config
                                   (0150) ;
0658: 10       PUSH  X             (0151) ;    Load configuration registers for receiver_config.
0659: 70 EF    AND   F,239         (0152) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
065B: 50 00    MOV   A,0           (0153) ;
065D: 67       ASR   A             (0154) ;       INPUTS: None.
                                   (0155) ;      RETURNS: Nothing.
065E: 50 04    MOV   A,4           (0156) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0660: 57 0E    MOV   X,14          (0157) ;               modified as may the Page Pointer registers!
0662: 7C 07 8A LCALL 0x078A        (0158) ;               In the large memory model currently only the page
                                   (0159) ;               pointer registers listed below are modified.  This does
0665: 50 01    MOV   A,1           (0160) ;               not guarantee that in future implementations of this
0667: 67       ASR   A             (0161) ;               function other page pointer registers will not be
                                   (0162) ;               modified.
0668: 50 04    MOV   A,4           (0163) ;          
066A: 57 33    MOV   X,51          (0164) ;               Page Pointer Registers Modified: 
066C: 7C 07 8A LCALL 0x078A        (0165) ;               CUR_PP
                                   (0166) ;
                                   (0167) _LoadConfig_receiver_config:
066F: 62 D0 00 MOV   REG[208],0    (0168)  LoadConfig_receiver_config:
0672: 2E 08 01 OR    [8],1         (0169)     RAM_PROLOGUE RAM_USE_CLASS_4
0675: 70 EF    AND   F,239         (0170) 	M8C_SetBank1
0677: 20       POP   X             (0171) 
                                   (0172) 	push	x
                                   (0173)     M8C_SetBank0                    ; Force bank 0
0678: 7F       RET                 (0174)     mov     a, 0                    ; Specify bank 0
                                   (0175)     asr     a                       ; Store in carry flag
                                   (0176)                                     ; Load bank 0 table:
                                   (0177)     mov     A, >LoadConfigTBL_receiver_config_Bank0
                                   (0178)     mov     X, <LoadConfigTBL_receiver_config_Bank0
                                   (0179)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0180) 
                                   (0181)     mov     a, 1                    ; Specify bank 1
                                   (0182)     asr     a                       ; Store in carry flag
                                   (0183)                                     ; Load bank 1 table:
                                   (0184)     mov     A, >LoadConfigTBL_receiver_config_Bank1
                                   (0185)     mov     X, <LoadConfigTBL_receiver_config_Bank1
                                   (0186)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0187) 
                                   (0188) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0189) ; set config active bit
                                   (0190) 	or		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
                                   (0191)     M8C_SetBank0                    ; Force return to bank 0
                                   (0192) 	pop		x
                                   (0193) 
                                   (0194)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0195)     ret
                                   (0196) 
                                   (0197) ;---------------------------------------------------------------------------
                                   (0198) ; Reload Configuration receiver_config
                                   (0199) ;
0679: 10       PUSH  X             (0200) ;    Reload configuration registers for receiver_config.
067A: 70 EF    AND   F,239         (0201) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
067C: 50 00    MOV   A,0           (0202) ;
067E: 67       ASR   A             (0203) ;       INPUTS: None.
                                   (0204) ;      RETURNS: Nothing.
067F: 50 04    MOV   A,4           (0205) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0681: 57 64    MOV   X,100         (0206) ;               modified as may the Page Pointer registers!
0683: 7C 07 8A LCALL 0x078A        (0207) ;               In the large memory model currently only the page
                                   (0208) ;               pointer registers listed below are modified.  This does
0686: 50 01    MOV   A,1           (0209) ;               not guarantee that in future implementations of this
0688: 67       ASR   A             (0210) ;               function other page pointer registers will not be
                                   (0211) ;               modified.
0689: 50 04    MOV   A,4           (0212) ;          
068B: 57 71    MOV   X,113         (0213) ;               Page Pointer Registers Modified: 
068D: 7C 07 8A LCALL 0x078A        (0214) ;               CUR_PP
                                   (0215) ;
0690: 71 10    OR    F,16          (0216) _ReloadConfig_receiver_config:
0692: 70 EF    AND   F,239         (0217)  ReloadConfig_receiver_config:
                                   (0218)     RAM_PROLOGUE RAM_USE_CLASS_4
0694: 62 D0 00 MOV   REG[208],0    (0219) 
0697: 26 08 FE AND   [8],254       (0220) 	push	x
069A: 70 EF    AND   F,239         (0221)     M8C_SetBank0                    ; Force bank 0
069C: 20       POP   X             (0222)     mov     a, 0                    ; Specify bank 0
                                   (0223)     asr     a                       ; Store in carry flag
                                   (0224)                                     ; Bank 0 table address:
069D: 7F       RET                 (0225)     mov     A, >ReloadConfigTBL_receiver_config_Bank0
                                   (0226)     mov     X, <ReloadConfigTBL_receiver_config_Bank0
                                   (0227)     lcall   LoadConfig              ; Reload the bank 0 values
                                   (0228) 
                                   (0229)     mov     a, 1                    ; Specify bank 1
                                   (0230)     asr     a                       ; Store in carry flag
                                   (0231)                                     ; Bank 1 table address:
                                   (0232)     mov     A, >ReloadConfigTBL_receiver_config_Bank1
                                   (0233)     mov     X, <ReloadConfigTBL_receiver_config_Bank1
                                   (0234)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0235) 
                                   (0236) ; set config active bit
                                   (0237) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0238) 	or		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
                                   (0239)     M8C_SetBank0                    ; Force return to bank 0
                                   (0240) 	pop		x
                                   (0241) 
                                   (0242)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0243)     ret
                                   (0244) 
                                   (0245) ;---------------------------------------------------------------------------
                                   (0246) ; Unload Configuration receiver_config
                                   (0247) ;
                                   (0248) ;    Reset configuration registers for receiver_config
069E: 71 10    OR    F,16          (0249) ;    to their values as initially configured.
                                   (0250) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
06A0: 41 00 C1 AND   REG[0],193    (0251) ;
06A3: 43 00 3E OR    REG[0],62     (0252) ;       INPUTS: None.
                                   (0253) ;      RETURNS: Nothing.
06A6: 41 01 C1 AND   REG[1],193    (0254) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0255) ;               modified as may the Page Pointer registers!
06A9: 70 EF    AND   F,239         (0256) ;               In the large memory model currently only the page
06AB: 41 03 5F AND   REG[3],95     (0257) ;               pointer registers listed below are modified.  This does
                                   (0258) ;               not guarantee that in future implementations of this
06AE: 41 02 5F AND   REG[2],95     (0259) ;               function other page pointer registers will not be
06B1: 43 02 A0 OR    REG[2],160    (0260) ;               modified.
                                   (0261) ;          
06B4: 71 10    OR    F,16          (0262) ;               Page Pointer Registers Modified: 
06B6: 41 E1 00 AND   REG[225],0    (0263) ;               CUR_PP
06B9: 43 E1 C1 OR    REG[225],193  (0264) ;
                                   (0265) _UnloadConfig_receiver_config:
06BC: 70 EF    AND   F,239         (0266)  UnloadConfig_receiver_config:
06BE: 41 B0 3F AND   REG[176],63   (0267)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0268) 
06C1: 41 B3 F0 AND   REG[179],240  (0269) 	push	x
06C4: 43 B3 05 OR    REG[179],5    (0270)     M8C_SetBank0                    ; Force bank 0
                                   (0271)     mov     a, 0                    ; Specify bank 0
06C7: 41 B4 F0 AND   REG[180],240  (0272)     asr     a                       ; Store in carry flag
06CA: 43 B4 05 OR    REG[180],5    (0273)                                     ; Bank 0 table address:
                                   (0274)     mov     A, >UnloadConfigTBL_receiver_config_Bank0
06CD: 41 B5 ED AND   REG[181],237  (0275)     mov     X, <UnloadConfigTBL_receiver_config_Bank0
06D0: 43 B5 12 OR    REG[181],18   (0276)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0277) 
06D3: 41 B6 EE AND   REG[182],238  (0278)     mov     a, 1                    ; Specify bank 1
06D6: 43 B6 11 OR    REG[182],17   (0279)     asr     a                       ; Store in carry flag
                                   (0280)                                     ; Bank 1 table address:
06D9: 41 B8 3F AND   REG[184],63   (0281)     mov     A, >UnloadConfigTBL_receiver_config_Bank1
06DC: 43 B8 40 OR    REG[184],64   (0282)     mov     X, <UnloadConfigTBL_receiver_config_Bank1
                                   (0283)     lcall   LoadConfig              ; Unload the bank 1 values
06DF: 41 BD DF AND   REG[189],223  (0284) 
06E2: 43 BD 20 OR    REG[189],32   (0285) 	M8C_SetBank1
                                   (0286) 	M8C_SetBank0
06E5: 10       PUSH  X             (0287) ; clear config active bit
06E6: 70 EF    AND   F,239         (0288) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
06E8: 50 00    MOV   A,0           (0289) 	and		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], ~receiver_config_BIT
06EA: 67       ASR   A             (0290)     M8C_SetBank0                    ; Force return to bank 0
                                   (0291) 	pop		x
06EB: 50 01    MOV   A,1           (0292) 
06ED: 57 90    MOV   X,144         (0293)     RAM_EPILOGUE RAM_USE_CLASS_4
06EF: 7C 07 8A LCALL 0x078A        (0294)     ret
                                   (0295) 
06F2: 50 01    MOV   A,1           (0296) ;---------------------------------------------------------------------------
06F4: 67       ASR   A             (0297) ; Load Configuration pc_listener
                                   (0298) ;
06F5: 50 01    MOV   A,1           (0299) ;    Load configuration registers for pc_listener.
06F7: 57 B5    MOV   X,181         (0300) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
06F9: 7C 07 8A LCALL 0x078A        (0301) ;
                                   (0302) ;       INPUTS: None.
06FC: 62 D0 00 MOV   REG[208],0    (0303) ;      RETURNS: Nothing.
                                   (0304) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
06FF: 2E 08 02 OR    [8],2         (0305) ;               modified as may the Page Pointer registers!
0702: 70 EF    AND   F,239         (0306) ;               In the large memory model currently only the page
0704: 20       POP   X             (0307) ;               pointer registers listed below are modified.  This does
                                   (0308) ;               not guarantee that in future implementations of this
                                   (0309) ;               function other page pointer registers will not be
0705: 7F       RET                 (0310) ;               modified.
                                   (0311) ;          
                                   (0312) ;               Page Pointer Registers Modified: 
                                   (0313) ;               CUR_PP
                                   (0314) ;
                                   (0315) _LoadConfig_pc_listener:
                                   (0316)  LoadConfig_pc_listener:
                                   (0317)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0318) 	M8C_SetBank1
                                   (0319) ; writing Port_0_DriveMode_0 register
                                   (0320) 	and		reg[ 0h], ~3eh
                                   (0321) 	or		reg[ 0h], 3eh
                                   (0322) ; writing Port_0_DriveMode_1 register
                                   (0323) 	and		reg[ 1h], ~3eh
                                   (0324) ; writing Port_0_DriveMode_2 register
                                   (0325) 	M8C_SetBank0
                                   (0326) 	and		reg[ 3h], ~a0h
                                   (0327) ; writing Port_0_GlobalSelect register
                                   (0328) 	and		reg[ 2h], ~a0h
                                   (0329) 	or		reg[ 2h], a0h
                                   (0330) ; writing OscillatorControl_1 register
                                   (0331) 	M8C_SetBank1
                                   (0332) 	and		reg[e1h], ~ffh
                                   (0333) 	or		reg[e1h], c1h
                                   (0334) ; writing Row_0_InputMux register
                                   (0335) 	M8C_SetBank0
0706: 10       PUSH  X             (0336) 	and		reg[b0h], ~c0h
0707: 70 EF    AND   F,239         (0337) ; writing Row_0_LogicSelect_0 register
0709: 50 00    MOV   A,0           (0338) 	and		reg[b3h], ~ fh
070B: 67       ASR   A             (0339) 	or		reg[b3h],  5h
                                   (0340) ; writing Row_0_LogicSelect_1 register
070C: 50 01    MOV   A,1           (0341) 	and		reg[b4h], ~ fh
070E: 57 E6    MOV   X,230         (0342) 	or		reg[b4h],  5h
0710: 7C 07 8A LCALL 0x078A        (0343) ; writing Row_0_OutputDrive_0 register
                                   (0344) 	and		reg[b5h], ~12h
0713: 50 01    MOV   A,1           (0345) 	or		reg[b5h], 12h
0715: 67       ASR   A             (0346) ; writing Row_0_OutputDrive_1 register
                                   (0347) 	and		reg[b6h], ~11h
0716: 50 01    MOV   A,1           (0348) 	or		reg[b6h], 11h
0718: 57 F3    MOV   X,243         (0349) ; writing Row_1_InputMux register
071A: 7C 07 8A LCALL 0x078A        (0350) 	and		reg[b8h], ~c0h
                                   (0351) 	or		reg[b8h], 40h
071D: 71 10    OR    F,16          (0352) ; writing Row_1_OutputDrive_0 register
                                   (0353) 	and		reg[bdh], ~20h
071F: 41 E1 00 AND   REG[225],0    (0354) 	or		reg[bdh], 20h
0722: 43 E1 99 OR    REG[225],153  (0355) 
                                   (0356) 	push	x
0725: 70 EF    AND   F,239         (0357)     M8C_SetBank0                    ; Force bank 0
0727: 41 B0 3F AND   REG[176],63   (0358)     mov     a, 0                    ; Specify bank 0
072A: 43 B0 40 OR    REG[176],64   (0359)     asr     a                       ; Store in carry flag
                                   (0360)                                     ; Load bank 0 table:
072D: 41 B3 F0 AND   REG[179],240  (0361)     mov     A, >LoadConfigTBL_pc_listener_Bank0
0730: 43 B3 03 OR    REG[179],3    (0362)     mov     X, <LoadConfigTBL_pc_listener_Bank0
                                   (0363)     lcall   LoadConfig              ; Load the bank 0 values
0733: 41 B4 F0 AND   REG[180],240  (0364) 
0736: 43 B4 03 OR    REG[180],3    (0365)     mov     a, 1                    ; Specify bank 1
                                   (0366)     asr     a                       ; Store in carry flag
0739: 41 B5 ED AND   REG[181],237  (0367)                                     ; Load bank 1 table:
                                   (0368)     mov     A, >LoadConfigTBL_pc_listener_Bank1
073C: 41 B6 EE AND   REG[182],238  (0369)     mov     X, <LoadConfigTBL_pc_listener_Bank1
                                   (0370)     lcall   LoadConfig              ; Load the bank 1 values
073F: 41 B8 3F AND   REG[184],63   (0371) 
                                   (0372) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0742: 41 BD DF AND   REG[189],223  (0373) ; set config active bit
                                   (0374) 	or		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
0745: 41 02 5F AND   REG[2],95     (0375)     M8C_SetBank0                    ; Force return to bank 0
                                   (0376) 	pop		x
0748: 41 03 5F AND   REG[3],95     (0377) 
074B: 43 03 A0 OR    REG[3],160    (0378)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0379)     ret
074E: 71 10    OR    F,16          (0380) 
0750: 41 01 C1 AND   REG[1],193    (0381) ;---------------------------------------------------------------------------
0753: 43 01 3E OR    REG[1],62     (0382) ; Unload Configuration pc_listener
                                   (0383) ;
0756: 41 00 C1 AND   REG[0],193    (0384) ;    Reset configuration registers for pc_listener
0759: 70 EF    AND   F,239         (0385) ;    to their values as initially configured.
                                   (0386) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
075B: 62 D0 00 MOV   REG[208],0    (0387) ;
075E: 26 08 FD AND   [8],253       (0388) ;       INPUTS: None.
0761: 70 EF    AND   F,239         (0389) ;      RETURNS: Nothing.
0763: 20       POP   X             (0390) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0391) ;               modified as may the Page Pointer registers!
                                   (0392) ;               In the large memory model currently only the page
0764: 7F       RET                 (0393) ;               pointer registers listed below are modified.  This does
                                   (0394) ;               not guarantee that in future implementations of this
                                   (0395) ;               function other page pointer registers will not be
                                   (0396) ;               modified.
                                   (0397) ;          
                                   (0398) ;               Page Pointer Registers Modified: 
                                   (0399) ;               CUR_PP
                                   (0400) ;
                                   (0401) _UnloadConfig_pc_listener:
                                   (0402)  UnloadConfig_pc_listener:
                                   (0403)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0404) 
                                   (0405) 	push	x
                                   (0406)     M8C_SetBank0                    ; Force bank 0
                                   (0407)     mov     a, 0                    ; Specify bank 0
                                   (0408)     asr     a                       ; Store in carry flag
                                   (0409)                                     ; Bank 0 table address:
                                   (0410)     mov     A, >UnloadConfigTBL_pc_listener_Bank0
                                   (0411)     mov     X, <UnloadConfigTBL_pc_listener_Bank0
                                   (0412)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0413) 
                                   (0414)     mov     a, 1                    ; Specify bank 1
                                   (0415)     asr     a                       ; Store in carry flag
                                   (0416)                                     ; Bank 1 table address:
                                   (0417)     mov     A, >UnloadConfigTBL_pc_listener_Bank1
                                   (0418)     mov     X, <UnloadConfigTBL_pc_listener_Bank1
0765: 10       PUSH  X             (0419)     lcall   LoadConfig              ; Unload the bank 1 values
0766: 70 EF    AND   F,239         (0420) 
0768: 50 00    MOV   A,0           (0421) 	M8C_SetBank1
076A: 67       ASR   A             (0422) ; writing OscillatorControl_1 register
                                   (0423) 	and		reg[e1h], ~ffh
076B: 50 04    MOV   A,4           (0424) 	or		reg[e1h], 99h
076D: 57 A3    MOV   X,163         (0425) ; writing Row_0_InputMux register
076F: 7C 07 8A LCALL 0x078A        (0426) 	M8C_SetBank0
                                   (0427) 	and		reg[b0h], ~c0h
0772: 50 01    MOV   A,1           (0428) 	or		reg[b0h], 40h
0774: 67       ASR   A             (0429) ; writing Row_0_LogicSelect_0 register
                                   (0430) 	and		reg[b3h], ~ fh
0775: 50 04    MOV   A,4           (0431) 	or		reg[b3h],  3h
0777: 57 C4    MOV   X,196         (0432) ; writing Row_0_LogicSelect_1 register
0779: 7C 07 8A LCALL 0x078A        (0433) 	and		reg[b4h], ~ fh
                                   (0434) 	or		reg[b4h],  3h
077C: 71 10    OR    F,16          (0435) ; writing Row_0_OutputDrive_0 register
077E: 70 EF    AND   F,239         (0436) 	and		reg[b5h], ~12h
                                   (0437) ; writing Row_0_OutputDrive_1 register
0780: 62 D0 00 MOV   REG[208],0    (0438) 	and		reg[b6h], ~11h
0783: 55 08 00 MOV   [8],0         (0439) ; writing Row_1_InputMux register
0786: 70 EF    AND   F,239         (0440) 	and		reg[b8h], ~c0h
0788: 20       POP   X             (0441) ; writing Row_1_OutputDrive_0 register
                                   (0442) 	and		reg[bdh], ~20h
                                   (0443) ; writing Port_0_GlobalSelect register
0789: 7F       RET                 (0444) 	and		reg[ 2h], ~a0h
                                   (0445) ; writing Port_0_DriveMode_2 register
                                   (0446) 	and		reg[ 3h], ~a0h
                                   (0447) 	or		reg[ 3h], a0h
                                   (0448) ; writing Port_0_DriveMode_1 register
                                   (0449) 	M8C_SetBank1
                                   (0450) 	and		reg[ 1h], ~3eh
                                   (0451) 	or		reg[ 1h], 3eh
                                   (0452) ; writing Port_0_DriveMode_0 register
                                   (0453) 	and		reg[ 0h], ~3eh
                                   (0454) 	M8C_SetBank0
                                   (0455) ; clear config active bit
                                   (0456) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0457) 	and		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], ~pc_listener_BIT
                                   (0458)     M8C_SetBank0                    ; Force return to bank 0
                                   (0459) 	pop		x
                                   (0460) 
                                   (0461)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0462)     ret
                                   (0463) 
                                   (0464) ;---------------------------------------------------------------------------
                                   (0465) ; Unload Configuration Total
078A: 38 02    ADD   SP,2          (0466) ;
078C: 10       PUSH  X             (0467) ;    Reset configuration registers for Total
078D: 08       PUSH  A             (0468) ;    to their values as initially configured.
078E: 4F       MOV   X,SP          (0469) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
078F: 56 FC 00 MOV   [X-4],0       (0470) ;
0792: D0 04    JNC   0x0797        (0471) ;       INPUTS: None.
0794: 56 FC 01 MOV   [X-4],1       (0472) ;      RETURNS: Nothing.
                                   (0473) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0797: 18       POP   A             (0474) ;               modified as may the Page Pointer registers!
0798: 20       POP   X             (0475) ;               In the large memory model currently only the page
                                   (0476) ;               pointer registers listed below are modified.  This does
                                   (0477) ;               not guarantee that in future implementations of this
0799: 70 EF    AND   F,239         (0478) ;               function other page pointer registers will not be
079B: 62 E3 00 MOV   REG[227],0    (0479) ;               modified.
079E: 10       PUSH  X             (0480) ;          
079F: 08       PUSH  A             (0481) ;               Page Pointer Registers Modified: 
07A0: 28       ROMX                (0482) ;               CUR_PP
07A1: 39 FF    CMP   A,255         (0483) ;
07A3: A0 1F    JZ    0x07C3        (0484) _UnloadConfig_Total:
07A5: 4F       MOV   X,SP          (0485)  UnloadConfig_Total:
07A6: 48 FC 01 TST   [X-4],1       (0486)     RAM_PROLOGUE RAM_USE_CLASS_4
07A9: A0 03    JZ    0x07AD        (0487) 
07AB: 71 10    OR    F,16          (0488) 	push	x
                                   (0489)     M8C_SetBank0                    ; Force bank 0
07AD: 54 FD    MOV   [X-3],A       (0490)     mov     a, 0                    ; Specify bank 0
07AF: 18       POP   A             (0491)     asr     a                       ; Store in carry flag
07B0: 20       POP   X             (0492)                                     ; Bank 0 table address:
07B1: 75       INC   X             (0493)     mov     A, >UnloadConfigTBL_Total_Bank0
07B2: 09 00    ADC   A,0           (0494)     mov     X, <UnloadConfigTBL_Total_Bank0
07B4: 10       PUSH  X             (0495)     lcall   LoadConfig              ; Unload the bank 0 values
07B5: 08       PUSH  A             (0496) 
07B6: 28       ROMX                (0497)     mov     a, 1                    ; Specify bank 1
07B7: 4F       MOV   X,SP          (0498)     asr     a                       ; Store in carry flag
07B8: 59 FD    MOV   X,[X-3]       (0499)                                     ; Bank 1 table address:
07BA: 61 00    MOV   REG[X+0],A    (0500)     mov     A, >UnloadConfigTBL_Total_Bank1
07BC: 18       POP   A             (0501)     mov     X, <UnloadConfigTBL_Total_Bank1
07BD: 20       POP   X             (0502)     lcall   LoadConfig              ; Unload the bank 1 values
07BE: 75       INC   X             (0503) 
07BF: 09 00    ADC   A,0           (0504) 	M8C_SetBank1
07C1: 8F D7    JMP   0x0799        (0505) 	M8C_SetBank0
                                   (0506) ; clear config active bit
07C3: 38 FC    ADD   SP,252        (0507) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
07C5: 70 3F    AND   F,63
07C7: 71 C0    OR    F,192         (0508) 	mov		[ACTIVE_CONFIG_STATUS+0], 0
07CA: 43 E1 02 OR    REG[225],2    (0509)     M8C_SetBank0                    ; Force return to bank 0

FILE: lib\tx_timeout.asm
                                   (0102) ;;*****************************************************************************
07CD: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
07CE: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
07D1: 7F       RET                 (0131) export  TX_TIMEOUT_EnableInt
                                   (0132) export _TX_TIMEOUT_EnableInt
                                   (0133) export  TX_TIMEOUT_DisableInt
                                   (0134) export _TX_TIMEOUT_DisableInt
                                   (0135) export  TX_TIMEOUT_Start
                                   (0136) export _TX_TIMEOUT_Start
                                   (0137) export  TX_TIMEOUT_Stop
                                   (0138) export _TX_TIMEOUT_Stop
                                   (0139) export  TX_TIMEOUT_WritePeriod
                                   (0140) export _TX_TIMEOUT_WritePeriod
                                   (0141) export  TX_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_TIMEOUT_wReadTimer
                                   (0146) export _TX_TIMEOUT_wReadTimer
                                   (0147) export  TX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
07D2: 43 23 01 OR    REG[35],1     (0157) export _wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
07D5: 7F       RET                 (0159) export  wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA pc_listener_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
07D6: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
07D9: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_TIMEOUT_EnableInt:
                                   (0200) _TX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
07DA: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
07DC: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
07DD: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
07DF: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_TIMEOUT_DisableInt:
                                   (0228) _TX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
07E0: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
07E2: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
07E3: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
07E5: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_TIMEOUT_Start:
                                   (0256) _TX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
07E6: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
07E8: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
07E9: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
07EB: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_TIMEOUT_Stop:
                                   (0284) _TX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_TIMEOUT_WritePeriod:
                                   (0313) _TX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_TIMEOUT_Stop to disable).
07EC: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
07ED: 38 03    ADD   SP,3          (0334) ;
07EF: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
07F1: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
07F2: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
07F4: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
07F5: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
07F7: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
07F8: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
07FA: 5D 26    MOV   A,REG[38]     (0343) ;
07FC: 54 01    MOV   [X+1],A       (0344)  TX_TIMEOUT_WriteCompareValue:
07FE: 5D 22    MOV   A,REG[34]     (0345) _TX_TIMEOUT_WriteCompareValue:
0800: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0802: 50 00    MOV   A,0           (0347)    mov   reg[TX_TIMEOUT_COMPARE_LSB_REG], A
0804: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0807: A0 03    JZ    0x080B        (0349)    mov   reg[TX_TIMEOUT_COMPARE_MSB_REG], A
0809: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
080B: 54 00    MOV   [X+0],A       (0352) 
080D: 70 FE    AND   F,254         (0353) .ENDSECTION
080F: 41 23 FE AND   REG[35],254   (0354) 
0812: 18       POP   A             (0355) 
0813: 60 26    MOV   REG[38],A     (0356) .SECTION
0815: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0816: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_TIMEOUT_wReadCompareValue
0818: 18       POP   A             (0359) ;
0819: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
081B: 18       POP   A             (0361) ;     Reads the Compare registers.
081C: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
081D: 70 3F    AND   F,63
081F: 71 C0    OR    F,192         (0363) ;
0821: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0822: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0824: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0826: 5C       MOV   X,A           (0409) ;
0827: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
082B: 43 E1 08 OR    REG[225],8    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\tx_repeater_23.asm
                                   (0109) ;;*****************************************************************************
082E: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_REPEATER_23.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_REPEATER_23.inc"
082F: 41 E1 F7 AND   REG[225],247  (0137) 
                                   (0138) area UserModules (ROM, REL)
0832: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_REPEATER_23_SetTxIntMode
                                   (0143) export  _TX_REPEATER_23_SetTxIntMode
                                   (0144) export   TX_REPEATER_23_EnableInt
                                   (0145) export  _TX_REPEATER_23_EnableInt
                                   (0146) export   TX_REPEATER_23_DisableInt
                                   (0147) export  _TX_REPEATER_23_DisableInt
                                   (0148) export   TX_REPEATER_23_Start
                                   (0149) export  _TX_REPEATER_23_Start
                                   (0150) export   TX_REPEATER_23_Stop
                                   (0151) export  _TX_REPEATER_23_Stop
                                   (0152) export   TX_REPEATER_23_SendData
                                   (0153) export  _TX_REPEATER_23_SendData
                                   (0154) export   TX_REPEATER_23_bReadTxStatus
                                   (0155) export  _TX_REPEATER_23_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_REPEATER_23_ReadTxStatus
                                   (0160) export  _bTX_REPEATER_23_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_REPEATER_23_PutSHexByte
                                   (0166) export _TX_REPEATER_23_PutSHexByte
                                   (0167) export  TX_REPEATER_23_PutSHexInt
                                   (0168) export _TX_REPEATER_23_PutSHexInt
                                   (0169) 
0833: 71 10    OR    F,16          (0170) export  TX_REPEATER_23_CPutString
0835: 21 01    AND   A,1           (0171) export _TX_REPEATER_23_CPutString
0837: A0 07    JZ    0x083F        (0172) export  TX_REPEATER_23_PutString
0839: 43 2C 10 OR    REG[44],16    (0173) export _TX_REPEATER_23_PutString
083C: 70 EF    AND   F,239         (0174) export  TX_REPEATER_23_PutChar
                                   (0175) export _TX_REPEATER_23_PutChar
083E: 7F       RET                 (0176) export  TX_REPEATER_23_Write
                                   (0177) export _TX_REPEATER_23_Write
                                   (0178) export  TX_REPEATER_23_CWrite
083F: 41 2C EF AND   REG[44],239   (0179) export _TX_REPEATER_23_CWrite
0842: 70 EF    AND   F,239         (0180) export  TX_REPEATER_23_PutCRLF
                                   (0181) export _TX_REPEATER_23_PutCRLF 
0844: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_REPEATER_23_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0845: 29 01    OR    A,1           (0211) ;    functions.
0847: 60 2F    MOV   REG[47],A     (0212) ;
                                   (0213)  TX_REPEATER_23_EnableInt:
0849: 7F       RET                 (0214) _TX_REPEATER_23_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_REPEATER_23_INT_REG, TX_REPEATER_23_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_REPEATER_23_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
084A: 41 2F FE AND   REG[47],254   (0240) ;    functions.
                                   (0241) ;
084D: 7F       RET                 (0242)  TX_REPEATER_23_DisableInt:
                                   (0243) _TX_REPEATER_23_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_REPEATER_23_INT_REG, TX_REPEATER_23_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_REPEATER_23_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
084E: 60 2D    MOV   REG[45],A     (0269) ;    functions.
                                   (0270) ;
0850: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_REPEATER_23_SetTxIntMode:
                                   (0276) _TX_REPEATER_23_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_REPEATER_23_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_REPEATER_23_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_REPEATER_23_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_REPEATER_23_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0851: 5D 2F    MOV   A,REG[47]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0853: 7F       RET                 (0303) ;
0854: 30       HALT  
0855: 31 32    XOR   A,50
0857: 33 34    XOR   A,[X+52]
0859: 35 36    XOR   [X+54],A
085B: 37 38 39 XOR   [X+56],57
085E: 41 42 43 AND   REG[66],67
0861: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_REPEATER_23_Start:
                                   (0317) _TX_REPEATER_23_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_REPEATER_23_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_REPEATER_23_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0864: 08       PUSH  A             (0335) ;
0865: 67       ASR   A             (0336) ;  RETURNS:  none
0866: 67       ASR   A             (0337) ;
0867: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0868: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0869: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
086B: FF E7    INDEX 0x0854        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
086D: 90 0F    CALL  0x087E        (0342) ;    responsibility to perserve their values across calls to fastcall16 
086F: 18       POP   A             (0343) ;    functions.
0870: 21 0F    AND   A,15          (0344) ;
0872: FF E0    INDEX 0x0854        (0345)  TX_REPEATER_23_Stop:
0874: 90 08    CALL  0x087E        (0346) _TX_REPEATER_23_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0876: 7F       RET                 (0348)    and   REG[TX_REPEATER_23_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_REPEATER_23_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_REPEATER_23_SendData:
                                   (0375) _TX_REPEATER_23_SendData:
0877: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0878: 9F EA    CALL  0x0864        (0377)    mov REG[TX_REPEATER_23_TX_BUFFER_REG], A
087A: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
087B: 9F E7    CALL  0x0864        (0379)    ret
                                   (0380) .ENDSECTION
087D: 7F       RET                 (0381) 
087E: 49 2F 10 TST   REG[47],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_REPEATER_23_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_REPEATER_23_bReadTxStatus:
                                   (0405) _TX_REPEATER_23_bReadTxStatus:
                                   (0406)  bTX_REPEATER_23_ReadTxStatus:
                                   (0407) _bTX_REPEATER_23_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_REPEATER_23_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0881: AF FC    JZ    0x087E        (0416) ;  FUNCTION NAME: TX_REPEATER_23_PutSHexByte
0883: 60 2D    MOV   REG[45],A
                                   (0417) ;
0885: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_REPEATER_23_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_REPEATER_23_PutSHexByte:
                                   (0441) _TX_REPEATER_23_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_REPEATER_23_HEX_STR       ; Get Hex value
                                   (0450)     call  TX_REPEATER_23_PutChar       ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_REPEATER_23_HEX_STR       ; Get Hex value
                                   (0454)     call  TX_REPEATER_23_PutChar       ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0886: 70 BF    AND   F,191         (0456)     ret
0888: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
088A: 52 00    MOV   A,[X+0]       (0459) .SECTION
088C: A0 06    JZ    0x0893        (0460) ;-----------------------------------------------------------------------------
088E: 9F EE    CALL  0x087E        (0461) ;  FUNCTION NAME: TX_REPEATER_23_PutSHexInt
0890: 75       INC   X             (0462) ;
0891: 8F F8    JMP   0x088A        (0463) ;  DESCRIPTION:
0893: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0895: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0897: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_REPEATER_23_PutSHexInt:
                                   (0482) _TX_REPEATER_23_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_REPEATER_23_PutSHexByte   ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_REPEATER_23_PutSHexByte   ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_REPEATER_23_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0898: 70 BF    AND   F,191         (0503) ;  RETURNS:
089A: 62 D3 03 MOV   REG[211],3    (0504) ;     none
089D: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
089E: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
08A0: A0 1A    JZ    0x08BB        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
08A2: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
08A4: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_REPEATER_23_CONTROL_REG], TX_REPEATER_23_TX_BUFFER_EMPTY    ; Check Tx Status
08A6: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
08A8: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_REPEATER_23_TX_BUFFER_REG], @Source    ; Write data to Tx Port
08AA: 52 00    MOV   A,[X+0]       (0518)    endm
08AC: 49 2F 10 TST   REG[47],16
08AF: AF FC    JZ    0x08AC        (0519) 
08B1: 60 2D    MOV   REG[45],A
08B3: 4F       MOV   X,SP          (0520) 
08B4: 62 D3 03 MOV   REG[211],3    (0521)  TX_REPEATER_23_PutChar:
08B7: 77 FD    INC   [X-3]         (0522) _TX_REPEATER_23_PutChar:
08B9: 8F E4    JMP   0x089E        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
08BB: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
08BD: 71 C0    OR    F,192         (0526)    ret
08BF: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_REPEATER_23_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_REPEATER_23_PutString:
                                   (0563) _TX_REPEATER_23_PutString:
08C0: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
08C1: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
08C4: B0 06    JNZ   0x08CB        (0569)    call  TX_REPEATER_23_PutChar             ; Send character to Tx port
08C6: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
08C9: A0 1D    JZ    0x08E7        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
08CB: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
08CC: 52 FC    MOV   A,[X-4]       (0575)    ret
08CE: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
08D0: 28       ROMX                (0577) 
08D1: 49 2F 10 TST   REG[47],16
08D4: AF FC    JZ    0x08D1        (0578) .SECTION
08D6: 60 2D    MOV   REG[45],A
08D8: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_REPEATER_23_Write
08D9: 07 FD 01 ADD   [X-3],1       (0581) ;
08DC: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
08DF: 17 FB 01 SUB   [X-5],1       (0585) ;
08E2: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
08E5: 8F DB    JMP   0x08C1        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
08E7: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_REPEATER_23_Write:
                                   (0610) _TX_REPEATER_23_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
08E8: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
08E9: 10       PUSH  X             (0622)    ENDIF
08EA: 28       ROMX                (0623) 
08EB: A0 0B    JZ    0x08F7        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
08ED: 9F 8F    CALL  0x087E        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
08EF: 20       POP   X             (0626)    mov   A,[X]
08F0: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
08F1: 75       INC   X             (0628)    mov   X, SP
08F2: DF F5    JNC   0x08E8        (0629)    RAM_SETPAGE_IDX2STK
08F4: 74       INC   A             (0630)    inc   [X+STR_LSB]
08F5: 8F F2    JMP   0x08E8        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
08F7: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
08F9: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_REPEATER_23_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
08FA: 50 0D    MOV   A,13          (0663) ;
08FC: 9F 80    CALL  0x087E        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
08FE: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0900: 9F 7C    CALL  0x087E        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0904: 43 E1 04 OR    REG[225],4    (0668) 

FILE: lib\tx_repeater_14.asm
                                   (0109) ;;*****************************************************************************
0907: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_REPEATER_14.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_REPEATER_14.inc"
0908: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
090B: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_REPEATER_14_SetTxIntMode
                                   (0143) export  _TX_REPEATER_14_SetTxIntMode
                                   (0144) export   TX_REPEATER_14_EnableInt
                                   (0145) export  _TX_REPEATER_14_EnableInt
                                   (0146) export   TX_REPEATER_14_DisableInt
                                   (0147) export  _TX_REPEATER_14_DisableInt
                                   (0148) export   TX_REPEATER_14_Start
                                   (0149) export  _TX_REPEATER_14_Start
                                   (0150) export   TX_REPEATER_14_Stop
                                   (0151) export  _TX_REPEATER_14_Stop
                                   (0152) export   TX_REPEATER_14_SendData
                                   (0153) export  _TX_REPEATER_14_SendData
                                   (0154) export   TX_REPEATER_14_bReadTxStatus
                                   (0155) export  _TX_REPEATER_14_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_REPEATER_14_ReadTxStatus
                                   (0160) export  _bTX_REPEATER_14_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_REPEATER_14_PutSHexByte
                                   (0166) export _TX_REPEATER_14_PutSHexByte
                                   (0167) export  TX_REPEATER_14_PutSHexInt
                                   (0168) export _TX_REPEATER_14_PutSHexInt
                                   (0169) 
090C: 71 10    OR    F,16          (0170) export  TX_REPEATER_14_CPutString
090E: 21 01    AND   A,1           (0171) export _TX_REPEATER_14_CPutString
0910: A0 07    JZ    0x0918        (0172) export  TX_REPEATER_14_PutString
0912: 43 28 10 OR    REG[40],16    (0173) export _TX_REPEATER_14_PutString
0915: 70 EF    AND   F,239         (0174) export  TX_REPEATER_14_PutChar
                                   (0175) export _TX_REPEATER_14_PutChar
0917: 7F       RET                 (0176) export  TX_REPEATER_14_Write
                                   (0177) export _TX_REPEATER_14_Write
                                   (0178) export  TX_REPEATER_14_CWrite
0918: 41 28 EF AND   REG[40],239   (0179) export _TX_REPEATER_14_CWrite
091B: 70 EF    AND   F,239         (0180) export  TX_REPEATER_14_PutCRLF
                                   (0181) export _TX_REPEATER_14_PutCRLF 
091D: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_REPEATER_14_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
091E: 29 01    OR    A,1           (0211) ;    functions.
0920: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_REPEATER_14_EnableInt:
0922: 7F       RET                 (0214) _TX_REPEATER_14_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_REPEATER_14_INT_REG, TX_REPEATER_14_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_REPEATER_14_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0923: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0926: 7F       RET                 (0242)  TX_REPEATER_14_DisableInt:
                                   (0243) _TX_REPEATER_14_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_REPEATER_14_INT_REG, TX_REPEATER_14_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_REPEATER_14_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0927: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0929: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_REPEATER_14_SetTxIntMode:
                                   (0276) _TX_REPEATER_14_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_REPEATER_14_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_REPEATER_14_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_REPEATER_14_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_REPEATER_14_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
092A: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
092C: 7F       RET                 (0303) ;
092D: 30       HALT  
092E: 31 32    XOR   A,50
0930: 33 34    XOR   A,[X+52]
0932: 35 36    XOR   [X+54],A
0934: 37 38 39 XOR   [X+56],57
0937: 41 42 43 AND   REG[66],67
093A: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_REPEATER_14_Start:
                                   (0317) _TX_REPEATER_14_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_REPEATER_14_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_REPEATER_14_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
093D: 08       PUSH  A             (0335) ;
093E: 67       ASR   A             (0336) ;  RETURNS:  none
093F: 67       ASR   A             (0337) ;
0940: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0941: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0942: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0944: FF E7    INDEX 0x092D        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0946: 90 0F    CALL  0x0957        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0948: 18       POP   A             (0343) ;    functions.
0949: 21 0F    AND   A,15          (0344) ;
094B: FF E0    INDEX 0x092D        (0345)  TX_REPEATER_14_Stop:
094D: 90 08    CALL  0x0957        (0346) _TX_REPEATER_14_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
094F: 7F       RET                 (0348)    and   REG[TX_REPEATER_14_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_REPEATER_14_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_REPEATER_14_SendData:
                                   (0375) _TX_REPEATER_14_SendData:
0950: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0951: 9F EA    CALL  0x093D        (0377)    mov REG[TX_REPEATER_14_TX_BUFFER_REG], A
0953: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0954: 9F E7    CALL  0x093D        (0379)    ret
                                   (0380) .ENDSECTION
0956: 7F       RET                 (0381) 
0957: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_REPEATER_14_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_REPEATER_14_bReadTxStatus:
                                   (0405) _TX_REPEATER_14_bReadTxStatus:
                                   (0406)  bTX_REPEATER_14_ReadTxStatus:
                                   (0407) _bTX_REPEATER_14_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_REPEATER_14_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
095A: AF FC    JZ    0x0957        (0416) ;  FUNCTION NAME: TX_REPEATER_14_PutSHexByte
095C: 60 29    MOV   REG[41],A
                                   (0417) ;
095E: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_REPEATER_14_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_REPEATER_14_PutSHexByte:
                                   (0441) _TX_REPEATER_14_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_REPEATER_14_HEX_STR       ; Get Hex value
                                   (0450)     call  TX_REPEATER_14_PutChar       ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_REPEATER_14_HEX_STR       ; Get Hex value
                                   (0454)     call  TX_REPEATER_14_PutChar       ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
095F: 70 BF    AND   F,191         (0456)     ret
0961: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0963: 52 00    MOV   A,[X+0]       (0459) .SECTION
0965: A0 06    JZ    0x096C        (0460) ;-----------------------------------------------------------------------------
0967: 9F EE    CALL  0x0957        (0461) ;  FUNCTION NAME: TX_REPEATER_14_PutSHexInt
0969: 75       INC   X             (0462) ;
096A: 8F F8    JMP   0x0963        (0463) ;  DESCRIPTION:
096C: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
096E: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0970: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_REPEATER_14_PutSHexInt:
                                   (0482) _TX_REPEATER_14_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_REPEATER_14_PutSHexByte   ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_REPEATER_14_PutSHexByte   ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_REPEATER_14_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0971: 70 BF    AND   F,191         (0503) ;  RETURNS:
0973: 62 D3 03 MOV   REG[211],3    (0504) ;     none
0976: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0977: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0979: A0 1A    JZ    0x0994        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
097B: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
097D: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_REPEATER_14_CONTROL_REG], TX_REPEATER_14_TX_BUFFER_EMPTY    ; Check Tx Status
097F: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0981: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_REPEATER_14_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0983: 52 00    MOV   A,[X+0]       (0518)    endm
0985: 49 2B 10 TST   REG[43],16
0988: AF FC    JZ    0x0985        (0519) 
098A: 60 29    MOV   REG[41],A
098C: 4F       MOV   X,SP          (0520) 
098D: 62 D3 03 MOV   REG[211],3    (0521)  TX_REPEATER_14_PutChar:
0990: 77 FD    INC   [X-3]         (0522) _TX_REPEATER_14_PutChar:
0992: 8F E4    JMP   0x0977        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0994: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0996: 71 C0    OR    F,192         (0526)    ret
0998: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_REPEATER_14_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_REPEATER_14_PutString:
                                   (0563) _TX_REPEATER_14_PutString:
0999: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
099A: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
099D: B0 06    JNZ   0x09A4        (0569)    call  TX_REPEATER_14_PutChar             ; Send character to Tx port
099F: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
09A2: A0 1D    JZ    0x09C0        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
09A4: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
09A5: 52 FC    MOV   A,[X-4]       (0575)    ret
09A7: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
09A9: 28       ROMX                (0577) 
09AA: 49 2B 10 TST   REG[43],16
09AD: AF FC    JZ    0x09AA        (0578) .SECTION
09AF: 60 29    MOV   REG[41],A
09B1: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_REPEATER_14_Write
09B2: 07 FD 01 ADD   [X-3],1       (0581) ;
09B5: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
09B8: 17 FB 01 SUB   [X-5],1       (0585) ;
09BB: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
09BE: 8F DB    JMP   0x099A        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
09C0: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_REPEATER_14_Write:
                                   (0610) _TX_REPEATER_14_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
09C1: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
09C2: 10       PUSH  X             (0622)    ENDIF
09C3: 28       ROMX                (0623) 
09C4: A0 0B    JZ    0x09D0        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
09C6: 9F 8F    CALL  0x0957        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
09C8: 20       POP   X             (0626)    mov   A,[X]
09C9: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
09CA: 75       INC   X             (0628)    mov   X, SP
09CB: DF F5    JNC   0x09C1        (0629)    RAM_SETPAGE_IDX2STK
09CD: 74       INC   A             (0630)    inc   [X+STR_LSB]
09CE: 8F F2    JMP   0x09C1        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
09D0: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
09D2: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_REPEATER_14_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
09D3: 50 0D    MOV   A,13          (0663) ;
09D5: 9F 80    CALL  0x0957        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
09D7: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
09D9: 9F 7C    CALL  0x0957        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
09DC: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\rx_timeout.asm
                                   (0102) ;;*****************************************************************************
09DF: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: RX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "RX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
09E0: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
09E3: 7F       RET                 (0131) export  RX_TIMEOUT_EnableInt
                                   (0132) export _RX_TIMEOUT_EnableInt
                                   (0133) export  RX_TIMEOUT_DisableInt
                                   (0134) export _RX_TIMEOUT_DisableInt
                                   (0135) export  RX_TIMEOUT_Start
                                   (0136) export _RX_TIMEOUT_Start
                                   (0137) export  RX_TIMEOUT_Stop
                                   (0138) export _RX_TIMEOUT_Stop
                                   (0139) export  RX_TIMEOUT_WritePeriod
                                   (0140) export _RX_TIMEOUT_WritePeriod
                                   (0141) export  RX_TIMEOUT_WriteCompareValue
                                   (0142) export _RX_TIMEOUT_WriteCompareValue
                                   (0143) export  RX_TIMEOUT_wReadCompareValue
                                   (0144) export _RX_TIMEOUT_wReadCompareValue
                                   (0145) export  RX_TIMEOUT_wReadTimer
                                   (0146) export _RX_TIMEOUT_wReadTimer
                                   (0147) export  RX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _RX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
09E4: 43 23 01 OR    REG[35],1     (0157) export _wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
09E7: 7F       RET                 (0159) export  wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA receiver_config_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: RX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
09E8: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
09EB: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  RX_TIMEOUT_EnableInt:
                                   (0200) _RX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    RX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: RX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
09EC: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
09EE: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
09EF: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
09F1: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  RX_TIMEOUT_DisableInt:
                                   (0228) _RX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    RX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: RX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
09F2: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
09F4: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
09F5: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
09F7: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  RX_TIMEOUT_Start:
                                   (0256) _RX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    RX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: RX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
09F8: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
09FA: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
09FB: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
09FD: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  RX_TIMEOUT_Stop:
                                   (0284) _RX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    RX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: RX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  RX_TIMEOUT_WritePeriod:
                                   (0313) _RX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[RX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[RX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: RX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call RX_TIMEOUT_Stop to disable).
09FE: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
09FF: 38 03    ADD   SP,3          (0334) ;
0A01: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0A03: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0A04: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0A06: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0A07: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0A09: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0A0A: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0A0C: 5D 26    MOV   A,REG[38]     (0343) ;
0A0E: 54 01    MOV   [X+1],A       (0344)  RX_TIMEOUT_WriteCompareValue:
0A10: 5D 22    MOV   A,REG[34]     (0345) _RX_TIMEOUT_WriteCompareValue:
0A12: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0A14: 50 00    MOV   A,0           (0347)    mov   reg[RX_TIMEOUT_COMPARE_LSB_REG], A
0A16: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0A19: A0 03    JZ    0x0A1D        (0349)    mov   reg[RX_TIMEOUT_COMPARE_MSB_REG], A
0A1B: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0A1D: 54 00    MOV   [X+0],A       (0352) 
0A1F: 70 FE    AND   F,254         (0353) .ENDSECTION
0A21: 41 23 FE AND   REG[35],254   (0354) 
0A24: 18       POP   A             (0355) 
0A25: 60 26    MOV   REG[38],A     (0356) .SECTION
0A27: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0A28: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: RX_TIMEOUT_wReadCompareValue
0A2A: 18       POP   A             (0359) ;
0A2B: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0A2D: 18       POP   A             (0361) ;     Reads the Compare registers.
0A2E: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0A2F: 70 3F    AND   F,63
0A31: 71 C0    OR    F,192         (0363) ;
0A33: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  RX_TIMEOUT_wReadCompareValue:
                                   (0374) _RX_TIMEOUT_wReadCompareValue:
                                   (0375)  wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[RX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[RX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: RX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0A34: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0A36: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0A38: 5C       MOV   X,A           (0409) ;
0A39: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0A3C: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\receive_4int.asm
0A3D: 10       PUSH  X             (0104) ;;*****************************************************************************
0A3E: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_4INT.asm
0A40: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0A41: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0A43: 5D 3F    MOV   A,REG[63]     (0111) ;;-----------------------------------------------------------------------------
0A45: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0A46: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0A48: B0 04    JNZ   0x0A4D        (0115) 
0A4A: 18       POP   A             (0116) include "m8c.inc"
0A4B: 80 5E    JMP   0x0AAA        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_4.inc"
                                   (0119) 
                                   (0120) 
0A4D: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0A4E: 21 E0    AND   A,224         (0124) export  _RECEIVE_4_ISR
0A50: A0 12    JZ    0x0A63        (0125) 
                                   (0126) 
0A52: 2C 00    OR    [0],A         (0127) IF (RECEIVE_4_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_4_aRxBuffer
0A54: 49 3E 00 TST   REG[62],0     (0129) export _RECEIVE_4_aRxBuffer
                                   (0130) export  RECEIVE_4_bRxCnt
0A57: 21 20    AND   A,32          (0131) export _RECEIVE_4_bRxCnt
0A59: A0 50    JZ    0x0AAA        (0132) export  RECEIVE_4_fStatus
                                   (0133) export _RECEIVE_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
0A5B: 41 3F FE AND   REG[63],254   (0136) 
0A5E: 43 3F 01 OR    REG[63],1     (0137) ;-----------------------------------------------
0A61: 80 48    JMP   0x0AAA        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_4_RXBUF_ENABLE)
0A63: 5D 3E    MOV   A,REG[62]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_4_fStatus:
                                   (0144) _RECEIVE_4_fStatus:      BLK  1
0A65: 47 00 01 TST   [0],1         (0145)  RECEIVE_4_bRxCnt:
0A68: B0 41    JNZ   0x0AAA        (0146) _RECEIVE_4_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_4_RAM(RAM,REL,CON)
0A6A: 39 00    CMP   A,0           (0148)  RECEIVE_4_aRxBuffer:    
0A6C: B0 14    JNZ   0x0A81        (0149) _RECEIVE_4_aRxBuffer:    BLK RECEIVE_4_RX_BUFFER_SIZE
0A6E: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0A71: 62 D3 00 MOV   REG[211],0    (0152) 
0A74: 70 3F    AND   F,63
0A76: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0A78: 56 7B 00 MOV   [X+123],0     (0154) 
0A7B: 70 3F    AND   F,63
0A7D: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0A7F: 80 2A    JMP   0x0AAA        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0A81: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0A84: C0 14    JC    0x0A99        (0168) 
0A86: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0A89: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0A8C: 70 3F    AND   F,63
0A8E: 71 80    OR    F,128         (0172) ;------------------------
0A90: 56 7B 00 MOV   [X+123],0     (0173) 
0A93: 70 3F    AND   F,63
0A95: 71 00    OR    F,0           (0174) 
0A97: 80 12    JMP   0x0AAA        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0A99: 75       INC   X             (0179) 
0A9A: 5A 01    MOV   [1],X         (0180) 
0A9C: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0A9D: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0AA0: 70 3F    AND   F,63
0AA2: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_4_ISR
0AA4: 54 7B    MOV   [X+123],A     (0185) ;
0AA6: 70 3F    AND   F,63
0AA8: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0AAA: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0AAB: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0AAD: 20       POP   X             (0195)    ; Insert your custom code below this banner
0AAE: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0AB0: 43 E1 80 OR    REG[225],128  (0201)    ; Insert your custom code above this banner

FILE: lib\receive_4.asm
                                   (0121) ;;*****************************************************************************
0AB3: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_4.inc"
0AB4: 41 E1 7F AND   REG[225],127  (0149) 
                                   (0150) 
0AB7: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_4_EnableInt
                                   (0155) export  _RECEIVE_4_EnableInt
                                   (0156) export   RECEIVE_4_DisableInt
                                   (0157) export  _RECEIVE_4_DisableInt
                                   (0158) export   RECEIVE_4_Start
                                   (0159) export  _RECEIVE_4_Start
                                   (0160) export   RECEIVE_4_Stop
                                   (0161) export  _RECEIVE_4_Stop
                                   (0162) export   RECEIVE_4_bReadRxData
                                   (0163) export  _RECEIVE_4_bReadRxData
                                   (0164) export   RECEIVE_4_bReadRxStatus
                                   (0165) export  _RECEIVE_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_4_ReadRxData
                                   (0170) export _bRECEIVE_4_ReadRxData
                                   (0171) export  bRECEIVE_4_ReadRxStatus
                                   (0172) export _bRECEIVE_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_4_cGetChar
0AB8: 29 01    OR    A,1           (0179) export _RECEIVE_4_cGetChar
0ABA: 60 3F    MOV   REG[63],A     (0180) export  RECEIVE_4_cReadChar
                                   (0181) export _RECEIVE_4_cReadChar
0ABC: 7F       RET                 (0182) export  RECEIVE_4_iReadChar
                                   (0183) export _RECEIVE_4_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_4_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_4_CmdReset
                                   (0187) export _RECEIVE_4_CmdReset
                                   (0188) export  RECEIVE_4_bCmdCheck
                                   (0189) export _RECEIVE_4_bCmdCheck
                                   (0190) export  RECEIVE_4_bCmdLength
                                   (0191) export _RECEIVE_4_bCmdLength
                                   (0192) export  RECEIVE_4_bErrCheck
                                   (0193) export _RECEIVE_4_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_4_szGetParam
                                   (0196) export _RECEIVE_4_szGetParam
                                   (0197) export  RECEIVE_4_szGetRestOfParams
                                   (0198) export _RECEIVE_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0ABD: 41 3F FE AND   REG[63],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0AC0: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_4_EnableInt:
                                   (0238) _RECEIVE_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0AC1: 5D 3E    MOV   A,REG[62]     (0240)    M8C_EnableIntMask RECEIVE_4_INT_REG, RECEIVE_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0AC3: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_4_DisableInt:
                                   (0267) _RECEIVE_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_4_INT_REG, RECEIVE_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0AC4: 5D 3F    MOV   A,REG[63]     (0272) .ENDSECTION
                                   (0273) 
0AC6: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_4_Start:
                                   (0297) _RECEIVE_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0AC7: 49 3F 08 TST   REG[63],8     (0311) ;
0ACA: AF FC    JZ    0x0AC7        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0ACC: 5D 3E    MOV   A,REG[62]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0ACE: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_4_Stop:
                                   (0326) _RECEIVE_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0ACF: 5D 3F    MOV   A,REG[63]     (0346) ;    bRxData - returned in A.
0AD1: 08       PUSH  A             (0347) ;
0AD2: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0AD4: B0 04    JNZ   0x0AD9        (0349) ;    The A and X registers may be modified by this or future implementations
0AD6: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0AD7: 80 0B    JMP   0x0AE3        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0AD9: 5D 3E    MOV   A,REG[62]     (0354) ;
0ADB: 4B       SWAP  A,X           (0355)  RECEIVE_4_bReadRxData:
                                   (0356) _RECEIVE_4_bReadRxData:
0ADC: 18       POP   A             (0357)  bRECEIVE_4_ReadRxData:
0ADD: 21 A0    AND   A,160         (0358) _bRECEIVE_4_ReadRxData:
0ADF: B0 03    JNZ   0x0AE3        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0AE1: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0AE2: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0AE3: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_4_bReadRxStatus
                                   (0368) ;
0AE5: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_4_bReadRxStatus:
                                   (0388) _RECEIVE_4_bReadRxStatus:
                                   (0389)  bRECEIVE_4_ReadRxStatus:
                                   (0390) _bRECEIVE_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0AE6: 5D 3F    MOV   A,REG[63]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0AE8: 21 E8    AND   A,232         (0408) ;
0AEA: 08       PUSH  A             (0409) ;  ARGUMENTS:
0AEB: 21 08    AND   A,8           (0410) ;      none
0AED: B0 07    JNZ   0x0AF5        (0411) ;
0AEF: 18       POP   A             (0412) ;  RETURNS:
0AF0: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0AF2: 4B       SWAP  A,X           (0414) ;
0AF3: 80 07    JMP   0x0AFB        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0AF5: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0AF6: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0AF8: 4B       SWAP  A,X           (0420) ;    functions.
0AF9: 5D 3E    MOV   A,REG[62]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0AFB: 7F       RET                 (0426)  RECEIVE_4_cGetChar:
                                   (0427) _RECEIVE_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_4_CONTROL_REG],RECEIVE_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_4_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_4_cReadChar:
                                   (0463) _RECEIVE_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_4_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_4_RX_COMPLETE                            ; Check if a character is ready
0AFC: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0AFF: 55 7B 00 MOV   [123],0       (0470)    pop  A
0B02: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0B05: 55 A4 00 MOV   [NUM_MODULES+2],0(0472) 
0B08: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0B0B: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[RECEIVE_4_RX_BUFFER_REG]                     ; Read data first, then
0B0E: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0B11: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_4_RX_PARITY_ERROR | RECEIVE_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0B12: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0B15: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0B17: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0B19: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_4_iReadChar:
                                   (0523) _RECEIVE_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_4_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_4_RX_ERROR|RECEIVE_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_4_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_4_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_4_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_4_RXBUF_ENABLE)
                                   (0552) .SECTION
0B1A: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0B1D: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0B1F: 21 F0    AND   A,240         (0555) ;
0B21: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0B24: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_4_CmdReset:
0B25: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_4_CmdReset:
0B28: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_4_aRxBuffer
0B2A: 7F       RET                 (0590)    mov [RECEIVE_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_4_bRxCnt
                                   (0594)    mov [RECEIVE_4_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_4_bCmdCheck:
                                   (0628) _RECEIVE_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_4_fStatus
                                   (0631)    mov A,  [RECEIVE_4_fStatus]
                                   (0632)    and A, RECEIVE_4_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0B2B: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0B2D: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0B30: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0B33: 50 7B    MOV   A,123         (0648) ;     BYTE  fStatus - Status of command receive buffer.
0B35: 02 A4    ADD   A,[NUM_MODULES+2](0649) ;                     Returns non-zero value in A if command is valid.
0B37: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0B38: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0B3A: B0 04    JNZ   0x0B3F        (0653) ;           0x10 => Software Buffer OverRun
0B3C: 10       PUSH  X             (0654) ;
0B3D: 80 33    JMP   0x0B71        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0B3F: 39 00    CMP   A,0           (0660) ;    functions.
0B41: B0 11    JNZ   0x0B53        (0661) ;          
0B43: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0B44: 76 A4    INC   [NUM_MODULES+2](0663) ;          CUR_PP
0B46: 52 00    MOV   A,[X+0]       (0664) ;
0B48: 3C A4 0F CMP   [NUM_MODULES+2],15(0665) ;     Error Status is clear when read.
0B4B: BF F3    JNZ   0x0B3F        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0B4D: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_4_bErrCheck:
0B4E: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_4_bErrCheck:
0B51: 80 1F    JMP   0x0B71        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_4_fStatus
                                   (0674)    mov A,  [RECEIVE_4_fStatus]
0B53: 10       PUSH  X             (0675)    and A, RECEIVE_4_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_4_fStatus], ~RECEIVE_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0B54: 75       INC   X             (0679) .ENDSECTION
0B55: 76 A4    INC   [NUM_MODULES+2](0680) 
0B57: 3C A4 0F CMP   [NUM_MODULES+2],15(0681) .SECTION
0B5A: AF F3    JZ    0x0B4E        (0682) ;-----------------------------------------------------------------------------
0B5C: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_4_bCmdLength
0B5E: A0 12    JZ    0x0B71        (0684) ;
0B60: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0B62: BF F1    JNZ   0x0B54        (0686) ;     Get length of command string
                                   (0687) ;
0B64: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0B67: 76 A4    INC   [NUM_MODULES+2](0689) ;     none.
0B69: 3C A4 0F CMP   [NUM_MODULES+2],15(0690) ;
0B6C: B0 04    JNZ   0x0B71        (0691) ;  RETURNS:
0B6E: 55 A4 0F MOV   [NUM_MODULES+2],15(0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0B71: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0B72: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0B73: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0B76: B0 0B    JNZ   0x0B82        (0699) ;    functions.
0B78: 20       POP   X             (0700) ;          
0B79: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0B7B: 50 00    MOV   A,0           (0702) ;          CUR_PP
0B7D: 70 3F    AND   F,63
0B7F: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_4_bCmdLength:
0B81: 7F       RET                 (0705) _RECEIVE_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_4_bRxCnt
0B82: 20       POP   X             (0708)    mov A,  [RECEIVE_4_bRxCnt]
0B83: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0B85: 70 3F    AND   F,63
0B87: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0B89: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0B8A: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0B8D: 50 7B    MOV   A,123         (0744) ;     each lexically distinct element into a null-terminated string by replacing
0B8F: 02 A4    ADD   A,[NUM_MODULES+2](0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0B91: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0B92: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_4_szGetParam, is
0B95: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\receive_3int.asm
0B96: 10       PUSH  X             (0104) ;;*****************************************************************************
0B97: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_3INT.asm
0B99: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0B9A: 58 03    MOV   X,[3]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0B9C: 5D 3B    MOV   A,REG[59]     (0111) ;;-----------------------------------------------------------------------------
0B9E: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0B9F: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0BA1: B0 04    JNZ   0x0BA6        (0115) 
0BA3: 18       POP   A             (0116) include "m8c.inc"
0BA4: 80 5E    JMP   0x0C03        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_3.inc"
                                   (0119) 
                                   (0120) 
0BA6: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0BA7: 21 E0    AND   A,224         (0124) export  _RECEIVE_3_ISR
0BA9: A0 12    JZ    0x0BBC        (0125) 
                                   (0126) 
0BAB: 2C 02    OR    [2],A         (0127) IF (RECEIVE_3_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_3_aRxBuffer
0BAD: 49 3A 00 TST   REG[58],0     (0129) export _RECEIVE_3_aRxBuffer
                                   (0130) export  RECEIVE_3_bRxCnt
0BB0: 21 20    AND   A,32          (0131) export _RECEIVE_3_bRxCnt
0BB2: A0 50    JZ    0x0C03        (0132) export  RECEIVE_3_fStatus
                                   (0133) export _RECEIVE_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
0BB4: 41 3B FE AND   REG[59],254   (0136) 
0BB7: 43 3B 01 OR    REG[59],1     (0137) ;-----------------------------------------------
0BBA: 80 48    JMP   0x0C03        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_3_RXBUF_ENABLE)
0BBC: 5D 3A    MOV   A,REG[58]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_3_fStatus:
                                   (0144) _RECEIVE_3_fStatus:      BLK  1
0BBE: 47 02 01 TST   [2],1         (0145)  RECEIVE_3_bRxCnt:
0BC1: B0 41    JNZ   0x0C03        (0146) _RECEIVE_3_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_3_RAM(RAM,REL,CON)
0BC3: 39 00    CMP   A,0           (0148)  RECEIVE_3_aRxBuffer:    
0BC5: B0 14    JNZ   0x0BDA        (0149) _RECEIVE_3_aRxBuffer:    BLK RECEIVE_3_RX_BUFFER_SIZE
0BC7: 2E 02 01 OR    [2],1         (0150) ENDIF
                                   (0151) 
0BCA: 62 D3 00 MOV   REG[211],0    (0152) 
0BCD: 70 3F    AND   F,63
0BCF: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0BD1: 56 6B 00 MOV   [X+107],0     (0154) 
0BD4: 70 3F    AND   F,63
0BD6: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0BD8: 80 2A    JMP   0x0C03        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0BDA: 3C 03 0F CMP   [3],15        (0167) ;------------------------
0BDD: C0 14    JC    0x0BF2        (0168) 
0BDF: 2E 02 10 OR    [2],16        (0169) 
                                   (0170) ;------------------------
0BE2: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0BE5: 70 3F    AND   F,63
0BE7: 71 80    OR    F,128         (0172) ;------------------------
0BE9: 56 6B 00 MOV   [X+107],0     (0173) 
0BEC: 70 3F    AND   F,63
0BEE: 71 00    OR    F,0           (0174) 
0BF0: 80 12    JMP   0x0C03        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0BF2: 75       INC   X             (0179) 
0BF3: 5A 03    MOV   [3],X         (0180) 
0BF5: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0BF6: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0BF9: 70 3F    AND   F,63
0BFB: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_3_ISR
0BFD: 54 6B    MOV   [X+107],A     (0185) ;
0BFF: 70 3F    AND   F,63
0C01: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0C03: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0C04: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0C06: 20       POP   X             (0195)    ; Insert your custom code below this banner
0C07: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0C09: 43 E1 40 OR    REG[225],64   (0201)    ; Insert your custom code above this banner

FILE: lib\receive_3.asm
                                   (0121) ;;*****************************************************************************
0C0C: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_3.inc"
0C0D: 41 E1 BF AND   REG[225],191  (0149) 
                                   (0150) 
0C10: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_3_EnableInt
                                   (0155) export  _RECEIVE_3_EnableInt
                                   (0156) export   RECEIVE_3_DisableInt
                                   (0157) export  _RECEIVE_3_DisableInt
                                   (0158) export   RECEIVE_3_Start
                                   (0159) export  _RECEIVE_3_Start
                                   (0160) export   RECEIVE_3_Stop
                                   (0161) export  _RECEIVE_3_Stop
                                   (0162) export   RECEIVE_3_bReadRxData
                                   (0163) export  _RECEIVE_3_bReadRxData
                                   (0164) export   RECEIVE_3_bReadRxStatus
                                   (0165) export  _RECEIVE_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_3_ReadRxData
                                   (0170) export _bRECEIVE_3_ReadRxData
                                   (0171) export  bRECEIVE_3_ReadRxStatus
                                   (0172) export _bRECEIVE_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_3_cGetChar
0C11: 29 01    OR    A,1           (0179) export _RECEIVE_3_cGetChar
0C13: 60 3B    MOV   REG[59],A     (0180) export  RECEIVE_3_cReadChar
                                   (0181) export _RECEIVE_3_cReadChar
0C15: 7F       RET                 (0182) export  RECEIVE_3_iReadChar
                                   (0183) export _RECEIVE_3_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_3_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_3_CmdReset
                                   (0187) export _RECEIVE_3_CmdReset
                                   (0188) export  RECEIVE_3_bCmdCheck
                                   (0189) export _RECEIVE_3_bCmdCheck
                                   (0190) export  RECEIVE_3_bCmdLength
                                   (0191) export _RECEIVE_3_bCmdLength
                                   (0192) export  RECEIVE_3_bErrCheck
                                   (0193) export _RECEIVE_3_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_3_szGetParam
                                   (0196) export _RECEIVE_3_szGetParam
                                   (0197) export  RECEIVE_3_szGetRestOfParams
                                   (0198) export _RECEIVE_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0C16: 41 3B FE AND   REG[59],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0C19: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_3_EnableInt:
                                   (0238) _RECEIVE_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0C1A: 5D 3A    MOV   A,REG[58]     (0240)    M8C_EnableIntMask RECEIVE_3_INT_REG, RECEIVE_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0C1C: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_3_DisableInt:
                                   (0267) _RECEIVE_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_3_INT_REG, RECEIVE_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0C1D: 5D 3B    MOV   A,REG[59]     (0272) .ENDSECTION
                                   (0273) 
0C1F: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_3_Start:
                                   (0297) _RECEIVE_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0C20: 49 3B 08 TST   REG[59],8     (0311) ;
0C23: AF FC    JZ    0x0C20        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0C25: 5D 3A    MOV   A,REG[58]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0C27: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_3_Stop:
                                   (0326) _RECEIVE_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0C28: 5D 3B    MOV   A,REG[59]     (0346) ;    bRxData - returned in A.
0C2A: 08       PUSH  A             (0347) ;
0C2B: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0C2D: B0 04    JNZ   0x0C32        (0349) ;    The A and X registers may be modified by this or future implementations
0C2F: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0C30: 80 0B    JMP   0x0C3C        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0C32: 5D 3A    MOV   A,REG[58]     (0354) ;
0C34: 4B       SWAP  A,X           (0355)  RECEIVE_3_bReadRxData:
                                   (0356) _RECEIVE_3_bReadRxData:
0C35: 18       POP   A             (0357)  bRECEIVE_3_ReadRxData:
0C36: 21 A0    AND   A,160         (0358) _bRECEIVE_3_ReadRxData:
0C38: B0 03    JNZ   0x0C3C        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0C3A: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0C3B: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0C3C: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_3_bReadRxStatus
                                   (0368) ;
0C3E: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_3_bReadRxStatus:
                                   (0388) _RECEIVE_3_bReadRxStatus:
                                   (0389)  bRECEIVE_3_ReadRxStatus:
                                   (0390) _bRECEIVE_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0C3F: 5D 3B    MOV   A,REG[59]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0C41: 21 E8    AND   A,232         (0408) ;
0C43: 08       PUSH  A             (0409) ;  ARGUMENTS:
0C44: 21 08    AND   A,8           (0410) ;      none
0C46: B0 07    JNZ   0x0C4E        (0411) ;
0C48: 18       POP   A             (0412) ;  RETURNS:
0C49: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0C4B: 4B       SWAP  A,X           (0414) ;
0C4C: 80 07    JMP   0x0C54        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0C4E: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0C4F: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0C51: 4B       SWAP  A,X           (0420) ;    functions.
0C52: 5D 3A    MOV   A,REG[58]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0C54: 7F       RET                 (0426)  RECEIVE_3_cGetChar:
                                   (0427) _RECEIVE_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_3_CONTROL_REG],RECEIVE_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_3_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_3_cReadChar:
                                   (0463) _RECEIVE_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_3_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_3_RX_COMPLETE                            ; Check if a character is ready
0C55: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0C58: 55 6B 00 MOV   [107],0       (0470)    pop  A
0C5B: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0C5E: 55 A7 00 MOV   [167],0       (0472) 
0C61: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0C64: 55 03 00 MOV   [3],0         (0474)    mov  A,REG[RECEIVE_3_RX_BUFFER_REG]                     ; Read data first, then
0C67: 26 02 00 AND   [2],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0C6A: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_3_RX_PARITY_ERROR | RECEIVE_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0C6B: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0C6E: 51 02    MOV   A,[2]         (0511) ;        0x40CC    Overrun Error
0C70: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0C72: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_3_iReadChar:
                                   (0523) _RECEIVE_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_3_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_3_RX_ERROR|RECEIVE_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_3_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_3_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_3_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_3_RXBUF_ENABLE)
                                   (0552) .SECTION
0C73: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0C76: 51 02    MOV   A,[2]         (0554) ;-----------------------------------------------------------------------------
0C78: 21 F0    AND   A,240         (0555) ;
0C7A: 26 02 0F AND   [2],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0C7D: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_3_CmdReset:
0C7E: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_3_CmdReset:
0C81: 51 03    MOV   A,[3]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_3_aRxBuffer
0C83: 7F       RET                 (0590)    mov [RECEIVE_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_3_bRxCnt
                                   (0594)    mov [RECEIVE_3_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_3_bCmdCheck:
                                   (0628) _RECEIVE_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_3_fStatus
                                   (0631)    mov A,  [RECEIVE_3_fStatus]
                                   (0632)    and A, RECEIVE_3_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0C84: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0C86: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0C89: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0C8C: 50 6B    MOV   A,107         (0648) ;     BYTE  fStatus - Status of command receive buffer.
0C8E: 02 A7    ADD   A,[167]       (0649) ;                     Returns non-zero value in A if command is valid.
0C90: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0C91: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0C93: B0 04    JNZ   0x0C98        (0653) ;           0x10 => Software Buffer OverRun
0C95: 10       PUSH  X             (0654) ;
0C96: 80 33    JMP   0x0CCA        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0C98: 39 00    CMP   A,0           (0660) ;    functions.
0C9A: B0 11    JNZ   0x0CAC        (0661) ;          
0C9C: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0C9D: 76 A7    INC   [167]         (0663) ;          CUR_PP
0C9F: 52 00    MOV   A,[X+0]       (0664) ;
0CA1: 3C A7 0F CMP   [167],15      (0665) ;     Error Status is clear when read.
0CA4: BF F3    JNZ   0x0C98        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0CA6: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_3_bErrCheck:
0CA7: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_3_bErrCheck:
0CAA: 80 1F    JMP   0x0CCA        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_3_fStatus
                                   (0674)    mov A,  [RECEIVE_3_fStatus]
0CAC: 10       PUSH  X             (0675)    and A, RECEIVE_3_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_3_fStatus], ~RECEIVE_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0CAD: 75       INC   X             (0679) .ENDSECTION
0CAE: 76 A7    INC   [167]         (0680) 
0CB0: 3C A7 0F CMP   [167],15      (0681) .SECTION
0CB3: AF F3    JZ    0x0CA7        (0682) ;-----------------------------------------------------------------------------
0CB5: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_3_bCmdLength
0CB7: A0 12    JZ    0x0CCA        (0684) ;
0CB9: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0CBB: BF F1    JNZ   0x0CAD        (0686) ;     Get length of command string
                                   (0687) ;
0CBD: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0CC0: 76 A7    INC   [167]         (0689) ;     none.
0CC2: 3C A7 0F CMP   [167],15      (0690) ;
0CC5: B0 04    JNZ   0x0CCA        (0691) ;  RETURNS:
0CC7: 55 A7 0F MOV   [167],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0CCA: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0CCB: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0CCC: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0CCF: B0 0B    JNZ   0x0CDB        (0699) ;    functions.
0CD1: 20       POP   X             (0700) ;          
0CD2: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0CD4: 50 00    MOV   A,0           (0702) ;          CUR_PP
0CD6: 70 3F    AND   F,63
0CD8: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_3_bCmdLength:
0CDA: 7F       RET                 (0705) _RECEIVE_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_3_bRxCnt
0CDB: 20       POP   X             (0708)    mov A,  [RECEIVE_3_bRxCnt]
0CDC: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0CDE: 70 3F    AND   F,63
0CE0: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0CE2: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0CE3: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0CE6: 50 6B    MOV   A,107         (0744) ;     each lexically distinct element into a null-terminated string by replacing
0CE8: 02 A7    ADD   A,[167]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0CEA: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0CEB: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_3_szGetParam, is
0CEE: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\receive_2int.asm
0CEF: 10       PUSH  X             (0104) ;;*****************************************************************************
0CF0: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_2INT.asm
0CF2: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0CF3: 58 05    MOV   X,[5]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0CF5: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
0CF7: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0CF8: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0CFA: B0 04    JNZ   0x0CFF        (0115) 
0CFC: 18       POP   A             (0116) include "m8c.inc"
0CFD: 80 5E    JMP   0x0D5C        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_2.inc"
                                   (0119) 
                                   (0120) 
0CFF: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0D00: 21 E0    AND   A,224         (0124) export  _RECEIVE_2_ISR
0D02: A0 12    JZ    0x0D15        (0125) 
                                   (0126) 
0D04: 2C 04    OR    [4],A         (0127) IF (RECEIVE_2_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_2_aRxBuffer
0D06: 49 2E 00 TST   REG[46],0     (0129) export _RECEIVE_2_aRxBuffer
                                   (0130) export  RECEIVE_2_bRxCnt
0D09: 21 20    AND   A,32          (0131) export _RECEIVE_2_bRxCnt
0D0B: A0 50    JZ    0x0D5C        (0132) export  RECEIVE_2_fStatus
                                   (0133) export _RECEIVE_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
0D0D: 41 2F FE AND   REG[47],254   (0136) 
0D10: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
0D13: 80 48    JMP   0x0D5C        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_2_RXBUF_ENABLE)
0D15: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_2_fStatus:
                                   (0144) _RECEIVE_2_fStatus:      BLK  1
0D17: 47 04 01 TST   [4],1         (0145)  RECEIVE_2_bRxCnt:
0D1A: B0 41    JNZ   0x0D5C        (0146) _RECEIVE_2_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_2_RAM(RAM,REL,CON)
0D1C: 39 00    CMP   A,0           (0148)  RECEIVE_2_aRxBuffer:    
0D1E: B0 14    JNZ   0x0D33        (0149) _RECEIVE_2_aRxBuffer:    BLK RECEIVE_2_RX_BUFFER_SIZE
0D20: 2E 04 01 OR    [4],1         (0150) ENDIF
                                   (0151) 
0D23: 62 D3 00 MOV   REG[211],0    (0152) 
0D26: 70 3F    AND   F,63
0D28: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0D2A: 56 4B 00 MOV   [X+75],0      (0154) 
0D2D: 70 3F    AND   F,63
0D2F: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0D31: 80 2A    JMP   0x0D5C        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0D33: 3C 05 0F CMP   [5],15        (0167) ;------------------------
0D36: C0 14    JC    0x0D4B        (0168) 
0D38: 2E 04 10 OR    [4],16        (0169) 
                                   (0170) ;------------------------
0D3B: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0D3E: 70 3F    AND   F,63
0D40: 71 80    OR    F,128         (0172) ;------------------------
0D42: 56 4B 00 MOV   [X+75],0      (0173) 
0D45: 70 3F    AND   F,63
0D47: 71 00    OR    F,0           (0174) 
0D49: 80 12    JMP   0x0D5C        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0D4B: 75       INC   X             (0179) 
0D4C: 5A 05    MOV   [5],X         (0180) 
0D4E: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0D4F: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0D52: 70 3F    AND   F,63
0D54: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_2_ISR
0D56: 54 4B    MOV   [X+75],A      (0185) ;
0D58: 70 3F    AND   F,63
0D5A: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0D5C: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0D5D: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0D5F: 20       POP   X             (0195)    ; Insert your custom code below this banner
0D60: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0D62: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\receive_2.asm
                                   (0121) ;;*****************************************************************************
0D65: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_2.inc"
0D66: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
0D69: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_2_EnableInt
                                   (0155) export  _RECEIVE_2_EnableInt
                                   (0156) export   RECEIVE_2_DisableInt
                                   (0157) export  _RECEIVE_2_DisableInt
                                   (0158) export   RECEIVE_2_Start
                                   (0159) export  _RECEIVE_2_Start
                                   (0160) export   RECEIVE_2_Stop
                                   (0161) export  _RECEIVE_2_Stop
                                   (0162) export   RECEIVE_2_bReadRxData
                                   (0163) export  _RECEIVE_2_bReadRxData
                                   (0164) export   RECEIVE_2_bReadRxStatus
                                   (0165) export  _RECEIVE_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_2_ReadRxData
                                   (0170) export _bRECEIVE_2_ReadRxData
                                   (0171) export  bRECEIVE_2_ReadRxStatus
                                   (0172) export _bRECEIVE_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_2_cGetChar
0D6A: 29 01    OR    A,1           (0179) export _RECEIVE_2_cGetChar
0D6C: 60 2F    MOV   REG[47],A     (0180) export  RECEIVE_2_cReadChar
                                   (0181) export _RECEIVE_2_cReadChar
0D6E: 7F       RET                 (0182) export  RECEIVE_2_iReadChar
                                   (0183) export _RECEIVE_2_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_2_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_2_CmdReset
                                   (0187) export _RECEIVE_2_CmdReset
                                   (0188) export  RECEIVE_2_bCmdCheck
                                   (0189) export _RECEIVE_2_bCmdCheck
                                   (0190) export  RECEIVE_2_bCmdLength
                                   (0191) export _RECEIVE_2_bCmdLength
                                   (0192) export  RECEIVE_2_bErrCheck
                                   (0193) export _RECEIVE_2_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_2_szGetParam
                                   (0196) export _RECEIVE_2_szGetParam
                                   (0197) export  RECEIVE_2_szGetRestOfParams
                                   (0198) export _RECEIVE_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0D6F: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0D72: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_2_EnableInt:
                                   (0238) _RECEIVE_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0D73: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask RECEIVE_2_INT_REG, RECEIVE_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0D75: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_2_DisableInt:
                                   (0267) _RECEIVE_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_2_INT_REG, RECEIVE_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0D76: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
0D78: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_2_Start:
                                   (0297) _RECEIVE_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0D79: 49 2F 08 TST   REG[47],8     (0311) ;
0D7C: AF FC    JZ    0x0D79        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0D7E: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0D80: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_2_Stop:
                                   (0326) _RECEIVE_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0D81: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
0D83: 08       PUSH  A             (0347) ;
0D84: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0D86: B0 04    JNZ   0x0D8B        (0349) ;    The A and X registers may be modified by this or future implementations
0D88: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0D89: 80 0B    JMP   0x0D95        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0D8B: 5D 2E    MOV   A,REG[46]     (0354) ;
0D8D: 4B       SWAP  A,X           (0355)  RECEIVE_2_bReadRxData:
                                   (0356) _RECEIVE_2_bReadRxData:
0D8E: 18       POP   A             (0357)  bRECEIVE_2_ReadRxData:
0D8F: 21 A0    AND   A,160         (0358) _bRECEIVE_2_ReadRxData:
0D91: B0 03    JNZ   0x0D95        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0D93: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0D94: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0D95: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_2_bReadRxStatus
                                   (0368) ;
0D97: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_2_bReadRxStatus:
                                   (0388) _RECEIVE_2_bReadRxStatus:
                                   (0389)  bRECEIVE_2_ReadRxStatus:
                                   (0390) _bRECEIVE_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0D98: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0D9A: 21 E8    AND   A,232         (0408) ;
0D9C: 08       PUSH  A             (0409) ;  ARGUMENTS:
0D9D: 21 08    AND   A,8           (0410) ;      none
0D9F: B0 07    JNZ   0x0DA7        (0411) ;
0DA1: 18       POP   A             (0412) ;  RETURNS:
0DA2: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0DA4: 4B       SWAP  A,X           (0414) ;
0DA5: 80 07    JMP   0x0DAD        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0DA7: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0DA8: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0DAA: 4B       SWAP  A,X           (0420) ;    functions.
0DAB: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0DAD: 7F       RET                 (0426)  RECEIVE_2_cGetChar:
                                   (0427) _RECEIVE_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_2_CONTROL_REG],RECEIVE_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_2_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_2_cReadChar:
                                   (0463) _RECEIVE_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_2_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_2_RX_COMPLETE                            ; Check if a character is ready
0DAE: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0DB1: 55 4B 00 MOV   [75],0        (0470)    pop  A
0DB4: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0DB7: 55 A6 00 MOV   [166],0       (0472) 
0DBA: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0DBD: 55 05 00 MOV   [5],0         (0474)    mov  A,REG[RECEIVE_2_RX_BUFFER_REG]                     ; Read data first, then
0DC0: 26 04 00 AND   [4],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0DC3: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_2_RX_PARITY_ERROR | RECEIVE_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0DC4: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0DC7: 51 04    MOV   A,[4]         (0511) ;        0x40CC    Overrun Error
0DC9: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0DCB: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_2_iReadChar:
                                   (0523) _RECEIVE_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_2_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_2_RX_ERROR|RECEIVE_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_2_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_2_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_2_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_2_RXBUF_ENABLE)
                                   (0552) .SECTION
0DCC: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0DCF: 51 04    MOV   A,[4]         (0554) ;-----------------------------------------------------------------------------
0DD1: 21 F0    AND   A,240         (0555) ;
0DD3: 26 04 0F AND   [4],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0DD6: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_2_CmdReset:
0DD7: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_2_CmdReset:
0DDA: 51 05    MOV   A,[5]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_2_aRxBuffer
0DDC: 7F       RET                 (0590)    mov [RECEIVE_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_2_bRxCnt
                                   (0594)    mov [RECEIVE_2_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_2_bCmdCheck:
                                   (0628) _RECEIVE_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_2_fStatus
                                   (0631)    mov A,  [RECEIVE_2_fStatus]
                                   (0632)    and A, RECEIVE_2_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0DDD: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0DDF: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0DE2: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0DE5: 50 4B    MOV   A,75          (0648) ;     BYTE  fStatus - Status of command receive buffer.
0DE7: 02 A6    ADD   A,[166]       (0649) ;                     Returns non-zero value in A if command is valid.
0DE9: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0DEA: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0DEC: B0 04    JNZ   0x0DF1        (0653) ;           0x10 => Software Buffer OverRun
0DEE: 10       PUSH  X             (0654) ;
0DEF: 80 33    JMP   0x0E23        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0DF1: 39 00    CMP   A,0           (0660) ;    functions.
0DF3: B0 11    JNZ   0x0E05        (0661) ;          
0DF5: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0DF6: 76 A6    INC   [166]         (0663) ;          CUR_PP
0DF8: 52 00    MOV   A,[X+0]       (0664) ;
0DFA: 3C A6 0F CMP   [166],15      (0665) ;     Error Status is clear when read.
0DFD: BF F3    JNZ   0x0DF1        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0DFF: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_2_bErrCheck:
0E00: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_2_bErrCheck:
0E03: 80 1F    JMP   0x0E23        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_2_fStatus
                                   (0674)    mov A,  [RECEIVE_2_fStatus]
0E05: 10       PUSH  X             (0675)    and A, RECEIVE_2_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_2_fStatus], ~RECEIVE_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0E06: 75       INC   X             (0679) .ENDSECTION
0E07: 76 A6    INC   [166]         (0680) 
0E09: 3C A6 0F CMP   [166],15      (0681) .SECTION
0E0C: AF F3    JZ    0x0E00        (0682) ;-----------------------------------------------------------------------------
0E0E: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_2_bCmdLength
0E10: A0 12    JZ    0x0E23        (0684) ;
0E12: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0E14: BF F1    JNZ   0x0E06        (0686) ;     Get length of command string
                                   (0687) ;
0E16: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0E19: 76 A6    INC   [166]         (0689) ;     none.
0E1B: 3C A6 0F CMP   [166],15      (0690) ;
0E1E: B0 04    JNZ   0x0E23        (0691) ;  RETURNS:
0E20: 55 A6 0F MOV   [166],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0E23: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0E24: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0E25: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0E28: B0 0B    JNZ   0x0E34        (0699) ;    functions.
0E2A: 20       POP   X             (0700) ;          
0E2B: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0E2D: 50 00    MOV   A,0           (0702) ;          CUR_PP
0E2F: 70 3F    AND   F,63
0E31: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_2_bCmdLength:
0E33: 7F       RET                 (0705) _RECEIVE_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_2_bRxCnt
0E34: 20       POP   X             (0708)    mov A,  [RECEIVE_2_bRxCnt]
0E35: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0E37: 70 3F    AND   F,63
0E39: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0E3B: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0E3C: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0E3F: 50 4B    MOV   A,75          (0744) ;     each lexically distinct element into a null-terminated string by replacing
0E41: 02 A6    ADD   A,[166]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0E43: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0E44: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_2_szGetParam, is
0E47: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\receive_1int.asm
0E48: 10       PUSH  X             (0104) ;;*****************************************************************************
0E49: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_1INT.asm
0E4B: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0E4C: 58 07    MOV   X,[7]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0E4E: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0E50: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0E51: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0E53: B0 04    JNZ   0x0E58        (0115) 
0E55: 18       POP   A             (0116) include "m8c.inc"
0E56: 80 5E    JMP   0x0EB5        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_1.inc"
                                   (0119) 
                                   (0120) 
0E58: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0E59: 21 E0    AND   A,224         (0124) export  _RECEIVE_1_ISR
0E5B: A0 12    JZ    0x0E6E        (0125) 
                                   (0126) 
0E5D: 2C 06    OR    [6],A         (0127) IF (RECEIVE_1_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_1_aRxBuffer
0E5F: 49 2A 00 TST   REG[42],0     (0129) export _RECEIVE_1_aRxBuffer
                                   (0130) export  RECEIVE_1_bRxCnt
0E62: 21 20    AND   A,32          (0131) export _RECEIVE_1_bRxCnt
0E64: A0 50    JZ    0x0EB5        (0132) export  RECEIVE_1_fStatus
                                   (0133) export _RECEIVE_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
0E66: 41 2B FE AND   REG[43],254   (0136) 
0E69: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0E6C: 80 48    JMP   0x0EB5        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_1_RXBUF_ENABLE)
0E6E: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_1_fStatus:
                                   (0144) _RECEIVE_1_fStatus:      BLK  1
0E70: 47 06 01 TST   [6],1         (0145)  RECEIVE_1_bRxCnt:
0E73: B0 41    JNZ   0x0EB5        (0146) _RECEIVE_1_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_1_RAM(RAM,REL,CON)
0E75: 39 00    CMP   A,0           (0148)  RECEIVE_1_aRxBuffer:    
0E77: B0 14    JNZ   0x0E8C        (0149) _RECEIVE_1_aRxBuffer:    BLK RECEIVE_1_RX_BUFFER_SIZE
0E79: 2E 06 01 OR    [6],1         (0150) ENDIF
                                   (0151) 
0E7C: 62 D3 00 MOV   REG[211],0    (0152) 
0E7F: 70 3F    AND   F,63
0E81: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0E83: 56 5B 00 MOV   [X+91],0      (0154) 
0E86: 70 3F    AND   F,63
0E88: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0E8A: 80 2A    JMP   0x0EB5        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0E8C: 3C 07 0F CMP   [7],15        (0167) ;------------------------
0E8F: C0 14    JC    0x0EA4        (0168) 
0E91: 2E 06 10 OR    [6],16        (0169) 
                                   (0170) ;------------------------
0E94: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0E97: 70 3F    AND   F,63
0E99: 71 80    OR    F,128         (0172) ;------------------------
0E9B: 56 5B 00 MOV   [X+91],0      (0173) 
0E9E: 70 3F    AND   F,63
0EA0: 71 00    OR    F,0           (0174) 
0EA2: 80 12    JMP   0x0EB5        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0EA4: 75       INC   X             (0179) 
0EA5: 5A 07    MOV   [7],X         (0180) 
0EA7: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0EA8: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0EAB: 70 3F    AND   F,63
0EAD: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_1_ISR
0EAF: 54 5B    MOV   [X+91],A      (0185) ;
0EB1: 70 3F    AND   F,63
0EB3: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0EB5: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0EB6: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0EB8: 20       POP   X             (0195)    ; Insert your custom code below this banner
0EB9: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0EBB: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\receive_1.asm
                                   (0121) ;;*****************************************************************************
0EBE: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_1.inc"
0EBF: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0EC2: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_1_EnableInt
                                   (0155) export  _RECEIVE_1_EnableInt
                                   (0156) export   RECEIVE_1_DisableInt
                                   (0157) export  _RECEIVE_1_DisableInt
                                   (0158) export   RECEIVE_1_Start
                                   (0159) export  _RECEIVE_1_Start
                                   (0160) export   RECEIVE_1_Stop
                                   (0161) export  _RECEIVE_1_Stop
                                   (0162) export   RECEIVE_1_bReadRxData
                                   (0163) export  _RECEIVE_1_bReadRxData
                                   (0164) export   RECEIVE_1_bReadRxStatus
                                   (0165) export  _RECEIVE_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_1_ReadRxData
                                   (0170) export _bRECEIVE_1_ReadRxData
                                   (0171) export  bRECEIVE_1_ReadRxStatus
                                   (0172) export _bRECEIVE_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_1_cGetChar
0EC3: 29 01    OR    A,1           (0179) export _RECEIVE_1_cGetChar
0EC5: 60 2B    MOV   REG[43],A     (0180) export  RECEIVE_1_cReadChar
                                   (0181) export _RECEIVE_1_cReadChar
0EC7: 7F       RET                 (0182) export  RECEIVE_1_iReadChar
                                   (0183) export _RECEIVE_1_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_1_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_1_CmdReset
                                   (0187) export _RECEIVE_1_CmdReset
                                   (0188) export  RECEIVE_1_bCmdCheck
                                   (0189) export _RECEIVE_1_bCmdCheck
                                   (0190) export  RECEIVE_1_bCmdLength
                                   (0191) export _RECEIVE_1_bCmdLength
                                   (0192) export  RECEIVE_1_bErrCheck
                                   (0193) export _RECEIVE_1_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_1_szGetParam
                                   (0196) export _RECEIVE_1_szGetParam
                                   (0197) export  RECEIVE_1_szGetRestOfParams
                                   (0198) export _RECEIVE_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0EC8: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0ECB: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_1_EnableInt:
                                   (0238) _RECEIVE_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0ECC: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask RECEIVE_1_INT_REG, RECEIVE_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0ECE: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_1_DisableInt:
                                   (0267) _RECEIVE_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_1_INT_REG, RECEIVE_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0ECF: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0ED1: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_1_Start:
                                   (0297) _RECEIVE_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0ED2: 49 2B 08 TST   REG[43],8     (0311) ;
0ED5: AF FC    JZ    0x0ED2        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0ED7: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0ED9: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_1_Stop:
                                   (0326) _RECEIVE_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0EDA: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0EDC: 08       PUSH  A             (0347) ;
0EDD: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0EDF: B0 04    JNZ   0x0EE4        (0349) ;    The A and X registers may be modified by this or future implementations
0EE1: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0EE2: 80 0B    JMP   0x0EEE        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0EE4: 5D 2A    MOV   A,REG[42]     (0354) ;
0EE6: 4B       SWAP  A,X           (0355)  RECEIVE_1_bReadRxData:
                                   (0356) _RECEIVE_1_bReadRxData:
0EE7: 18       POP   A             (0357)  bRECEIVE_1_ReadRxData:
0EE8: 21 A0    AND   A,160         (0358) _bRECEIVE_1_ReadRxData:
0EEA: B0 03    JNZ   0x0EEE        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0EEC: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0EED: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0EEE: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_1_bReadRxStatus
                                   (0368) ;
0EF0: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_1_bReadRxStatus:
                                   (0388) _RECEIVE_1_bReadRxStatus:
                                   (0389)  bRECEIVE_1_ReadRxStatus:
                                   (0390) _bRECEIVE_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0EF1: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0EF3: 21 E8    AND   A,232         (0408) ;
0EF5: 08       PUSH  A             (0409) ;  ARGUMENTS:
0EF6: 21 08    AND   A,8           (0410) ;      none
0EF8: B0 07    JNZ   0x0F00        (0411) ;
0EFA: 18       POP   A             (0412) ;  RETURNS:
0EFB: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0EFD: 4B       SWAP  A,X           (0414) ;
0EFE: 80 07    JMP   0x0F06        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0F00: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0F01: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0F03: 4B       SWAP  A,X           (0420) ;    functions.
0F04: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0F06: 7F       RET                 (0426)  RECEIVE_1_cGetChar:
                                   (0427) _RECEIVE_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_1_CONTROL_REG],RECEIVE_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_1_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_1_cReadChar:
                                   (0463) _RECEIVE_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_1_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_1_RX_COMPLETE                            ; Check if a character is ready
0F07: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0F0A: 55 5B 00 MOV   [91],0        (0470)    pop  A
0F0D: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0F10: 55 A5 00 MOV   [NUM_MODULES+3],0(0472) 
0F13: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0F16: 55 07 00 MOV   [7],0         (0474)    mov  A,REG[RECEIVE_1_RX_BUFFER_REG]                     ; Read data first, then
0F19: 26 06 00 AND   [6],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0F1C: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_1_RX_PARITY_ERROR | RECEIVE_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0F1D: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0F20: 51 06    MOV   A,[6]         (0511) ;        0x40CC    Overrun Error
0F22: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0F24: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_1_iReadChar:
                                   (0523) _RECEIVE_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_1_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_1_RX_ERROR|RECEIVE_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_1_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_1_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_1_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_1_RXBUF_ENABLE)
                                   (0552) .SECTION
0F25: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0F28: 51 06    MOV   A,[6]         (0554) ;-----------------------------------------------------------------------------
0F2A: 21 F0    AND   A,240         (0555) ;
0F2C: 26 06 0F AND   [6],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0F2F: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_1_CmdReset:
0F30: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_1_CmdReset:
0F33: 51 07    MOV   A,[7]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_1_aRxBuffer
0F35: 7F       RET                 (0590)    mov [RECEIVE_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_1_bRxCnt
                                   (0594)    mov [RECEIVE_1_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_1_bCmdCheck:
                                   (0628) _RECEIVE_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_1_fStatus
                                   (0631)    mov A,  [RECEIVE_1_fStatus]
                                   (0632)    and A, RECEIVE_1_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0F36: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0F38: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0F3B: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0F3E: 50 5B    MOV   A,91          (0648) ;     BYTE  fStatus - Status of command receive buffer.
0F40: 02 A5    ADD   A,[NUM_MODULES+3](0649) ;                     Returns non-zero value in A if command is valid.
0F42: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0F43: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0F45: B0 04    JNZ   0x0F4A        (0653) ;           0x10 => Software Buffer OverRun
0F47: 10       PUSH  X             (0654) ;
0F48: 80 33    JMP   0x0F7C        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0F4A: 39 00    CMP   A,0           (0660) ;    functions.
0F4C: B0 11    JNZ   0x0F5E        (0661) ;          
0F4E: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0F4F: 76 A5    INC   [NUM_MODULES+3](0663) ;          CUR_PP
0F51: 52 00    MOV   A,[X+0]       (0664) ;
0F53: 3C A5 0F CMP   [NUM_MODULES+3],15(0665) ;     Error Status is clear when read.
0F56: BF F3    JNZ   0x0F4A        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0F58: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_1_bErrCheck:
0F59: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_1_bErrCheck:
0F5C: 80 1F    JMP   0x0F7C        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_1_fStatus
                                   (0674)    mov A,  [RECEIVE_1_fStatus]
0F5E: 10       PUSH  X             (0675)    and A, RECEIVE_1_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_1_fStatus], ~RECEIVE_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0F5F: 75       INC   X             (0679) .ENDSECTION
0F60: 76 A5    INC   [NUM_MODULES+3](0680) 
0F62: 3C A5 0F CMP   [NUM_MODULES+3],15(0681) .SECTION
0F65: AF F3    JZ    0x0F59        (0682) ;-----------------------------------------------------------------------------
0F67: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_1_bCmdLength
0F69: A0 12    JZ    0x0F7C        (0684) ;
0F6B: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0F6D: BF F1    JNZ   0x0F5F        (0686) ;     Get length of command string
                                   (0687) ;
0F6F: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0F72: 76 A5    INC   [NUM_MODULES+3](0689) ;     none.
0F74: 3C A5 0F CMP   [NUM_MODULES+3],15(0690) ;
0F77: B0 04    JNZ   0x0F7C        (0691) ;  RETURNS:
0F79: 55 A5 0F MOV   [NUM_MODULES+3],15(0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0F7C: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0F7D: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0F7E: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0F81: B0 0B    JNZ   0x0F8D        (0699) ;    functions.
0F83: 20       POP   X             (0700) ;          
0F84: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0F86: 50 00    MOV   A,0           (0702) ;          CUR_PP
0F88: 70 3F    AND   F,63
0F8A: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_1_bCmdLength:
0F8C: 7F       RET                 (0705) _RECEIVE_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_1_bRxCnt
0F8D: 20       POP   X             (0708)    mov A,  [RECEIVE_1_bRxCnt]
0F8E: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0F90: 70 3F    AND   F,63
0F92: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0F94: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0F95: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0F98: 50 5B    MOV   A,91          (0744) ;     each lexically distinct element into a null-terminated string by replacing
0F9A: 02 A5    ADD   A,[NUM_MODULES+3](0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0F9C: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0F9D: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_1_szGetParam, is
0FA0: 7E       RETI                (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\comp_serialint.asm
                                   (0102) ;;*****************************************************************************
                                   (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME:   COMP_SERIALINT.asm
                                   (0105) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                   (0109) ;;-----------------------------------------------------------------------------
                                   (0110) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0111) ;;*****************************************************************************
                                   (0112) ;;*****************************************************************************
                                   (0113) 
                                   (0114) 
                                   (0115) include "COMP_SERIAL.inc"
                                   (0116) include "memory.inc"
                                   (0117) include "m8c.inc"
                                   (0118) 
                                   (0119) ;-----------------------------------------------
                                   (0120) ;  Global Symbols
                                   (0121) ;-----------------------------------------------
                                   (0122) export  _COMP_SERIAL_TX_ISR
                                   (0123) export  _COMP_SERIAL_RX_ISR
                                   (0124) 
                                   (0125) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0126) export  COMP_SERIAL_aRxBuffer
                                   (0127) export _COMP_SERIAL_aRxBuffer
                                   (0128) export  COMP_SERIAL_bRxCnt
                                   (0129) export _COMP_SERIAL_bRxCnt
                                   (0130) export  COMP_SERIAL_fStatus
                                   (0131) export _COMP_SERIAL_fStatus
                                   (0132) ENDIF
                                   (0133) 
                                   (0134) 
                                   (0135) ;-----------------------------------------------
                                   (0136) ; Variable Allocation
                                   (0137) ;-----------------------------------------------
                                   (0138) AREA InterruptRAM (RAM, REL, CON)
                                   (0139) 
                                   (0140) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0141)  COMP_SERIAL_fStatus:
                                   (0142) _COMP_SERIAL_fStatus:      BLK  1
                                   (0143)  COMP_SERIAL_bRxCnt:
                                   (0144) _COMP_SERIAL_bRxCnt:       BLK  1
                                   (0145) AREA COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0146)  COMP_SERIAL_aRxBuffer:
                                   (0147) _COMP_SERIAL_aRxBuffer:    BLK COMP_SERIAL_RX_BUFFER_SIZE
                                   (0148) ENDIF
                                   (0149) 
                                   (0150) AREA InterruptRAM (RAM, REL, CON)
                                   (0151) 
0FA1: 08       PUSH  A             (0152) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0FA2: 10       PUSH  X             (0153) ;---------------------------------------------------
0FA3: 5D D3    MOV   A,REG[211]
                                   (0154) ; Insert your custom declarations below this banner
                                   (0155) ;---------------------------------------------------
0FA5: 08       PUSH  A             (0156) 
                                   (0157) ;------------------------
                                   (0158) ;  Includes
0FA6: 58 0A    MOV   X,[10]        (0159) ;------------------------
0FA8: 5D 3F    MOV   A,REG[63]     (0160) 
0FAA: 08       PUSH  A             (0161) 
                                   (0162) ;------------------------
0FAB: 21 08    AND   A,8           (0163) ;  Constant Definitions
0FAD: B0 04    JNZ   0x0FB2        (0164) ;------------------------
0FAF: 18       POP   A             (0165) 
0FB0: 80 5E    JMP   0x100F        (0166) 
                                   (0167) ;------------------------
                                   (0168) ; Variable Allocation
0FB2: 18       POP   A             (0169) ;------------------------
                                   (0170) 
                                   (0171) 
0FB3: 21 E0    AND   A,224         (0172) ;---------------------------------------------------
0FB5: A0 12    JZ    0x0FC8        (0173) ; Insert your custom declarations above this banner
                                   (0174) ;---------------------------------------------------
0FB7: 2C 09    OR    [9],A         (0175) ;@PSoC_UserCode_END@ (Do not change this line.)
0FB9: 49 3E 00 TST   REG[62],0     (0176) 
0FBC: 21 20    AND   A,32          (0177) 
0FBE: A0 50    JZ    0x100F        (0178) AREA UserModules (ROM, REL, CON)
                                   (0179) 
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: _COMP_SERIAL_TX_ISR
0FC0: 41 3F FE AND   REG[63],254   (0182) ;
0FC3: 43 3F 01 OR    REG[63],1     (0183) ;  DESCRIPTION:
0FC6: 80 48    JMP   0x100F        (0184) ;     UART TX interrupt handler for instance COMP_SERIAL.
                                   (0185) ;
                                   (0186) ;     This is a place holder function.  If the user requires use of an interrupt
                                   (0187) ;     handler for this function, then place code where specified.
0FC8: 5D 3E    MOV   A,REG[62]     (0188) ;-----------------------------------------------------------------------------
                                   (0189) 
                                   (0190) _COMP_SERIAL_TX_ISR:
0FCA: 47 09 01 TST   [9],1         (0191)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
0FCD: B0 41    JNZ   0x100F        (0192)    ;---------------------------------------------------
                                   (0193)    ; Insert your custom code below this banner
0FCF: 39 3B    CMP   A,59          (0194)    ;---------------------------------------------------
0FD1: B0 14    JNZ   0x0FE6        (0195)    ;   NOTE: interrupt service routines must preserve
0FD3: 2E 09 01 OR    [9],1         (0196)    ;   the values of the A and X CPU registers.
                                   (0197)    
                                   (0198)    ;---------------------------------------------------
                                   (0199)    ; Insert your custom code above this banner
0FD6: 62 D3 00 MOV   REG[211],0    (0200)    ;---------------------------------------------------
0FD9: 70 3F    AND   F,63
0FDB: 71 80    OR    F,128         (0201)    ;@PSoC_UserCode_END@ (Do not change this line.)
0FDD: 56 0B 00 MOV   [X+11],0      (0202)    reti
0FE0: 70 3F    AND   F,63
0FE2: 71 00    OR    F,0           (0203) 
0FE4: 80 2A    JMP   0x100F        (0204) 
                                   (0205) ;-----------------------------------------------------------------------------
                                   (0206) ;  FUNCTION NAME: _COMP_SERIAL_RX_ISR
                                   (0207) ;
                                   (0208) ;  DESCRIPTION:
                                   (0209) ;     UART RX interrupt handler for instance COMP_SERIAL.
                                   (0210) ;     This ISR handles the background processing of received characters if
                                   (0211) ;     the buffer is enabled.
                                   (0212) ;
                                   (0213) ;
                                   (0214) ;  The following assumes that the RX buffer feature has been enabled.
                                   (0215) ;
                                   (0216) ;  SIDE EFFECTS:
                                   (0217) ;     There are 3 posible errors that may occur with the serial port.
0FE6: 39 20    CMP   A,32          (0218) ;      1) Parity Error
0FE8: C0 26    JC    0x100F        (0219) ;      2) Framing Error
                                   (0220) ;      3) OverRun Error
                                   (0221) ;
                                   (0222) ;  This user module check for parity and framing error.  If either of these
                                   (0223) ;  two errors are detected, the data is read and ignored.  When an overRun
0FEA: 62 D3 00 MOV   REG[211],0    (0224) ;  error occurs, the last byte was lost, but the current byte is valid.  For
0FED: 3C 0A 3F CMP   [10],63       (0225) ;  this reason this error is ignored at this time.  Code could be added to
0FF0: C0 11    JC    0x1002        (0226) ;  this ISR to set a flag if an error condition occurs.
0FF2: 70 3F    AND   F,63
0FF4: 71 80    OR    F,128         (0227) ;
0FF6: 56 0B 00 MOV   [X+11],0      (0228) ;  THEORY of OPERATION:
0FF9: 70 3F    AND   F,63
0FFB: 71 00    OR    F,0           (0229) ;     When using the RX buffer feature, the ISR collects received characters
0FFD: 2E 09 10 OR    [9],16        (0230) ;     in a buffer until the user defined command terminator is detected.  After
1000: 80 0E    JMP   0x100F        (0231) ;     the command terminator is detected, the command bit is set and all other
1002: 70 3F    AND   F,63
                                   (0232) ;     characters will be ignored until the command bit is reset.  Up to
                                   (0233) ;     buffer_size - 1 characters will be collected waiting for a command
                                   (0234) ;     terminator.  After that, the characters will be discarded, although
1004: 71 80    OR    F,128         (0235) ;     a command determinator will still cause the command bit to be set.
1006: 54 0B    MOV   [X+11],A      (0236) ;
1008: 70 3F    AND   F,63
100A: 71 00    OR    F,0           (0237) ;-----------------------------------------------------------------------------
100C: 75       INC   X             (0238) _COMP_SERIAL_RX_ISR:
100D: 5A 0A    MOV   [10],X        (0239) 
100F: 18       POP   A
                                   (0240)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0241)    ;---------------------------------------------------
                                   (0242)    ; Insert your custom code below this banner
1010: 60 D3    MOV   REG[211],A    (0243)    ;---------------------------------------------------
                                   (0244)    ;   NOTE: interrupt service routines must preserve
                                   (0245)    ;   the values of the A and X CPU registers.
                                   (0246) 
1012: 20       POP   X             (0247)    ;---------------------------------------------------
1013: 18       POP   A             (0248)    ; Insert your custom code above this banner
                                   (0249)    ;---------------------------------------------------
                                   (0250)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0251) 
                                   (0252) IF (COMP_SERIAL_RXBUF_ENABLE)
1015: 43 E1 40 OR    REG[225],64   (0253)    push A

FILE: lib\comp_serial.asm
1018: 43 E1 80 OR    REG[225],128  (0180) ;;*****************************************************************************
                                   (0181) ;;*****************************************************************************
101B: 7F       RET                 (0182) ;;  Filename:   COMP_SERIAL.asm
                                   (0183) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0184) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0185) ;;
                                   (0186) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                   (0187) ;;                22/24/25/26/27xxx families.
                                   (0188) ;;
                                   (0189) ;;
                                   (0190) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0191) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0192) ;;        This means it is the caller's responsibility to preserve any values
                                   (0193) ;;        in the X and A registers that are still needed after the API functions
                                   (0194) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0195) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0196) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0197) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0198) ;;-----------------------------------------------------------------------------
                                   (0199) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0200) ;;*****************************************************************************
                                   (0201) ;;*****************************************************************************
                                   (0202) 
                                   (0203) 
                                   (0204) include "m8c.inc"
                                   (0205) include "memory.inc"
                                   (0206) include "COMP_SERIAL.inc"
                                   (0207) 
                                   (0208) ;-----------------------------------------------
                                   (0209) ;  Global Symbols
                                   (0210) ;-----------------------------------------------
101C: 41 E1 BF AND   REG[225],191  (0211) ;-------------------------------------------------------------------
101F: 41 E1 7F AND   REG[225],127  (0212) ;  Declare the functions global for both assembler and C compiler.
                                   (0213) ;
1022: 7F       RET                 (0214) ;  Note that there are two names for each API. First name is
                                   (0215) ;  assembler reference. Name with underscore is name refence for
                                   (0216) ;  C compiler.  Calling function in C source code does not require
                                   (0217) ;  the underscore.
                                   (0218) ;-------------------------------------------------------------------
                                   (0219) export  COMP_SERIAL_SetTxIntMode
                                   (0220) export _COMP_SERIAL_SetTxIntMode
                                   (0221) export  COMP_SERIAL_EnableInt
                                   (0222) export _COMP_SERIAL_EnableInt
                                   (0223) export  COMP_SERIAL_DisableInt
                                   (0224) export _COMP_SERIAL_DisableInt
                                   (0225) 
                                   (0226) export  COMP_SERIAL_Start
                                   (0227) export _COMP_SERIAL_Start
                                   (0228) export  COMP_SERIAL_Stop
                                   (0229) export _COMP_SERIAL_Stop
                                   (0230) export  COMP_SERIAL_SendData
                                   (0231) export _COMP_SERIAL_SendData
                                   (0232) export  COMP_SERIAL_bReadTxStatus
                                   (0233) export _COMP_SERIAL_bReadTxStatus
                                   (0234) export  COMP_SERIAL_bReadRxData
                                   (0235) export _COMP_SERIAL_bReadRxData
                                   (0236) export  COMP_SERIAL_bReadRxStatus
                                   (0237) export _COMP_SERIAL_bReadRxStatus
                                   (0238) 
                                   (0239) export  COMP_SERIAL_IntCntl
                                   (0240) export _COMP_SERIAL_IntCntl
                                   (0241) 
                                   (0242) export  COMP_SERIAL_TxIntMode
                                   (0243) export _COMP_SERIAL_TxIntMode
                                   (0244) 
                                   (0245) export  COMP_SERIAL_PutSHexByte
                                   (0246) export _COMP_SERIAL_PutSHexByte
1023: 71 10    OR    F,16          (0247) export  COMP_SERIAL_PutSHexInt
1025: 21 01    AND   A,1           (0248) export _COMP_SERIAL_PutSHexInt
1027: A0 07    JZ    0x102F        (0249) 
1029: 43 38 10 OR    REG[56],16    (0250) export  COMP_SERIAL_CPutString
102C: 70 EF    AND   F,239         (0251) export _COMP_SERIAL_CPutString
                                   (0252) export  COMP_SERIAL_PutString
102E: 7F       RET                 (0253) export _COMP_SERIAL_PutString
                                   (0254) export  COMP_SERIAL_PutChar
                                   (0255) export _COMP_SERIAL_PutChar
102F: 41 38 EF AND   REG[56],239   (0256) export  COMP_SERIAL_Write
1032: 70 EF    AND   F,239         (0257) export _COMP_SERIAL_Write
                                   (0258) export  COMP_SERIAL_CWrite
1034: 7F       RET                 (0259) export _COMP_SERIAL_CWrite
                                   (0260) 
                                   (0261) export  COMP_SERIAL_cGetChar
                                   (0262) export _COMP_SERIAL_cGetChar
                                   (0263) export  COMP_SERIAL_cReadChar
                                   (0264) export _COMP_SERIAL_cReadChar
                                   (0265) export  COMP_SERIAL_iReadChar
                                   (0266) export _COMP_SERIAL_iReadChar
                                   (0267) export  COMP_SERIAL_PutCRLF
                                   (0268) export _COMP_SERIAL_PutCRLF
                                   (0269) 
                                   (0270) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0271) export  COMP_SERIAL_CmdReset
                                   (0272) export _COMP_SERIAL_CmdReset
                                   (0273) export  COMP_SERIAL_bCmdCheck
                                   (0274) export _COMP_SERIAL_bCmdCheck
                                   (0275) export  COMP_SERIAL_bCmdLength
                                   (0276) export _COMP_SERIAL_bCmdLength
                                   (0277) export  COMP_SERIAL_bErrCheck
                                   (0278) export _COMP_SERIAL_bErrCheck
                                   (0279) 
                                   (0280) export  COMP_SERIAL_szGetParam
                                   (0281) export _COMP_SERIAL_szGetParam
                                   (0282) export  COMP_SERIAL_szGetRestOfParams
                                   (0283) export _COMP_SERIAL_szGetRestOfParams
                                   (0284) ENDIF
                                   (0285) 
                                   (0286) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0287) ; WARNING WARNING WARNING
                                   (0288) ; The following exports are for backwards compatibility only and should
                                   (0289) ; not be used for new designs. They may be eliminated in a future release.
1035: 29 01    OR    A,1           (0290) ; Their status is "NO FURTHER MAINTENANCE". 
1037: 60 3B    MOV   REG[59],A     (0291) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1039: 60 3F    MOV   REG[63],A     (0292) export  bCOMP_SERIAL_ReadTxStatus
                                   (0293) export _bCOMP_SERIAL_ReadTxStatus
103B: 91 2A    CALL  0x1167        (0294) export  bCOMP_SERIAL_ReadRxData
                                   (0295) export _bCOMP_SERIAL_ReadRxData
                                   (0296) export  bCOMP_SERIAL_ReadRxStatus
103D: 7F       RET                 (0297) export _bCOMP_SERIAL_ReadRxStatus
                                   (0298) 	
                                   (0299) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0300) ;             END WARNING
                                   (0301) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0302) 
                                   (0303) ;-----------------------------------------------
                                   (0304) ; Variable Allocation
                                   (0305) ;-----------------------------------------------
                                   (0306) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0307)     
                                   (0308) area COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0309)     
                                   (0310)  ptrParam:   BLK  1
                                   (0311) 
                                   (0312) ENDIF
                                   (0313) 
                                   (0314) area text (ROM,REL)
                                   (0315) 
                                   (0316) ;-----------------------------------------------
                                   (0317) ;  EQUATES
                                   (0318) ;-----------------------------------------------
                                   (0319) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                   (0320) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                   (0321) 
                                   (0322) area UserModules (ROM, REL, CON)
                                   (0323) 
                                   (0324) ;=============================================================================
103E: 41 3B FE AND   REG[59],254   (0325) ;=============================================================================
1041: 41 3F FE AND   REG[63],254   (0326) ;
                                   (0327) ;     Low-Level Commands
1044: 7F       RET                 (0328) ;
                                   (0329) ;=============================================================================
                                   (0330) ;=============================================================================
                                   (0331) 
                                   (0332) .SECTION
                                   (0333) ;-----------------------------------------------------------------------------
                                   (0334) ;  FUNCTION NAME: COMP_SERIAL_EnableInt
                                   (0335) ;
                                   (0336) ;  DESCRIPTION:
                                   (0337) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                   (0338) ;     bit associated with this User Module. Remember to call the global
                                   (0339) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;
                                   (0342) ;  ARGUMENTS:
                                   (0343) ;     none.
                                   (0344) ;
                                   (0345) ;  RETURNS:
                                   (0346) ;     none.
                                   (0347) ;
                                   (0348) ;  SIDE EFFECTS:
                                   (0349) ;    The A and X registers may be modified by this or future implementations
                                   (0350) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
                                   (0354) ;
                                   (0355)  COMP_SERIAL_EnableInt:
1045: 60 39    MOV   REG[57],A     (0356) _COMP_SERIAL_EnableInt:
                                   (0357)    RAM_PROLOGUE RAM_USE_CLASS_1
1047: 7F       RET                 (0358)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0359)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0361)    ret
                                   (0362) .ENDSECTION
                                   (0363) 
                                   (0364)     
                                   (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: COMP_SERIAL_DisableInt
                                   (0368) ;
                                   (0369) ;  DESCRIPTION:
                                   (0370) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                   (0371) ;     associated with this User Module.
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:
                                   (0375) ;     none.
                                   (0376) ;
                                   (0377) ;  RETURNS:
                                   (0378) ;     none.
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  COMP_SERIAL_DisableInt:
                                   (0388) _COMP_SERIAL_DisableInt:
1048: 5D 3B    MOV   A,REG[59]     (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0390)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
104A: 7F       RET                 (0391)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0392)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0393)    ret
                                   (0394) .ENDSECTION
                                   (0395) 
                                   (0396) 
                                   (0397) .SECTION
                                   (0398) ;-----------------------------------------------------------------------------
                                   (0399) ;  FUNCTION NAME: COMP_SERIAL_SetTxIntMode(BYTE bTxIntMode)
                                   (0400) ;
                                   (0401) ;  DESCRIPTION:
                                   (0402) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0403) ;-----------------------------------------------------------------------------
                                   (0404) ;
                                   (0405) ;  ARGUMENTS:
                                   (0406) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0407) ;        Passed in the A register
                                   (0408) ;
                                   (0409) ;  RETURNS:
                                   (0410) ;     none.
                                   (0411) ;
                                   (0412) ;  SIDE EFFECTS:
                                   (0413) ;    The A and X registers may be modified by this or future implementations
                                   (0414) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0415) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0416) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0417) ;    functions.
                                   (0418) ;
                                   (0419) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0420) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0421) ;     on TX register empty or TX transmit complete
104B: 5D 3E    MOV   A,REG[62]     (0422) ;
                                   (0423)  COMP_SERIAL_SetTxIntMode:
104D: 7F       RET                 (0424) _COMP_SERIAL_SetTxIntMode:
                                   (0425)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0426)    M8C_SetBank1
                                   (0427)    and   A, COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0428)    jz    .SetModeRegEmpty
                                   (0429)    or    REG[COMP_SERIAL_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0430)    M8C_SetBank0
                                   (0431)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0432)    ret
                                   (0433) 
                                   (0434) .SetModeRegEmpty:
                                   (0435)    and   REG[COMP_SERIAL_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0436)    M8C_SetBank0
                                   (0437)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0438)    ret
                                   (0439) .ENDSECTION
                                   (0440) 
                                   (0441) 
                                   (0442) .SECTION
                                   (0443) ;-----------------------------------------------------------------------------
                                   (0444) ;  FUNCTION NAME: COMP_SERIAL_Start(BYTE bParity)
                                   (0445) ;
                                   (0446) ;  DESCRIPTION:
                                   (0447) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0448) ;-----------------------------------------------------------------------------
                                   (0449) ;
                                   (0450) ;  ARGUMENTS:
                                   (0451) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                   (0452) ;        Passed in the A register.
                                   (0453) ;
                                   (0454) ;  RETURNS:
                                   (0455) ;     none.
104E: 5D 3F    MOV   A,REG[63]     (0456) ;
                                   (0457) ;  SIDE EFFECTS:
1050: 7F       RET                 (0458) ;    The A and X registers may be modified by this or future implementations
                                   (0459) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0460) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0461) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0462) ;    functions.
                                   (0463) ;
                                   (0464)  COMP_SERIAL_Start:
                                   (0465) _COMP_SERIAL_Start:
                                   (0466)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0467)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                   (0468) 
                                   (0469)    or    A, bfCONTROL_REG_START_BIT
                                   (0470)    mov   REG[COMP_SERIAL_TX_CONTROL_REG], A
                                   (0471)    mov   REG[COMP_SERIAL_RX_CONTROL_REG], A
                                   (0472) IF ( COMP_SERIAL_RXBUF_ENABLE )
                                   (0473)    call  _COMP_SERIAL_CmdReset
                                   (0474) ENDIF
                                   (0475)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0476)    ret
                                   (0477) .ENDSECTION
                                   (0478) 
                                   (0479) 
                                   (0480) .SECTION
                                   (0481) ;-----------------------------------------------------------------------------
                                   (0482) ;  FUNCTION NAME: COMP_SERIAL_Stop
                                   (0483) ;
                                   (0484) ;  DESCRIPTION:
                                   (0485) ;     Disables UART operation.
                                   (0486) ;-----------------------------------------------------------------------------
                                   (0487) ;
                                   (0488) ;  ARGUMENTS:
1051: 21 01    AND   A,1           (0489) ;     none.
1053: 71 10    OR    F,16          (0490) ;
1055: 39 01    CMP   A,1           (0491) ;  RETURNS:
1057: A0 06    JZ    0x105E        (0492) ;     none.
                                   (0493) ;
1059: 41 38 EF AND   REG[56],239   (0494) ;  SIDE EFFECTS:
105C: 80 04    JMP   0x1061        (0495) ;    The A and X registers may be modified by this or future implementations
                                   (0496) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0497) ;    the Large Memory Model.  When necessary, it is the calling function's
105E: 43 38 10 OR    REG[56],16    (0498) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0499) ;    functions.
                                   (0500) ;
1061: 70 EF    AND   F,239         (0501)  COMP_SERIAL_Stop:
                                   (0502) _COMP_SERIAL_Stop:
1063: 7F       RET                 (0503)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0504)    and   REG[COMP_SERIAL_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0505)    and   REG[COMP_SERIAL_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0506)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0507)    ret
                                   (0508) .ENDSECTION
                                   (0509) 
                                   (0510) 
                                   (0511) .SECTION
                                   (0512) ;-----------------------------------------------------------------------------
                                   (0513) ;  FUNCTION NAME: COMP_SERIAL_SendData
                                   (0514) ;
                                   (0515) ;  DESCRIPTION:
                                   (0516) ;     Initiates a transmission of data.
                                   (0517) ;-----------------------------------------------------------------------------
                                   (0518) ;
                                   (0519) ;  ARGUMENTS:
                                   (0520) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                   (0521) ;
                                   (0522) ;  RETURNS:
                                   (0523) ;     none.
                                   (0524) ;
                                   (0525) ;  SIDE EFFECTS:
                                   (0526) ;    The A and X registers may be modified by this or future implementations
                                   (0527) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0528) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0529) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0530) ;    functions.
                                   (0531) ;
                                   (0532)  COMP_SERIAL_SendData:
                                   (0533) _COMP_SERIAL_SendData:
                                   (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0535)    mov REG[COMP_SERIAL_TX_BUFFER_REG], A
1064: 08       PUSH  A             (0536)    RAM_EPILOGUE RAM_USE_CLASS_1
1065: 21 01    AND   A,1           (0537)    ret
1067: A0 06    JZ    0x106E        (0538) .ENDSECTION
                                   (0539) 
1069: 43 E1 80 OR    REG[225],128  (0540) 
106C: 80 04    JMP   0x1071        (0541) .SECTION
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) ;  FUNCTION NAME: COMP_SERIAL_bReadTxStatus
106E: 41 E1 7F AND   REG[225],127  (0544) ;
                                   (0545) ;  DESCRIPTION:
                                   (0546) ;     Reads the Tx Status bits in the Control/Status register.
1071: 18       POP   A             (0547) ;-----------------------------------------------------------------------------
1072: 21 02    AND   A,2           (0548) ;
1074: A0 06    JZ    0x107B        (0549) ;  ARGUMENTS:
                                   (0550) ;     none.
1076: 43 E1 40 OR    REG[225],64   (0551) ;
1079: 80 04    JMP   0x107E        (0552) ;  RETURNS:
                                   (0553) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                   (0554) ;           status bits (returned in A)
107B: 41 E1 BF AND   REG[225],191  (0555) ;
                                   (0556) ;  SIDE EFFECTS:
                                   (0557) ;    The A and X registers may be modified by this or future implementations
                                   (0558) ;    of this function.  The same is true for all RAM page pointer registers in
107E: 7F       RET                 (0559) ;    the Large Memory Model.  When necessary, it is the calling function's
107F: 30       HALT  
1080: 31 32    XOR   A,50
1082: 33 34    XOR   A,[X+52]
1084: 35 36    XOR   [X+54],A
1086: 37 38 39 XOR   [X+56],57
1089: 41 42 43 AND   REG[66],67
108C: 44 45 46 OR    REG[X+69],70
                                   (0560) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0561) ;    functions.
                                   (0562) ;
                                   (0563)  COMP_SERIAL_bReadTxStatus:
                                   (0564) _COMP_SERIAL_bReadTxStatus:
                                   (0565)  bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0566) _bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0567)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0568)    mov A,  REG[COMP_SERIAL_TX_CONTROL_REG]
                                   (0569)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0570)    ret
                                   (0571) .ENDSECTION
                                   (0572) 
                                   (0573) 
                                   (0574) .SECTION
                                   (0575) ;-----------------------------------------------------------------------------
                                   (0576) ;  FUNCTION NAME: COMP_SERIAL_bReadRxData
                                   (0577) ;
                                   (0578) ;  DESCRIPTION:
                                   (0579) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0580) ;     sure data is valid.
                                   (0581) ;-----------------------------------------------------------------------------
                                   (0582) ;
                                   (0583) ;  ARGUMENTS:
                                   (0584) ;     none.
                                   (0585) ;
                                   (0586) ;  RETURNS:
                                   (0587) ;     bRxData - returned in A.
                                   (0588) ;
                                   (0589) ;  SIDE EFFECTS:
                                   (0590) ;    The A and X registers may be modified by this or future implementations
                                   (0591) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0592) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0593) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0594) ;    functions.
                                   (0595) ;
                                   (0596)  COMP_SERIAL_bReadRxData:
                                   (0597) _COMP_SERIAL_bReadRxData:
                                   (0598)  bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0599) _bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
108F: 08       PUSH  A             (0601)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]
1090: 67       ASR   A             (0602)    RAM_EPILOGUE RAM_USE_CLASS_1
1091: 67       ASR   A             (0603)    ret
1092: 67       ASR   A             (0604) .ENDSECTION
1093: 67       ASR   A             (0605) 
1094: 21 0F    AND   A,15          (0606) 
1096: FF E7    INDEX 0x107F        (0607) .SECTION
1098: 90 0F    CALL  0x10A9        (0608) ;-----------------------------------------------------------------------------
109A: 18       POP   A             (0609) ;  FUNCTION NAME: COMP_SERIAL_bReadRxStatus
109B: 21 0F    AND   A,15          (0610) ;
109D: FF E0    INDEX 0x107F        (0611) ;  DESCRIPTION:
109F: 90 08    CALL  0x10A9        (0612) ;     Reads the RX Status bits in the Control/Status register.
                                   (0613) ;-----------------------------------------------------------------------------
10A1: 7F       RET                 (0614) ;
                                   (0615) ;  ARGUMENTS:
                                   (0616) ;     none.
                                   (0617) ;
                                   (0618) ;  RETURNS:
                                   (0619) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                   (0620) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0621) ;           returned in A.
                                   (0622) ;
                                   (0623) ;  SIDE EFFECTS:
                                   (0624) ;    The A and X registers may be modified by this or future implementations
                                   (0625) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0626) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0627) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0628) ;    functions.
                                   (0629) ;
                                   (0630)  COMP_SERIAL_bReadRxStatus:
                                   (0631) _COMP_SERIAL_bReadRxStatus:
                                   (0632)  bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0633) _bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0634)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0635)    mov A,  REG[COMP_SERIAL_RX_CONTROL_REG]
                                   (0636)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0637)    ret
                                   (0638) .ENDSECTION
                                   (0639) 
                                   (0640) 
                                   (0641) .SECTION
                                   (0642) ;-----------------------------------------------------------------------------
                                   (0643) ;  FUNCTION NAME: COMP_SERIAL_TxIntMode
                                   (0644) ;
10A2: 4B       SWAP  A,X           (0645) ;  DESCRIPTION:
10A3: 9F EA    CALL  0x108F        (0646) ;     This function is used to change the TX Interrupt mode.
10A5: 5B       MOV   A,X           (0647) ;-----------------------------------------------------------------------------
10A6: 9F E7    CALL  0x108F        (0648) ;
                                   (0649) ;  ARGUMENTS:
10A8: 7F       RET                 (0650) ;     A => Tx Interrupt mode
10A9: 49 3B 10 TST   REG[59],16
                                   (0651) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                   (0652) ;             1 => Interrupt on TX Complete
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none.
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
                                   (0663) ;
                                   (0664)  COMP_SERIAL_TxIntMode:
                                   (0665) _COMP_SERIAL_TxIntMode:
                                   (0666)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0667) 
                                   (0668)    and  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0669)    M8C_SetBank1
                                   (0670)    cmp  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0671)    jz   .SetTxCmpMode
                                   (0672) 
                                   (0673)    and  reg[COMP_SERIAL_TX_FUNC_REG],0xEF        ; Set Interrupt on Tx_Reg_Empty
                                   (0674)    jmp  .TxIntMode_End
                                   (0675) 
                                   (0676) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
                                   (0677)    or   reg[COMP_SERIAL_TX_FUNC_REG],0x10
                                   (0678) 
                                   (0679) .TxIntMode_End:
                                   (0680)    M8C_SetBank0
                                   (0681)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0682)    ret
                                   (0683) .ENDSECTION
                                   (0684) 
                                   (0685)     
10AC: AF FC    JZ    0x10A9        (0686) .SECTION
10AE: 60 39    MOV   REG[57],A
                                   (0687) ;-----------------------------------------------------------------------------
10B0: 7F       RET                 (0688) ;  FUNCTION NAME: COMP_SERIAL_IntCntl
                                   (0689) ;
                                   (0690) ;  DESCRIPTION:
                                   (0691) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                   (0692) ;-----------------------------------------------------------------------------
                                   (0693) ;
                                   (0694) ;  ARGUMENTS:
                                   (0695) ;     A => Interrupt mask
                                   (0696) ;
                                   (0697) ;  RETURNS:
                                   (0698) ;     none.
                                   (0699) ;
                                   (0700) ;  SIDE EFFECTS:
                                   (0701) ;    The A and X registers may be modified by this or future implementations
                                   (0702) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0703) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0704) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0705) ;    functions.
                                   (0706) ;
                                   (0707) ;  THEORY of OPERATION or PROCEDURE:
                                   (0708) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                   (0709) ;     and RX block.
                                   (0710) ;
                                   (0711)  COMP_SERIAL_IntCntl:
                                   (0712) _COMP_SERIAL_IntCntl:
                                   (0713)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0714) 
                                   (0715)    push A
                                   (0716)    and  A,COMP_SERIAL_ENABLE_RX_INT
                                   (0717)    jz   .DisRxInt
                                   (0718)      ; Enable Rx Interrupt
                                   (0719)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
10B1: 49 3F 08 TST   REG[63],8     (0720)    jmp  .CheckTxInt
10B4: AF FC    JZ    0x10B1        (0721) .DisRxInt:
10B6: 5D 3E    MOV   A,REG[62]     (0722)      ; Disable Rx Interrupt
                                   (0723)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
10B8: 7F       RET                 (0724) 
                                   (0725) .CheckTxInt:
                                   (0726)    pop  A
                                   (0727)    and  A,COMP_SERIAL_ENABLE_TX_INT
                                   (0728)    jz   .DisTxInt
                                   (0729)      ; Enable Tx Interrupt
                                   (0730)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0731)    jmp  .End_IntCntl
                                   (0732) .DisTxInt:
                                   (0733)      ; Disable Tx Interrupt
                                   (0734)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0735) 
                                   (0736) .End_IntCntl:
                                   (0737)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0738)    ret
                                   (0739) .ENDSECTION
                                   (0740) 
                                   (0741) 
                                   (0742) ;=============================================================================
                                   (0743) ;=============================================================================
                                   (0744) ;
                                   (0745) ;     High-Level Commands
                                   (0746) ;
                                   (0747) ;=============================================================================
                                   (0748) ;=============================================================================
                                   (0749) 
                                   (0750) 
                                   (0751) ;-----------------------------------------------------------------------------
                                   (0752) ;  FUNCTION NAME: COMP_SERIAL_PutSHexByte
                                   (0753) ;
                                   (0754) ;  DESCRIPTION:
10B9: 5D 3F    MOV   A,REG[63]     (0755) ;     Print a byte in Hex (two characters) to the UART Tx
10BB: 08       PUSH  A             (0756) ;-----------------------------------------------------------------------------
10BC: 21 08    AND   A,8           (0757) ;
10BE: B0 04    JNZ   0x10C3        (0758) ;  ARGUMENTS:
10C0: 18       POP   A             (0759) ;     A  => (BYTE) Data/char to be printed
10C1: 80 0B    JMP   0x10CD        (0760) ;
                                   (0761) ;  RETURNS:
                                   (0762) ;     none.
10C3: 5D 3E    MOV   A,REG[62]     (0763) ;
10C5: 4B       SWAP  A,X           (0764) ;  SIDE EFFECTS:
                                   (0765) ;    The A and X registers may be modified by this or future implementations
10C6: 18       POP   A             (0766) ;    of this function.  The same is true for all RAM page pointer registers in
10C7: 21 A0    AND   A,160         (0767) ;    the Large Memory Model.  When necessary, it is the calling function's
10C9: B0 03    JNZ   0x10CD        (0768) ;    responsibility to perserve their values across calls to fastcall16 
10CB: 4B       SWAP  A,X           (0769) ;    functions.
                                   (0770) ;
10CC: 7F       RET                 (0771) .LITERAL
                                   (0772) COMP_SERIAL_HEX_STR:
                                   (0773)      DS    "0123456789ABCDEF"
10CD: 50 00    MOV   A,0           (0774) .ENDLITERAL
                                   (0775) 
                                   (0776) .SECTION
                                   (0777)  COMP_SERIAL_PutSHexByte:
10CF: 7F       RET                 (0778) _COMP_SERIAL_PutSHexByte:
                                   (0779)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0780)    push  A                             ; Save lower nibble
                                   (0781)    asr   A                             ; Shift high nibble to right
                                   (0782)    asr   A
                                   (0783)    asr   A
                                   (0784)    asr   A
                                   (0785)    and   A,0Fh                         ; Mask off nibble
                                   (0786)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0787)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0788)    pop   A                             ; Restore value
                                   (0789)    and   A,0Fh                         ; Mask off lower nibble
                                   (0790)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0791)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0792)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0793)    ret
                                   (0794) .ENDSECTION
                                   (0795) 
                                   (0796) 
                                   (0797) .SECTION
                                   (0798) ;-----------------------------------------------------------------------------
                                   (0799) ;  FUNCTION NAME: COMP_SERIAL_PutSHexInt
                                   (0800) ;
                                   (0801) ;  DESCRIPTION:
                                   (0802) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0803) ;-----------------------------------------------------------------------------
                                   (0804) ;
                                   (0805) ;  ARGUMENTS:
                                   (0806) ;     Pointer to string
                                   (0807) ;     A  => ASB of Int
                                   (0808) ;     X  => MSB of Int
                                   (0809) ;
                                   (0810) ;  RETURNS:
                                   (0811) ;     none.
                                   (0812) ;
                                   (0813) ;  SIDE EFFECTS:
                                   (0814) ;    The A and X registers may be modified by this or future implementations
                                   (0815) ;    of this function.  The same is true for all RAM page pointer registers in
10D0: 5D 3F    MOV   A,REG[63]     (0816) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0817) ;    responsibility to perserve their values across calls to fastcall16 
10D2: 21 E8    AND   A,232         (0818) ;    functions.
10D4: 08       PUSH  A             (0819) ;
10D5: 21 08    AND   A,8           (0820) 
10D7: B0 07    JNZ   0x10DF        (0821)  COMP_SERIAL_PutSHexInt:
10D9: 18       POP   A             (0822) _COMP_SERIAL_PutSHexInt:
10DA: 29 01    OR    A,1           (0823)    RAM_PROLOGUE RAM_USE_CLASS_1
10DC: 4B       SWAP  A,X           (0824)    swap  A,X
10DD: 80 07    JMP   0x10E5        (0825)    call  COMP_SERIAL_PutSHexByte       ; Print MSB
                                   (0826)    mov   A,X                           ; Move LSB into position
                                   (0827)    call  COMP_SERIAL_PutSHexByte       ; Print LSB
10DF: 18       POP   A             (0828)    RAM_EPILOGUE RAM_USE_CLASS_1
10E0: 21 E0    AND   A,224         (0829)    ret
10E2: 4B       SWAP  A,X           (0830) .ENDSECTION
10E3: 5D 3E    MOV   A,REG[62]     (0831) 
                                   (0832) 
                                   (0833) .SECTION
                                   (0834) ;-----------------------------------------------------------------------------
                                   (0835) ;  FUNCTION NAME: COMP_SERIAL_PutChar
10E5: 7F       RET                 (0836) ;
                                   (0837) ;  DESCRIPTION:
                                   (0838) ;     Send character out through UART TX port.
                                   (0839) ;-----------------------------------------------------------------------------
                                   (0840) ;
                                   (0841) ;  ARGUMENTS:
                                   (0842) ;     A has Character to send to UART Tx Port
                                   (0843) ;
                                   (0844) ;  RETURNS:
                                   (0845) ;     none
                                   (0846) ;
                                   (0847) ;  SIDE EFFECTS:
                                   (0848) ;    The A and X registers may be modified by this or future implementations
                                   (0849) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0850) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0851) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0852) ;    functions.
                                   (0853) ;
                                   (0854) 
                                   (0855)    macro InLinePutChar( Source )
                                   (0856) .BufEmptyWaitLoop:
                                   (0857)    tst REG[COMP_SERIAL_TX_CONTROL_REG], COMP_SERIAL_TX_BUFFER_EMPTY     ; Check Tx Status
                                   (0858)    jz  .BufEmptyWaitLoop
                                   (0859)    mov REG[COMP_SERIAL_TX_BUFFER_REG], @Source     ; Write data to Tx Port
                                   (0860)    endm
                                   (0861) 
                                   (0862)  COMP_SERIAL_PutChar:
                                   (0863) _COMP_SERIAL_PutChar:
                                   (0864)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0865)    InLinePutChar A
                                   (0866)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0867)    ret
10E6: 70 BF    AND   F,191         (0868) .ENDSECTION
10E8: 60 D3    MOV   REG[211],A    (0869) 
                                   (0870) 
10EA: 52 00    MOV   A,[X+0]       (0871) .SECTION
10EC: A0 06    JZ    0x10F3        (0872) ;-----------------------------------------------------------------------------
10EE: 9F B9    CALL  0x10A9        (0873) ;  FUNCTION NAME: COMP_SERIAL_cGetChar
10F0: 75       INC   X             (0874) ;
10F1: 8F F8    JMP   0x10EA        (0875) ;  DESCRIPTION:
10F3: 70 3F    AND   F,63
                                   (0876) ;     Read character from UART RX port.
                                   (0877) ;-----------------------------------------------------------------------------
10F5: 71 C0    OR    F,192         (0878) ;
10F7: 7F       RET                 (0879) ;  ARGUMENTS:
                                   (0880) ;      none
                                   (0881) ;
                                   (0882) ;  RETURNS:
                                   (0883) ;     char that is returned from UART
                                   (0884) ;
                                   (0885) ;  SIDE EFFECTS:
                                   (0886) ;    The A and X registers may be modified by this or future implementations
                                   (0887) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0888) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0889) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0890) ;    functions.
                                   (0891) ;
                                   (0892) ;    Program flow will stay in this function until a character is received.
                                   (0893) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0894) ;    the delay between characters is less than the watchdog timeout.
                                   (0895) ;
                                   (0896)  COMP_SERIAL_cGetChar:
                                   (0897) _COMP_SERIAL_cGetChar:
                                   (0898)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0899)    tst REG[COMP_SERIAL_RX_CONTROL_REG],COMP_SERIAL_RX_REG_FULL    ; Check if a character is ready
                                   (0900)    jz  COMP_SERIAL_cGetChar                              ; If not loop
                                   (0901)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]                 ; Get character
                                   (0902)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0903)    ret
                                   (0904) .ENDSECTION
                                   (0905) 
                                   (0906) 
                                   (0907) .SECTION
                                   (0908) ;-----------------------------------------------------------------------------
                                   (0909) ;  FUNCTION NAME: COMP_SERIAL_cReadChar
                                   (0910) ;
                                   (0911) ;  DESCRIPTION:
                                   (0912) ;     Read character from UART RX port.
                                   (0913) ;-----------------------------------------------------------------------------
                                   (0914) ;
10F8: 70 BF    AND   F,191         (0915) ;  ARGUMENTS:
10FA: 62 D3 03 MOV   REG[211],3    (0916) ;      none
10FD: 4F       MOV   X,SP          (0917) ;
                                   (0918) ;  RETURNS:
                                   (0919) ;     char that is returned from UART
10FE: 52 FB    MOV   A,[X-5]       (0920) ;
1100: A0 1A    JZ    0x111B        (0921) ;  SIDE EFFECTS:
1102: 7B FB    DEC   [X-5]         (0922) ;    The A and X registers may be modified by this or future implementations
                                   (0923) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0924) ;    the Large Memory Model.  When necessary, it is the calling function's
1104: 52 FC    MOV   A,[X-4]       (0925) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0926) ;    functions.
                                   (0927) ;
1106: 59 FD    MOV   X,[X-3]       (0928) ;    A valid 0x00 character will be ignored, since a 0x00 return value
1108: 60 D3    MOV   REG[211],A    (0929) ;    implies a valid character or an error condition occured.
110A: 52 00    MOV   A,[X+0]       (0930) ;
110C: 49 3B 10 TST   REG[59],16
110F: AF FC    JZ    0x110C        (0931)  COMP_SERIAL_cReadChar:
1111: 60 39    MOV   REG[57],A
1113: 4F       MOV   X,SP          (0932) _COMP_SERIAL_cReadChar:
1114: 62 D3 03 MOV   REG[211],3    (0933)    RAM_PROLOGUE RAM_USE_CLASS_1
1117: 77 FD    INC   [X-3]         (0934)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
1119: 8F E4    JMP   0x10FE        (0935)    push A
111B: 70 3F    AND   F,63
                                   (0936)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (0937)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
111D: 71 C0    OR    F,192         (0938)    pop  A
111F: 7F       RET                 (0939)    jmp  .RX_NO_VALID_CHAR
                                   (0940) 
                                   (0941) .RX_DATA_RDY:
                                   (0942)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]          
                                   (0943)    swap A,X                                                ; determine if data is valid
                                   (0944) 
                                   (0945)    pop  A                                                  ; Check for errors
                                   (0946)    and  A,(COMP_SERIAL_RX_PARITY_ERROR | COMP_SERIAL_RX_FRAMING_ERROR)
                                   (0947)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0948)    swap A,X                                                ; Put data in A and exit
                                   (0949)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0950)    ret
                                   (0951) 
                                   (0952) .RX_NO_VALID_CHAR:
                                   (0953)    mov A,0x00                                              ; Zero out character
                                   (0954) 
                                   (0955)  End_COMP_SERIAL_cReadChar:
                                   (0956)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0957)    ret
                                   (0958) .ENDSECTION
                                   (0959) 
                                   (0960) 
                                   (0961) .SECTION
                                   (0962) ;-----------------------------------------------------------------------------
                                   (0963) ;  FUNCTION NAME: COMP_SERIAL_iReadChar
                                   (0964) ;
                                   (0965) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0966) ;  to just set a value in the upper byte if error conditions exists.
                                   (0967) ;
                                   (0968) ;  DESCRIPTION:
                                   (0969) ;     Read character from UART RX port.
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;
                                   (0972) ;  ARGUMENTS:
                                   (0973) ;      none
                                   (0974) ;
                                   (0975) ;  RETURNS:
                                   (0976) ;     An integer value is returned.  A negative value inplies and error
1120: 4F       MOV   X,SP          (0977) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0978) ;
1121: 3D FA 00 CMP   [X-6],0       (0979) ;     Error Codes:
1124: B0 06    JNZ   0x112B        (0980) ;        0x80CC    Parity Error
1126: 3D FB 00 CMP   [X-5],0       (0981) ;        0x40CC    Overrun Error
1129: A0 1D    JZ    0x1147        (0982) ;        0x20CC    Framing Error
                                   (0983) ;        0x01CC    No Data available
                                   (0984) ;
112B: 10       PUSH  X             (0985) ;  SIDE EFFECTS:
112C: 52 FC    MOV   A,[X-4]       (0986) ;    The A and X registers may be modified by this or future implementations
112E: 59 FD    MOV   X,[X-3]       (0987) ;    of this function.  The same is true for all RAM page pointer registers in
1130: 28       ROMX                (0988) ;    the Large Memory Model.  When necessary, it is the calling function's
1131: 49 3B 10 TST   REG[59],16
1134: AF FC    JZ    0x1131        (0989) ;    responsibility to perserve their values across calls to fastcall16 
1136: 60 39    MOV   REG[57],A
1138: 20       POP   X             (0990) ;    functions.
1139: 07 FD 01 ADD   [X-3],1       (0991) ;
113C: 0F FC 00 ADC   [X-4],0       (0992)  COMP_SERIAL_iReadChar:
113F: 17 FB 01 SUB   [X-5],1       (0993) _COMP_SERIAL_iReadChar:
1142: 1F FA 00 SBB   [X-6],0       (0994)    RAM_PROLOGUE RAM_USE_CLASS_1
1145: 8F DB    JMP   0x1121        (0995)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
1147: 70 3F    AND   F,63
                                   (0996)                                                            ; Mask only errors and data ready
                                   (0997)    and  A,(COMP_SERIAL_RX_ERROR|COMP_SERIAL_RX_REG_FULL)
1149: 71 C0    OR    F,192         (0998)    push A
114B: 7F       RET                 (0999)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (1000)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (1001)    pop  A
                                   (1002)    or   A,COMP_SERIAL_RX_NO_DATA                           ; Add no data flag
                                   (1003)    swap A,X
                                   (1004)    jmp  End_COMP_SERIAL_iReadChar
                                   (1005) 
                                   (1006) .RX_GET_DATA:
                                   (1007)    pop  A
                                   (1008)    and  A,COMP_SERIAL_RX_ERROR
                                   (1009)    swap A,X
                                   (1010)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]                  ; Read data first, then
                                   (1011)                                                            ; determine if data is valid
                                   (1012) 
                                   (1013)  End_COMP_SERIAL_iReadChar:
                                   (1014)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1015)    ret
                                   (1016) .ENDSECTION
                                   (1017) 
                                   (1018) 
                                   (1019) .SECTION
                                   (1020) ;-----------------------------------------------------------------------------
                                   (1021) ;  FUNCTION NAME: COMP_SERIAL_PutString
                                   (1022) ;
                                   (1023) ;  DESCRIPTION:
                                   (1024) ;     Send String out through UART TX port.
                                   (1025) ;-----------------------------------------------------------------------------
                                   (1026) ;
                                   (1027) ;  ARGUMENTS:
                                   (1028) ;     Pointer to String
114C: 08       PUSH  A             (1029) ;     A has MSB of string address
114D: 10       PUSH  X             (1030) ;     X has LSB of string address
114E: 28       ROMX                (1031) ;
114F: A0 0B    JZ    0x115B        (1032) ;  RETURNS:
1151: 9F 56    CALL  0x10A9        (1033) ;     none
1153: 20       POP   X             (1034) ;
1154: 18       POP   A             (1035) ;  SIDE EFFECTS:
1155: 75       INC   X             (1036) ;    The A and X registers may be modified by this or future implementations
1156: DF F5    JNC   0x114C        (1037) ;    of this function.  The same is true for all RAM page pointer registers in
1158: 74       INC   A             (1038) ;    the Large Memory Model.  When necessary, it is the calling function's
1159: 8F F2    JMP   0x114C        (1039) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1040) ;    functions.
                                   (1041) ;          
                                   (1042) ;    Currently only the page pointer registers listed below are modified: 
115B: 38 FE    ADD   SP,254        (1043) ;          IDX_PP
                                   (1044) ;
115D: 7F       RET                 (1045)  COMP_SERIAL_PutString:
                                   (1046) _COMP_SERIAL_PutString:
                                   (1047)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1048)    RAM_SETPAGE_IDX A
                                   (1049) .PutStringLoop:
                                   (1050)    mov   A,[X]                                   ; Get value pointed to by X
                                   (1051)    jz    End_PutString                           ; Check for end of string
                                   (1052)    call  COMP_SERIAL_PutChar                     ; Send character to Tx port
                                   (1053)    inc   X                                       ; Advance pointer to next character
                                   (1054)    jmp   .PutStringLoop                          ; Get next character
                                   (1055) 
                                   (1056) End_PutString:
                                   (1057)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1058)    ret
                                   (1059) .ENDSECTION
                                   (1060)     
                                   (1061) .SECTION
                                   (1062) ;-----------------------------------------------------------------------------
                                   (1063) ;  FUNCTION NAME: COMP_SERIAL_Write
                                   (1064) ;
                                   (1065) ;  DESCRIPTION:
                                   (1066) ;     Send String of length X to serial port
                                   (1067) ;-----------------------------------------------------------------------------
                                   (1068) ;
                                   (1069) ;  ARGUMENTS:
                                   (1070) ;     Pointer to String
                                   (1071) ;     [SP-5] Count of characters to send
                                   (1072) ;     [SP-4] has MSB of string address
115E: 50 0D    MOV   A,13          (1073) ;     [SP-3] has LSB of string address
1160: 9F 47    CALL  0x10A9        (1074) ;
1162: 50 0A    MOV   A,10          (1075) ;  RETURNS:
1164: 9F 43    CALL  0x10A9        (1076) ;     none
                                   (1077) ;
1166: 7F       RET                 (1078) ;  SIDE EFFECTS:
                                   (1079) ;    The A and X registers may be modified by this or future implementations
                                   (1080) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1082) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1083) ;    functions.
                                   (1084) ;          
                                   (1085) ;    Currently only the page pointer registers listed below are modified: 
                                   (1086) ;          IDX_PP
                                   (1087) ;
                                   (1088) CNT_LEN:    equ -5                               ; Length of data to send
                                   (1089) STR_MSB:    equ -4                               ; MSB pointer of string 
                                   (1090) STR_LSB:    equ -3                               ; LSB pointer of string 
                                   (1091) 
                                   (1092)  COMP_SERIAL_Write:
                                   (1093) _COMP_SERIAL_Write:
                                   (1094)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1095)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
                                   (1096)    mov   X, SP                                   ; Establish the frame pointer 
                                   (1097) 
                                   (1098) .NextByteLoop:
                                   (1099)    mov   A, [X+CNT_LEN]                          ; End of the string?
                                   (1100)    jz    .End_Write                              ;   Yes, prepare to exit
                                   (1101)    dec   [X+CNT_LEN]                             ; Decrement counter
                                   (1102) 
                                   (1103)    IF SYSTEM_LARGE_MEMORY_MODEL
                                   (1104)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                   (1105)    ENDIF
                                   (1106) 
                                   (1107)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
                                   (1108)    RAM_SETPAGE_IDX A                             ; switch index pages
                                   (1109)    mov   A, [X]                                  ; Grab the data
                                   (1110)    InLinePutChar A                               ; Put data in empty TX buf reg
                                   (1111)    mov   X, SP                                   ; Recover frame pointer
                                   (1112)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
                                   (1113)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
                                   (1114)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
                                   (1115) 
                                   (1116) .End_Write:
                                   (1117)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1118)    ret
                                   (1119) .ENDSECTION
                                   (1120)     
1167: 62 D0 00 MOV   REG[208],0    (1121) 
116A: 55 0B 00 MOV   [11],0        (1122) .SECTION
116D: 62 D0 00 MOV   REG[208],0    (1123) ;-----------------------------------------------------------------------------
1170: 55 0A 00 MOV   [10],0        (1124) ;  FUNCTION NAME: COMP_SERIAL_CWrite
1173: 26 09 00 AND   [9],0         (1125) ;
1176: 62 D0 00 MOV   REG[208],0    (1126) ;             WARNING WARNING NOT COMPLETE
1179: 55 A8 00 MOV   [168],0       (1127) ;
                                   (1128) ;  DESCRIPTION:
117C: 7F       RET                 (1129) ;     Send String of length X to serial port
                                   (1130) ;-----------------------------------------------------------------------------
                                   (1131) ;
                                   (1132) ;  ARGUMENTS:
                                   (1133) ;     [SP-4] MSB of Count of character to send
                                   (1134) ;     [SP-3] LSB of Count of character to send
                                   (1135) ;     [SP-2] has MSB of string address
                                   (1136) ;     [SP-1] has LSB of string address
                                   (1137) ;
                                   (1138) ;  RETURNS:
                                   (1139) ;     none
                                   (1140) ;
                                   (1141) ;  SIDE EFFECTS:
                                   (1142) ;    The A and X registers may be modified by this or future implementations
                                   (1143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1146) ;    functions.
                                   (1147) ;
                                   (1148) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                   (1149) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                   (1150) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (1151) CSTR_LSB:   equ -3           ; LSB pointer of string
                                   (1152) 
                                   (1153)  COMP_SERIAL_CWrite:
                                   (1154) _COMP_SERIAL_CWrite:
                                   (1155)    RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1156)    mov   X,SP
                                   (1157) .CW_Loop:
                                   (1158)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
                                   (1159)    jnz   .CW_WRITEIT
                                   (1160)    cmp   [X+CLEN_LSB],0x00
                                   (1161)    jz    .End_CWrite                        ; Leave if done
                                   (1162) 
                                   (1163) .CW_WRITEIT:                                
117D: 62 D0 00 MOV   REG[208],0    (1164)    push  X                                  ; Save frame pointer
1180: 51 09    MOV   A,[9]         (1165)    mov   A,[X+CSTR_MSB]
1182: 21 01    AND   A,1           (1166)    mov   X,[X+CSTR_LSB]
                                   (1167)    romx                                     ; Get character from ROM
1184: 7F       RET                 (1168)    InLinePutChar A                          ; Put data in empty TX buf reg
                                   (1169)    pop   X                                  ; Restore frame pointer
                                   (1170)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
                                   (1171)    adc   [X+CSTR_MSB],0
                                   (1172)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
                                   (1173)    sbb   [X+CLEN_MSB],0x00
                                   (1174)    jmp   .CW_Loop
                                   (1175) 
                                   (1176) .End_CWrite:
                                   (1177)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1178)    ret
                                   (1179) .ENDSECTION
                                   (1180) 
                                   (1181) 
                                   (1182) .SECTION
                                   (1183) ;-----------------------------------------------------------------------------
                                   (1184) ;  FUNCTION NAME: COMP_SERIAL_CPutString
                                   (1185) ;
                                   (1186) ;  DESCRIPTION:
                                   (1187) ;     Send String out through UART TX port.
                                   (1188) ;-----------------------------------------------------------------------------
                                   (1189) ;
                                   (1190) ;  ARGUMENTS:
                                   (1191) ;     Pointer to String
                                   (1192) ;     A has MSB of string address
                                   (1193) ;     X has LSB of string address
                                   (1194) ;
                                   (1195) ;  RETURNS:
                                   (1196) ;     none
                                   (1197) ;
                                   (1198) ;  SIDE EFFECTS:
                                   (1199) ;    The A and X registers may be modified by this or future implementations
                                   (1200) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1202) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1203) ;    functions.
                                   (1204) ;
                                   (1205)  COMP_SERIAL_CPutString:
                                   (1206) _COMP_SERIAL_CPutString:
                                   (1207)    RAM_PROLOGUE RAM_USE_CLASS_1
1185: 62 D0 00 MOV   REG[208],0    (1208)    push  A                                       ; Store ROM pointer
1188: 51 09    MOV   A,[9]         (1209)    push  X
118A: 21 F0    AND   A,240         (1210)    romx                                          ; Get character from ROM
118C: 26 09 0F AND   [9],15        (1211)    jz    .End_CPutString
                                   (1212)    call  COMP_SERIAL_PutChar                     ; Print character
118F: 7F       RET                 (1213)    pop   X
                                   (1214)    pop   A
                                   (1215)    inc   X                                       ; Inc LSB of pointer
                                   (1216)    jnc   COMP_SERIAL_CPutString                  ; Check for carry
                                   (1217)    inc   A                                       ; Inc MSB of pointer
                                   (1218)    jmp   COMP_SERIAL_CPutString
                                   (1219) 
                                   (1220) 
                                   (1221) .End_CPutString:
                                   (1222)    add   SP, -2
                                   (1223)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1224)    ret
                                   (1225) .ENDSECTION
                                   (1226) 
                                   (1227) 
                                   (1228) .SECTION
                                   (1229) ;-----------------------------------------------------------------------------
                                   (1230) ;  FUNCTION NAME: COMP_SERIAL_PutCRLF
                                   (1231) ;
                                   (1232) ;  DESCRIPTION:
                                   (1233) ;     Send a CR and LF
                                   (1234) ;-----------------------------------------------------------------------------
                                   (1235) ;
                                   (1236) ;  ARGUMENTS:
                                   (1237) ;     none.
                                   (1238) ;
                                   (1239) ;  RETURNS:
                                   (1240) ;     none.
                                   (1241) ;
                                   (1242) ;  SIDE EFFECTS:
1190: 62 D0 00 MOV   REG[208],0    (1243) ;    The A and X registers may be modified by this or future implementations
1193: 51 0A    MOV   A,[10]        (1244) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1245) ;    the Large Memory Model.  When necessary, it is the calling function's
1195: 7F       RET                 (1246) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1247) ;    functions.
                                   (1248) ;
                                   (1249)  COMP_SERIAL_PutCRLF:
                                   (1250) _COMP_SERIAL_PutCRLF:
                                   (1251)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1252)    mov  A,0x0D                        ; Send CR
                                   (1253)    call COMP_SERIAL_PutChar
                                   (1254)    mov  A,0x0A                        ; Send LF
                                   (1255)    call COMP_SERIAL_PutChar
                                   (1256)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1257)    ret
                                   (1258) .ENDSECTION
                                   (1259) 
                                   (1260) 
                                   (1261) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (1262) ;=============================================================================
                                   (1263) ;=============================================================================
                                   (1264) ;
                                   (1265) ;     Command Buffer commands
                                   (1266) ;
                                   (1267) ;=============================================================================
                                   (1268) ;=============================================================================
                                   (1269) 
                                   (1270) .SECTION
                                   (1271) ;-----------------------------------------------------------------------------
                                   (1272) ;  FUNCTION NAME: COMP_SERIAL_CmdReset
                                   (1273) ;
                                   (1274) ;  DESCRIPTION:
                                   (1275) ;     Reset command string and status flags
                                   (1276) ;-----------------------------------------------------------------------------
                                   (1277) ;
                                   (1278) ;  ARGUMENTS:
                                   (1279) ;     none.
                                   (1280) ;
                                   (1281) ;  RETURNS:
                                   (1282) ;     none.
                                   (1283) ;
                                   (1284) ;  SIDE EFFECTS:
                                   (1285) ;    The A and X registers may be modified by this or future implementations
                                   (1286) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1287) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1288) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1289) ;    functions.
                                   (1290) ;          
                                   (1291) ;    Currently only the page pointer registers listed below are modified: 
                                   (1292) ;          CUR_PP
                                   (1293) ;
                                   (1294) ;  THEORY of OPERATION or PROCEDURE:
                                   (1295) ;     Clear the command buffer, command counter, and flag.
                                   (1296) ;
                                   (1297)  COMP_SERIAL_CmdReset:
                                   (1298) _COMP_SERIAL_CmdReset:
                                   (1299)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1300)    RAM_SETPAGE_CUR >COMP_SERIAL_aRxBuffer
1196: 70 BF    AND   F,191         (1301)    mov [COMP_SERIAL_aRxBuffer], 0x00
                                   (1302)    RAM_SETPAGE_CUR >COMP_SERIAL_bRxCnt
1198: 62 D0 00 MOV   REG[208],0    (1303)    mov [COMP_SERIAL_bRxCnt], 0x00
119B: 50 0B    MOV   A,11          (1304)    and [COMP_SERIAL_fStatus], 0x00
119D: 02 A8    ADD   A,[168]       (1305)    RAM_SETPAGE_CUR >ptrParam
119F: 5C       MOV   X,A           (1306)    mov [ptrParam],0x00
11A0: 62 D3 00 MOV   REG[211],0    (1307)    RAM_EPILOGUE RAM_USE_CLASS_4
11A3: 52 00    MOV   A,[X+0]       (1308)    ret
11A5: B0 04    JNZ   0x11AA        (1309) .ENDSECTION
11A7: 10       PUSH  X             (1310) 
11A8: 80 33    JMP   0x11DC        (1311) 
                                   (1312) .SECTION
                                   (1313) ;-----------------------------------------------------------------------------
                                   (1314) ;  FUNCTION NAME: COMP_SERIAL_bCmdCheck
11AA: 39 2C    CMP   A,44          (1315) ;
11AC: B0 11    JNZ   0x11BE        (1316) ;  DESCRIPTION:
11AE: 75       INC   X             (1317) ;     Check to see if valid command in buffer.
11AF: 76 A8    INC   [168]         (1318) ;-----------------------------------------------------------------------------
11B1: 52 00    MOV   A,[X+0]       (1319) ;
11B3: 3C A8 3F CMP   [168],63      (1320) ;  ARGUMENTS:
11B6: BF F3    JNZ   0x11AA        (1321) ;     none.
                                   (1322) ;
                                   (1323) ;  RETURNS:
11B8: 10       PUSH  X             (1324) ;     BYTE  fStatus - Status of command receive buffer.
                                   (1325) ;                     Returns non-zero value in A if command is valid.
11B9: 56 00 00 MOV   [X+0],0       (1326) ;
11BC: 80 1F    JMP   0x11DC        (1327) ;  SIDE EFFECTS:
                                   (1328) ;    The A and X registers may be modified by this or future implementations
                                   (1329) ;    of this function.  The same is true for all RAM page pointer registers in
11BE: 10       PUSH  X             (1330) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1331) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1332) ;    functions.
11BF: 75       INC   X             (1333) ;          
11C0: 76 A8    INC   [168]         (1334) ;    Currently only the page pointer registers listed below are modified: 
11C2: 3C A8 3F CMP   [168],63      (1335) ;          CUR_PP
11C5: AF F3    JZ    0x11B9        (1336) ;
11C7: 52 00    MOV   A,[X+0]       (1337) ;  THEORY of OPERATION or PROCEDURE:
11C9: A0 12    JZ    0x11DC        (1338) ;     Read the status and control register.
11CB: 39 2C    CMP   A,44          (1339) ;
11CD: BF F1    JNZ   0x11BF        (1340)  COMP_SERIAL_bCmdCheck:
11CF: 56 00 00 MOV   [X+0],0       (1341) _COMP_SERIAL_bCmdCheck:
11D2: 76 A8    INC   [168]         (1342)    RAM_PROLOGUE RAM_USE_CLASS_4
11D4: 3C A8 3F CMP   [168],63      (1343)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
11D7: B0 04    JNZ   0x11DC        (1344)    mov A,  [COMP_SERIAL_fStatus]
11D9: 55 A8 3F MOV   [168],63      (1345)    and A, COMP_SERIAL_RX_BUF_CMDTERM             ; Mask off Command status
                                   (1346)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1347)    ret
11DC: 20       POP   X             (1348) .ENDSECTION
11DD: 10       PUSH  X             (1349)     
11DE: 3D 00 00 CMP   [X+0],0       (1350) 
11E1: B0 0B    JNZ   0x11ED        (1351) .SECTION
11E3: 20       POP   X             (1352) ;-----------------------------------------------------------------------------
11E4: 57 00    MOV   X,0           (1353) ;  FUNCTION NAME: COMP_SERIAL_bErrCheck
11E6: 50 00    MOV   A,0           (1354) ;
11E8: 70 3F    AND   F,63
11EA: 71 C0    OR    F,192         (1355) ;  DESCRIPTION:
                                   (1356) ;     Check to see if an error has occured since last CmdReset
11EC: 7F       RET                 (1357) ;-----------------------------------------------------------------------------
                                   (1358) ;
                                   (1359) ;  ARGUMENTS:
11ED: 20       POP   X             (1360) ;     none.
11EE: 50 00    MOV   A,0           (1361) ;
11F0: 70 3F    AND   F,63
11F2: 71 C0    OR    F,192         (1362) ;  RETURNS:
                                   (1363) ;     BYTE  fStatus - Status of command receive buffer.
11F4: 7F       RET                 (1364) ;                     Returns non-zero value in A if command is valid.
                                   (1365) ;           0x80 => Parity Error
                                   (1366) ;           0x40 => OverRun Error
                                   (1367) ;           0x20 => Framing Error
                                   (1368) ;           0x10 => Software Buffer OverRun
                                   (1369) ;
                                   (1370) ;  SIDE EFFECTS:
                                   (1371) ;    The A and X registers may be modified by this or future implementations
                                   (1372) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1373) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1374) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1375) ;    functions.
                                   (1376) ;          
                                   (1377) ;    Currently only the page pointer registers listed below are modified: 
                                   (1378) ;          CUR_PP
                                   (1379) ;     Error Status is clear when read.
                                   (1380) ;
                                   (1381) ;  THEORY of OPERATION or PROCEDURE:
                                   (1382) ;     Read RX buffer error status and clear status
                                   (1383) ;
                                   (1384)  COMP_SERIAL_bErrCheck:
                                   (1385) _COMP_SERIAL_bErrCheck:
                                   (1386)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1387)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
                                   (1388)    mov A,  [COMP_SERIAL_fStatus]
                                   (1389)    and A, COMP_SERIAL_RX_BUF_ERROR               ; Mask off Error status
                                   (1390)    and [COMP_SERIAL_fStatus], ~COMP_SERIAL_RX_BUF_ERROR
                                   (1391)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1392)    ret
                                   (1393) .ENDSECTION
                                   (1394) 
11F5: 62 D0 00 MOV   REG[208],0    (1395) .SECTION
11F8: 50 0B    MOV   A,11          (1396) ;-----------------------------------------------------------------------------
11FA: 02 A8    ADD   A,[168]       (1397) ;  FUNCTION NAME: COMP_SERIAL_bCmdLength
11FC: 5C       MOV   X,A           (1398) ;
11FD: 50 00    MOV   A,0           (1399) ;  DESCRIPTION:
                                   (1400) ;     Get length of command string
__text_start:
_main:
1200: 62 D0 00 MOV   REG[208],0    (1401) ;-----------------------------------------------------------------------------
1203: 55 A3 00 MOV   [NUM_MODULES+1],0
1206: 55 A2 00 MOV   [NUM_MODULES],0

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
(0121) // Author: Jason Tennyson
1209: 62 D0 00 MOV   REG[208],0
120C: 55 A1 00 MOV   [STATE+1],0
120F: 55 A0 00 MOV   [STATE],0
(0122) // Date: 7-10-11
(0123) // File: main.c
(0124) //
1212: 43 E0 20 OR    REG[224],32
(0125) // This is the design for the parent module of Jason Tennyson's Thesis.
(0126) // This design is made for a PSoC CY8C28433-24PVXI.
(0127) //
1215: 71 01    OR    F,1
1217: 80 21    JMP   0x1239
(0128) // Controller Packet Structure (each field is a byte)
(0129) // -----------------------------------------------------
(0130) // All Packets:
(0131) // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
(0132) //
1219: 62 D0 00 MOV   REG[208],0
121C: 3C A2 00 CMP   [NUM_MODULES],0
121F: B0 0B    JNZ   0x122B
1221: 3C A3 00 CMP   [NUM_MODULES+1],0
1224: B0 06    JNZ   0x122B
(0133) // Servo Packet Structure (each field is a byte)
(0134) // -----------------------------------------------------
1226: 7C 1F 1F LCALL _initializeChildren
(0135) // Source Packets:
1229: 80 0F    JMP   0x1239
(0136) // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
122B: 10       PUSH  X
122C: 7C 11 7D LCALL 0x117D
122F: 62 D0 00 MOV   REG[208],0
1232: 20       POP   X
1233: 39 00    CMP   A,0
1235: A0 03    JZ    0x1239
(0137) //
(0138) // Return Packets:
1237: 93 8A    CALL  _decodeTransmission
1239: 8F DF    JMP   0x1219
123B: 8F FF    JMP   0x123B
(0139) // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
(0140) 
(0141) #include <m8c.h>        	// Part-specific constants and macros.
(0142) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules.
(0143) #include "psocdynamic.h"	// Required for dynamically swapping configurations at run time.
(0144) #include <stdlib.h>			// Required for converting character arrays to and from floats and ints.
_pingModule:
  module_id            --> X-5
123D: 10       PUSH  X
123E: 4F       MOV   X,SP
(0145) 
(0146) //#include <string.h>
123F: 50 00    MOV   A,0
1241: 08       PUSH  A
1242: 50 01    MOV   A,1
1244: 08       PUSH  A
1245: 7C 1E 25 LCALL _configToggle
1248: 38 FE    ADD   SP,254
(0147) 
(0148) // These are declarations of all of the timer interrupts that are used for all configurations.
(0149) #pragma interrupt_handler TX_TIMEOUT_ISR
124A: 10       PUSH  X
124B: 50 FC    MOV   A,252
124D: 7C 09 57 LCALL 0x0957
1250: 20       POP   X
(0150) #pragma interrupt_handler RX_TIMEOUT_ISR
1251: 10       PUSH  X
1252: 50 FC    MOV   A,252
1254: 7C 08 7E LCALL 0x087E
1257: 20       POP   X
(0151) 
1258: 10       PUSH  X
1259: 50 FC    MOV   A,252
125B: 7C 09 57 LCALL 0x0957
125E: 20       POP   X
(0152) // These defines are used as parameters of the configToggle function.
125F: 10       PUSH  X
1260: 50 FC    MOV   A,252
1262: 7C 08 7E LCALL 0x087E
1265: 20       POP   X
(0153) // Passing one or the other in the function call switches the system between PC and RX modes.
1266: 10       PUSH  X
1267: 50 00    MOV   A,0
1269: 7C 09 57 LCALL 0x0957
126C: 20       POP   X
(0154) #define		PC_MODE						(1)
126D: 10       PUSH  X
126E: 50 00    MOV   A,0
1270: 7C 08 7E LCALL 0x087E
1273: 20       POP   X
(0155) #define		RX_MODE						(2)
1274: 62 D0 00 MOV   REG[208],0
1277: 52 FC    MOV   A,[X-4]
1279: 10       PUSH  X
127A: 7C 09 57 LCALL 0x0957
127D: 20       POP   X
(0156) 
127E: 62 D0 00 MOV   REG[208],0
1281: 52 FC    MOV   A,[X-4]
1283: 10       PUSH  X
1284: 7C 08 7E LCALL 0x087E
1287: 20       POP   X
(0157) // These defines are used as comparisons to find what port the newest module is connected to.
1288: 10       PUSH  X
1289: 50 CB    MOV   A,203
128B: 7C 09 57 LCALL 0x0957
128E: 20       POP   X
(0158) #define		PORT_1						('1')
128F: 10       PUSH  X
1290: 50 CB    MOV   A,203
1292: 7C 08 7E LCALL 0x087E
1295: 20       POP   X
(0159) #define		PORT_2						('2')
1296: 10       PUSH  X
1297: 50 FD    MOV   A,253
1299: 7C 09 57 LCALL 0x0957
129C: 20       POP   X
(0160) #define		PORT_3						('3')
129D: 10       PUSH  X
129E: 50 FD    MOV   A,253
12A0: 7C 08 7E LCALL 0x087E
12A3: 20       POP   X
(0161) #define		PORT_4						('4')
12A4: 10       PUSH  X
12A5: 50 FD    MOV   A,253
12A7: 7C 09 57 LCALL 0x0957
12AA: 20       POP   X
(0162) 
12AB: 10       PUSH  X
12AC: 50 FD    MOV   A,253
12AE: 7C 08 7E LCALL 0x087E
12B1: 20       POP   X
(0163) // This is the module type identifier.
(0164) #define		TYPE						('2')
(0165) 
12B2: 10       PUSH  X
12B3: 7C 09 2A LCALL 0x092A
12B6: 62 D0 00 MOV   REG[208],0
12B9: 20       POP   X
12BA: 53 9D    MOV   [__r0],A
12BC: 47 9D 20 TST   [__r0],32
12BF: AF F2    JZ    0x12B2
(0166) // These defines are used as transmission indicators.
12C1: 10       PUSH  X
12C2: 7C 08 51 LCALL 0x0851
12C5: 62 D0 00 MOV   REG[208],0
12C8: 20       POP   X
12C9: 53 9D    MOV   [__r0],A
12CB: 47 9D 20 TST   [__r0],32
12CE: AF F2    JZ    0x12C1
(0167) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
(0168) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
(0169) #define		COMMAND_TYPE_SPACE			(200)	// The number where reserved command types start.
12D0: 7C 22 28 LCALL _xmitWait
(0170) #define		HELLO_BYTE					(200)	// Indicates parent is ready to talk.
(0171) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the parent.
(0172) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is acknowledged.
12D3: 50 00    MOV   A,0
12D5: 08       PUSH  A
12D6: 50 02    MOV   A,2
12D8: 08       PUSH  A
12D9: 7C 1E 25 LCALL _configToggle
12DC: 38 FE    ADD   SP,254
12DE: 80 41    JMP   0x1320
(0173) #define		PING						(203)	// Indicates that someone is pinging someone else.
(0174) #define		CLEAR_CONFIG				(204)	// Indicates that the parent is asking for a config clear.
(0175) #define		CONFIG_CLEARED				(205)	// Indicates that a module has cleared its own config.
(0176) #define		PARENT_ID					(0)		// The parent node's ID.
(0177) #define		BROADCAST					(254)	// The broadcast ID for talking to all nodes.
12E0: 92 19    CALL  _validTransmission
12E2: 62 D0 00 MOV   REG[208],0
12E5: 3C 9D 00 CMP   [__r0],0
12E8: B0 06    JNZ   0x12EF
12EA: 3C 9C 00 CMP   [__r1],0
12ED: A0 32    JZ    0x1320
(0178) #define		BLANK_MODULE_ID				(251)	// This is the ID of an unconfigured module.
(0179) #define		SERVO_START					(255)	// The start byte of a servo.
(0180) 
12EF: 62 D0 00 MOV   REG[208],0
12F2: 3C A9 CB CMP   [COMMAND_TYPE],203
12F5: B0 2A    JNZ   0x1320
(0181) // These defines are used to fill in the instruction we are using on the servo.
(0182) #define		PING_SERVO					(1)		// This is the instruction number for ping.
(0183) #define		READ_SERVO					(2)		// This is the instruction number for a read.
12F7: 62 D0 00 MOV   REG[208],0
12FA: 3C AA 00 CMP   [COMMAND_DESTINATION],0
12FD: B0 22    JNZ   0x1320
(0184) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
(0185) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
(0186) 
12FF: 62 D0 00 MOV   REG[208],0
1302: 51 AB    MOV   A,[COMMAND_SOURCE]
1304: 62 D0 00 MOV   REG[208],0
1307: 53 9C    MOV   [__r1],A
1309: 50 00    MOV   A,0
130B: 3B FB    CMP   A,[X-5]
130D: B0 12    JNZ   0x1320
130F: 51 9C    MOV   A,[__r1]
1311: 3B FC    CMP   A,[X-4]
1313: B0 0C    JNZ   0x1320
(0187) // These defines are used for transmission timing.
(0188) #define 	RX_TIMEOUT_DURATION			(5)		// This is receive wait time in 1 ms units.
1315: 62 D0 00 MOV   REG[208],0
1318: 55 9C 01 MOV   [__r1],1
131B: 55 9D 00 MOV   [__r0],0
131E: 80 27    JMP   0x1346
1320: 62 D0 00 MOV   REG[208],0
1323: 51 9F    MOV   A,[TIMEOUT+1]
1325: 11 05    SUB   A,5
1327: 51 9E    MOV   A,[TIMEOUT]
1329: 31 80    XOR   A,128
132B: 19 80    SBB   A,128
132D: CF B2    JC    0x12E0
(0189) 
(0190) // These defines are used for the initial probing stage.
(0191) #define		INIT_WAIT_TIME				(50)	// Initial wait time between module probes.
(0192) #define		MAX_TIMEOUTS				(50)	// Number of timeouts allowed before hello mode exit.
(0193) 
(0194) // This is the maximum number of allowable modules per branch out from the parent.
(0195) #define		MAX_MODULES					(250)
132F: 10       PUSH  X
1330: 7C 09 E8 LCALL 0x09E8
1333: 20       POP   X
(0196) 
1334: 62 D0 00 MOV   REG[208],0
1337: 55 9F 00 MOV   [TIMEOUT+1],0
133A: 55 9E 00 MOV   [TIMEOUT],0
(0197) // Receives a mode identifier and toggles to that mode.
(0198) void configToggle(int mode);
133D: 62 D0 00 MOV   REG[208],0
1340: 55 9C 00 MOV   [__r1],0
1343: 55 9D 00 MOV   [__r0],0
1346: 20       POP   X
1347: 7F       RET   
(0199) // Pings the index passed to it. Returns 1 on success, 0 on fail.
(0200) int pingModule(int module_id);
(0201) // Assigns an ID to a module.
(0202) int assignID(int assigned_ID);
_assignID:
  assigned_ID          --> X-5
1348: 10       PUSH  X
1349: 4F       MOV   X,SP
(0203) // Attempts to read a valid transmission and store it.
(0204) int validTransmission(void);
134A: 50 00    MOV   A,0
134C: 08       PUSH  A
134D: 50 01    MOV   A,1
134F: 08       PUSH  A
1350: 7C 1E 25 LCALL _configToggle
1353: 38 FE    ADD   SP,254
(0205) // Reads a PC command and translates it to the correct packet type.
(0206) void decodeTransmission(void);
(0207) // Sends out a hello message packet.
1355: 10       PUSH  X
1356: 50 FC    MOV   A,252
1358: 7C 09 57 LCALL 0x0957
135B: 20       POP   X
(0208) void sayHello(void);
135C: 10       PUSH  X
135D: 50 FC    MOV   A,252
135F: 7C 08 7E LCALL 0x087E
1362: 20       POP   X
(0209) // Servo instruction function that sends read or write commands.
1363: 10       PUSH  X
1364: 50 FC    MOV   A,252
1366: 7C 09 57 LCALL 0x0957
1369: 20       POP   X
(0210) void servoInstruction(char id, char length, char instruction, char address, char value);
136A: 10       PUSH  X
136B: 50 FC    MOV   A,252
136D: 7C 08 7E LCALL 0x087E
1370: 20       POP   X
(0211) // Servo instruction function that sends long two-byte write commands.
1371: 10       PUSH  X
1372: 50 00    MOV   A,0
1374: 7C 09 57 LCALL 0x0957
1377: 20       POP   X
(0212) void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
1378: 10       PUSH  X
1379: 50 00    MOV   A,0
137B: 7C 08 7E LCALL 0x087E
137E: 20       POP   X
(0213) // Immediately performs a non-blocking read char operation, and returns 0 upon failure.
137F: 10       PUSH  X
1380: 50 FB    MOV   A,251
1382: 7C 09 57 LCALL 0x0957
1385: 20       POP   X
(0214) char iReadChar(void);
1386: 10       PUSH  X
1387: 50 FB    MOV   A,251
1389: 7C 08 7E LCALL 0x087E
138C: 20       POP   X
(0215) // Performs a blocking read char operation.
138D: 10       PUSH  X
138E: 50 C9    MOV   A,201
1390: 7C 09 57 LCALL 0x0957
1393: 20       POP   X
(0216) char readChar(void);
1394: 10       PUSH  X
1395: 50 C9    MOV   A,201
1397: 7C 08 7E LCALL 0x087E
139A: 20       POP   X
(0217) // Checks the current mode and unloads the configuration for that mode.
139B: 62 D0 00 MOV   REG[208],0
139E: 52 FC    MOV   A,[X-4]
13A0: 10       PUSH  X
13A1: 7C 09 57 LCALL 0x0957
13A4: 20       POP   X
(0218) void unloadAllConfigs(void);
13A5: 62 D0 00 MOV   REG[208],0
13A8: 52 FC    MOV   A,[X-4]
13AA: 10       PUSH  X
13AB: 7C 08 7E LCALL 0x087E
13AE: 20       POP   X
(0219) // Unloads the configuration corresponding to the number passed to it.
13AF: 10       PUSH  X
13B0: 50 FD    MOV   A,253
13B2: 7C 09 57 LCALL 0x0957
13B5: 20       POP   X
(0220) void unloadConfig(int config_num);
13B6: 10       PUSH  X
13B7: 50 FD    MOV   A,253
13B9: 7C 08 7E LCALL 0x087E
13BC: 20       POP   X
(0221) // Initialization function for the child module controllers.
13BD: 10       PUSH  X
13BE: 50 FD    MOV   A,253
13C0: 7C 09 57 LCALL 0x0957
13C3: 20       POP   X
(0222) void initializeChildren(void);
13C4: 10       PUSH  X
13C5: 50 FD    MOV   A,253
13C7: 7C 08 7E LCALL 0x087E
13CA: 20       POP   X
(0223) // Static wait time of approximately 50 microseconds for use after starting a transmission.
(0224) void xmitWait(void);
(0225) // Listen for a child and record the port value.
13CB: 10       PUSH  X
13CC: 7C 09 2A LCALL 0x092A
13CF: 62 D0 00 MOV   REG[208],0
13D2: 20       POP   X
13D3: 53 9D    MOV   [__r0],A
13D5: 47 9D 20 TST   [__r0],32
13D8: AF F2    JZ    0x13CB
(0226) void childListen(void);
13DA: 10       PUSH  X
13DB: 7C 08 51 LCALL 0x0851
13DE: 62 D0 00 MOV   REG[208],0
13E1: 20       POP   X
13E2: 53 9D    MOV   [__r0],A
13E4: 47 9D 20 TST   [__r0],32
13E7: AF F2    JZ    0x13DA
(0227) 
(0228) int TIMEOUT;				// This flag is incremented if there is a timeout.
(0229) int NUM_MODULES;			// Stores the number of modules that have been discovered.
13E9: 7C 22 28 LCALL _xmitWait
(0230) int STATE;					// Stores the current configuration state of the system.
(0231) char CHILD;					// The child port value stored from initialization.
(0232) 
13EC: 50 00    MOV   A,0
13EE: 08       PUSH  A
13EF: 50 02    MOV   A,2
13F1: 08       PUSH  A
13F2: 7C 1E 25 LCALL _configToggle
13F5: 38 FE    ADD   SP,254
13F7: 80 41    JMP   0x1439
(0233) char COMMAND_SOURCE;		// Stores who the current command is from.
(0234) char COMMAND_DESTINATION;	// Stores who the current command is for.
(0235) char COMMAND_TYPE;			// Stores the type of command that was just read.
(0236) char PARAM[10];				// Stores a parameters that accompanies the command (if any).
(0237) 
13F9: 91 00    CALL  _validTransmission
13FB: 62 D0 00 MOV   REG[208],0
13FE: 3C 9D 00 CMP   [__r0],0
1401: B0 06    JNZ   0x1408
1403: 3C 9C 00 CMP   [__r1],0
1406: A0 32    JZ    0x1439
(0238) void main()
(0239) {	
(0240) 	NUM_MODULES = 0;	// Initialize the number of modules.
1408: 62 D0 00 MOV   REG[208],0
140B: 3C A9 CA CMP   [COMMAND_TYPE],202
140E: B0 2A    JNZ   0x1439
(0241) 	STATE = 0;			// Initialize the current hardware state.
(0242) 	
(0243) 	// Activate GPIO ISR.
1410: 62 D0 00 MOV   REG[208],0
1413: 3C AA 00 CMP   [COMMAND_DESTINATION],0
1416: B0 22    JNZ   0x1439
(0244) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
(0245) 	
(0246) 	// Turn on global interrupts for the transmission timeout timer.
1418: 62 D0 00 MOV   REG[208],0
141B: 51 AB    MOV   A,[COMMAND_SOURCE]
141D: 62 D0 00 MOV   REG[208],0
1420: 53 9C    MOV   [__r1],A
1422: 50 00    MOV   A,0
1424: 3B FB    CMP   A,[X-5]
1426: B0 12    JNZ   0x1439
1428: 51 9C    MOV   A,[__r1]
142A: 3B FC    CMP   A,[X-4]
142C: B0 0C    JNZ   0x1439
(0247) 	M8C_EnableGInt;
(0248) 	
142E: 62 D0 00 MOV   REG[208],0
1431: 55 9C 01 MOV   [__r1],1
1434: 55 9D 00 MOV   [__r0],0
1437: 80 27    JMP   0x145F
1439: 62 D0 00 MOV   REG[208],0
143C: 51 9F    MOV   A,[TIMEOUT+1]
143E: 11 05    SUB   A,5
1440: 51 9E    MOV   A,[TIMEOUT]
1442: 31 80    XOR   A,128
1444: 19 80    SBB   A,128
1446: CF B2    JC    0x13F9
(0249) 	while(1)
(0250) 	{
(0251) 		// If there are no modules, find some. Otherwise, look for computer commands.
(0252) 		if(!NUM_MODULES)
(0253) 		{
(0254) 			initializeChildren();
(0255) 		}
1448: 10       PUSH  X
1449: 7C 09 E8 LCALL 0x09E8
144C: 20       POP   X
(0256) 		else if(COMP_SERIAL_bCmdCheck())
144D: 62 D0 00 MOV   REG[208],0
1450: 55 9F 00 MOV   [TIMEOUT+1],0
1453: 55 9E 00 MOV   [TIMEOUT],0
(0257) 		{
(0258) 			decodeTransmission();
1456: 62 D0 00 MOV   REG[208],0
1459: 55 9C 00 MOV   [__r1],0
145C: 55 9D 00 MOV   [__r0],0
145F: 20       POP   X
1460: 7F       RET   
(0259) 		}
(0260) 	}
(0261) }
(0262) 
(0263) int pingModule(int module_id)
(0264) {
(0265) 	// Toggle into PC mode.
_sayHello:
1461: 50 00    MOV   A,0
1463: 08       PUSH  A
1464: 50 01    MOV   A,1
1466: 08       PUSH  A
1467: 7C 1E 25 LCALL _configToggle
146A: 38 FE    ADD   SP,254
(0266) 	configToggle(PC_MODE);
(0267) 	
(0268) 	// Transmit a ping to everyone.
146C: 10       PUSH  X
146D: 50 FC    MOV   A,252
146F: 7C 09 57 LCALL 0x0957
1472: 20       POP   X
(0269) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte one
1473: 10       PUSH  X
1474: 50 FC    MOV   A,252
1476: 7C 08 7E LCALL 0x087E
1479: 20       POP   X
(0270) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte one
147A: 10       PUSH  X
147B: 50 FC    MOV   A,252
147D: 7C 09 57 LCALL 0x0957
1480: 20       POP   X
(0271) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte two
1481: 10       PUSH  X
1482: 50 FC    MOV   A,252
1484: 7C 08 7E LCALL 0x087E
1487: 20       POP   X
(0272) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte two
1488: 10       PUSH  X
1489: 50 00    MOV   A,0
148B: 7C 09 57 LCALL 0x0957
148E: 20       POP   X
(0273) 	TX_REPEATER_14_PutChar(PARENT_ID);			// My ID
148F: 10       PUSH  X
1490: 50 00    MOV   A,0
1492: 7C 08 7E LCALL 0x087E
1495: 20       POP   X
(0274) 	TX_REPEATER_23_PutChar(PARENT_ID);			// My ID
1496: 10       PUSH  X
1497: 50 FB    MOV   A,251
1499: 7C 09 57 LCALL 0x0957
149C: 20       POP   X
(0275) 	TX_REPEATER_14_PutChar(module_id);			// Destination ID
149D: 10       PUSH  X
149E: 50 FB    MOV   A,251
14A0: 7C 08 7E LCALL 0x087E
14A3: 20       POP   X
(0276) 	TX_REPEATER_23_PutChar(module_id);			// Destination ID
14A4: 10       PUSH  X
14A5: 50 C8    MOV   A,200
14A7: 7C 09 57 LCALL 0x0957
14AA: 20       POP   X
(0277) 	TX_REPEATER_14_PutChar(PING);				// This is a ping response
14AB: 10       PUSH  X
14AC: 50 C8    MOV   A,200
14AE: 7C 08 7E LCALL 0x087E
14B1: 20       POP   X
(0278) 	TX_REPEATER_23_PutChar(PING);				// This is a ping response
14B2: 10       PUSH  X
14B3: 50 FD    MOV   A,253
14B5: 7C 09 57 LCALL 0x0957
14B8: 20       POP   X
(0279) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
14B9: 10       PUSH  X
14BA: 50 FD    MOV   A,253
14BC: 7C 08 7E LCALL 0x087E
14BF: 20       POP   X
(0280) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
14C0: 10       PUSH  X
14C1: 50 FD    MOV   A,253
14C3: 7C 09 57 LCALL 0x0957
14C6: 20       POP   X
(0281) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
14C7: 10       PUSH  X
14C8: 50 FD    MOV   A,253
14CA: 7C 08 7E LCALL 0x087E
14CD: 20       POP   X
(0282) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0283) 	
(0284) 	// Wait for the transmission to finish.
14CE: 10       PUSH  X
14CF: 7C 09 2A LCALL 0x092A
14D2: 62 D0 00 MOV   REG[208],0
14D5: 20       POP   X
14D6: 53 9D    MOV   [__r0],A
14D8: 47 9D 20 TST   [__r0],32
14DB: AF F2    JZ    0x14CE
(0285) 	while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
14DD: 10       PUSH  X
14DE: 7C 08 51 LCALL 0x0851
14E1: 62 D0 00 MOV   REG[208],0
14E4: 20       POP   X
14E5: 53 9D    MOV   [__r0],A
14E7: 47 9D 20 TST   [__r0],32
14EA: AF F2    JZ    0x14DD
(0286) 	while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
(0287) 	
(0288) 	// Make completely sure we're done.
14EC: 7C 22 28 LCALL _xmitWait
(0289) 	xmitWait();
(0290) 	
(0291) 	// Switch to listening mode.
14EF: 50 00    MOV   A,0
14F1: 08       PUSH  A
14F2: 50 02    MOV   A,2
14F4: 08       PUSH  A
14F5: 7C 1E 25 LCALL _configToggle
14F8: 38 FE    ADD   SP,254
14FA: 7F       RET   
(0292) 	configToggle(RX_MODE);
(0293) 	
(0294) 	// Listen for the response.
(0295) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
(0296) 	{
_validTransmission:
  i                    --> X+1
  tempByte             --> X+0
14FB: 10       PUSH  X
14FC: 4F       MOV   X,SP
14FD: 38 03    ADD   SP,3
(0297) 		if(validTransmission())
14FF: 56 02 00 MOV   [X+2],0
1502: 56 01 00 MOV   [X+1],0
(0298) 		{
1505: 56 00 00 MOV   [X+0],0
1508: 80 9E    JMP   0x15A7
(0299) 			// If the response is what we are looking for.
(0300) 			if(COMMAND_TYPE == PING)
(0301) 			{
(0302) 				// If this is for me, check who it was from.
(0303) 				if(COMMAND_DESTINATION == PARENT_ID)
(0304) 				{
(0305) 					// If it's from the right module, return 1.
150A: 7C 21 8C LCALL _iReadChar
150D: 62 D0 00 MOV   REG[208],0
1510: 39 FC    CMP   A,252
1512: B0 94    JNZ   0x15A7
(0306) 					if(COMMAND_SOURCE == module_id)
1514: 80 83    JMP   0x1598
(0307) 					{
(0308) 						return 1;
(0309) 					}
(0310) 				}
(0311) 			}
1516: 7C 21 8C LCALL _iReadChar
1519: 54 00    MOV   [X+0],A
151B: 39 00    CMP   A,0
151D: A0 7A    JZ    0x1598
(0312) 		}
(0313) 	}
(0314) 
151F: 3D 00 FC CMP   [X+0],252
1522: A0 75    JZ    0x1598
(0315) 	RX_TIMEOUT_Stop();
(0316) 	TIMEOUT = 0;
(0317) 	
1524: 52 00    MOV   A,[X+0]
1526: 62 D0 00 MOV   REG[208],0
1529: 53 AB    MOV   [COMMAND_SOURCE],A
152B: 80 5D    JMP   0x1589
(0318) 	return 0;
(0319) }
(0320) 
(0321) int assignID(int assigned_ID)
(0322) {	
(0323) 	// Switch to PC mode.
152D: 7C 21 8C LCALL _iReadChar
1530: 62 D0 00 MOV   REG[208],0
1533: 54 00    MOV   [X+0],A
1535: 39 00    CMP   A,0
1537: A0 51    JZ    0x1589
(0324) 	configToggle(PC_MODE);
(0325) 
(0326) 	// Transmit an ID assignment.
1539: 3D 00 C8 CMP   [X+0],200
153C: C0 4C    JC    0x1589
(0327) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte one
(0328) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte one
(0329) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte two
153E: 52 00    MOV   A,[X+0]
1540: 62 D0 00 MOV   REG[208],0
1543: 53 A9    MOV   [COMMAND_TYPE],A
1545: 80 34    JMP   0x157A
(0330) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte two
(0331) 	TX_REPEATER_14_PutChar(PARENT_ID);			// My ID
(0332) 	TX_REPEATER_23_PutChar(PARENT_ID);			// My ID
(0333) 	TX_REPEATER_14_PutChar(BLANK_MODULE_ID);	// Destination ID
(0334) 	TX_REPEATER_23_PutChar(BLANK_MODULE_ID);	// Destination ID
(0335) 	TX_REPEATER_14_PutChar(ID_ASSIGNMENT);		// This is an ID assignment
1547: 7C 21 8C LCALL _iReadChar
154A: 62 D0 00 MOV   REG[208],0
154D: 54 00    MOV   [X+0],A
154F: 39 00    CMP   A,0
1551: A0 28    JZ    0x157A
(0336) 	TX_REPEATER_23_PutChar(ID_ASSIGNMENT);		// This is an ID assignment
(0337) 	TX_REPEATER_14_PutChar(assigned_ID);		// This is the new ID
(0338) 	TX_REPEATER_23_PutChar(assigned_ID);		// This is the new ID
1553: 3D 00 FD CMP   [X+0],253
1556: A0 18    JZ    0x156F
(0339) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0340) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
1558: 52 02    MOV   A,[X+2]
155A: 01 8B    ADD   A,139
155C: 53 9C    MOV   [__r1],A
155E: 52 01    MOV   A,[X+1]
1560: 09 00    ADC   A,0
1562: 60 D5    MOV   REG[213],A
1564: 52 00    MOV   A,[X+0]
1566: 3F 9C    MVI   [__r1],A
(0341) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
1568: 77 02    INC   [X+2]
156A: 0F 01 00 ADC   [X+1],0
(0342) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
156D: 80 0C    JMP   0x157A
(0343) 	
(0344) 	// Wait for the transmission to finish.
(0345) 	while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
156F: 62 D0 00 MOV   REG[208],0
1572: 55 9C 01 MOV   [__r1],1
1575: 55 9D 00 MOV   [__r0],0
1578: 80 46    JMP   0x15BF
157A: 62 D0 00 MOV   REG[208],0
157D: 51 9F    MOV   A,[TIMEOUT+1]
157F: 11 05    SUB   A,5
1581: 51 9E    MOV   A,[TIMEOUT]
1583: 31 80    XOR   A,128
1585: 19 80    SBB   A,128
1587: CF BF    JC    0x1547
1589: 62 D0 00 MOV   REG[208],0
158C: 51 9F    MOV   A,[TIMEOUT+1]
158E: 11 05    SUB   A,5
1590: 51 9E    MOV   A,[TIMEOUT]
1592: 31 80    XOR   A,128
1594: 19 80    SBB   A,128
1596: CF 96    JC    0x152D
1598: 62 D0 00 MOV   REG[208],0
159B: 51 9F    MOV   A,[TIMEOUT+1]
159D: 11 05    SUB   A,5
159F: 51 9E    MOV   A,[TIMEOUT]
15A1: 31 80    XOR   A,128
15A3: 19 80    SBB   A,128
15A5: CF 70    JC    0x1516
15A7: 62 D0 00 MOV   REG[208],0
15AA: 51 9F    MOV   A,[TIMEOUT+1]
15AC: 11 05    SUB   A,5
15AE: 51 9E    MOV   A,[TIMEOUT]
15B0: 31 80    XOR   A,128
15B2: 19 80    SBB   A,128
15B4: CF 55    JC    0x150A
(0346) 	while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
(0347) 	
(0348) 	// Make completely sure we're done.
(0349) 	xmitWait();
(0350) 	
(0351) 	// Switch to listening mode.
(0352) 	configToggle(RX_MODE);
(0353) 	
(0354) 	// Listen for the response.
(0355) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
(0356) 	{
(0357) 		if(validTransmission())
(0358) 		{
15B6: 62 D0 00 MOV   REG[208],0
15B9: 55 9C 00 MOV   [__r1],0
15BC: 55 9D 00 MOV   [__r0],0
15BF: 38 FD    ADD   SP,253
15C1: 20       POP   X
15C2: 7F       RET   
(0359) 			// If this is the response we are looking for.
(0360) 			if(COMMAND_TYPE == ID_ASSIGN_OK)
(0361) 			{
(0362) 				// If this is for me, check who it was from.
(0363) 				if(COMMAND_DESTINATION == PARENT_ID)
_decodeTransmission:
  speed                --> X+10
  angle                --> X+8
  total                --> X+6
  ID                   --> X+5
  runningTotal         --> X+3
  tempByte             --> X+2
  param                --> X+0
15C3: 10       PUSH  X
15C4: 4F       MOV   X,SP
15C5: 38 0C    ADD   SP,12
(0364) 				{
(0365) 					// If it is from the right module, return 1.
15C7: 56 05 00 MOV   [X+5],0
(0366) 					if(COMMAND_SOURCE == assigned_ID)
15CA: 56 02 00 MOV   [X+2],0
(0367) 					{
(0368) 						return 1;
(0369) 					}
15CD: 56 07 00 MOV   [X+7],0
15D0: 56 06 00 MOV   [X+6],0
(0370) 				}
15D3: 56 04 00 MOV   [X+4],0
15D6: 56 03 00 MOV   [X+3],0
(0371) 			}
(0372) 		}
(0373) 	}
15D9: 10       PUSH  X
15DA: 7C 11 96 LCALL 0x1196
15DD: 62 D0 00 MOV   REG[208],0
15E0: 53 9D    MOV   [__r0],A
15E2: 5A 9C    MOV   [__r1],X
15E4: 20       POP   X
15E5: 51 9C    MOV   A,[__r1]
15E7: 54 01    MOV   [X+1],A
15E9: 51 9D    MOV   A,[__r0]
15EB: 54 00    MOV   [X+0],A
15ED: 3C 9D 00 CMP   [__r0],0
15F0: B0 06    JNZ   0x15F7
15F2: 3C 9C 00 CMP   [__r1],0
15F5: A6 1B    JZ    0x1C11
(0374) 	
(0375) 	RX_TIMEOUT_Stop();
15F7: 62 D0 00 MOV   REG[208],0
15FA: 52 01    MOV   A,[X+1]
15FC: 53 9C    MOV   [__r1],A
15FE: 52 00    MOV   A,[X+0]
1600: 60 D4    MOV   REG[212],A
1602: 3E 9C    MVI   A,[__r1]
1604: 53 9C    MOV   [__r1],A
1606: 55 9D 00 MOV   [__r0],0
1609: 3C 9D 00 CMP   [__r0],0
160C: B0 05    JNZ   0x1612
160E: 39 78    CMP   A,120
1610: A0 0E    JZ    0x161F
1612: 62 D0 00 MOV   REG[208],0
1615: 3C 9D 00 CMP   [__r0],0
1618: B0 11    JNZ   0x162A
161A: 3C 9C 58 CMP   [__r1],88
161D: B0 0C    JNZ   0x162A
(0376) 	TIMEOUT = 0;
(0377) 	
(0378) 	return 0;
161F: 62 D0 00 MOV   REG[208],0
1622: 55 A3 00 MOV   [NUM_MODULES+1],0
1625: 55 A2 00 MOV   [NUM_MODULES],0
(0379) }
1628: 85 E8    JMP   0x1C11
(0380) 
162A: 62 D0 00 MOV   REG[208],0
162D: 52 01    MOV   A,[X+1]
162F: 53 9C    MOV   [__r1],A
1631: 52 00    MOV   A,[X+0]
1633: 60 D4    MOV   REG[212],A
1635: 3E 9C    MVI   A,[__r1]
1637: 53 9C    MOV   [__r1],A
1639: 55 9D 00 MOV   [__r0],0
163C: 3C 9D 00 CMP   [__r0],0
163F: B0 05    JNZ   0x1645
1641: 39 6E    CMP   A,110
1643: A0 0E    JZ    0x1652
1645: 62 D0 00 MOV   REG[208],0
1648: 3C 9D 00 CMP   [__r0],0
164B: B0 35    JNZ   0x1681
164D: 3C 9C 4E CMP   [__r1],78
1650: B0 30    JNZ   0x1681
(0381) // This function transmits a hello message.
(0382) void sayHello(void)
1652: 50 00    MOV   A,0
1654: 08       PUSH  A
1655: 50 0A    MOV   A,10
1657: 08       PUSH  A
1658: 62 D0 00 MOV   REG[208],0
165B: 51 A2    MOV   A,[NUM_MODULES]
165D: 08       PUSH  A
165E: 51 A3    MOV   A,[NUM_MODULES+1]
1660: 08       PUSH  A
1661: 52 00    MOV   A,[X+0]
1663: 08       PUSH  A
1664: 52 01    MOV   A,[X+1]
1666: 08       PUSH  A
1667: 7C 24 E1 LCALL _itoa
166A: 38 FA    ADD   SP,250
(0383) {
166C: 10       PUSH  X
166D: 52 00    MOV   A,[X+0]
166F: 08       PUSH  A
1670: 52 01    MOV   A,[X+1]
1672: 5C       MOV   X,A
1673: 18       POP   A
1674: 7C 10 E6 LCALL 0x10E6
1677: 20       POP   X
(0384) 	// Toggle into PC mode.
1678: 10       PUSH  X
1679: 50 0A    MOV   A,10
167B: 7C 10 A9 LCALL 0x10A9
167E: 20       POP   X
(0385) 	configToggle(PC_MODE);
167F: 85 91    JMP   0x1C11
(0386) 	
1681: 62 D0 00 MOV   REG[208],0
1684: 52 01    MOV   A,[X+1]
1686: 53 9C    MOV   [__r1],A
1688: 52 00    MOV   A,[X+0]
168A: 60 D4    MOV   REG[212],A
168C: 3E 9C    MVI   A,[__r1]
168E: 53 9C    MOV   [__r1],A
1690: 55 9D 00 MOV   [__r0],0
1693: 3C 9D 00 CMP   [__r0],0
1696: B0 05    JNZ   0x169C
1698: 39 77    CMP   A,119
169A: A0 0E    JZ    0x16A9
169C: 62 D0 00 MOV   REG[208],0
169F: 3C 9D 00 CMP   [__r0],0
16A2: B2 14    JNZ   0x18B7
16A4: 3C 9C 57 CMP   [__r1],87
16A7: B2 0F    JNZ   0x18B7
(0387) 	// Transmit an ID assignment.
(0388) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte one
16A9: 10       PUSH  X
16AA: 7C 11 96 LCALL 0x1196
16AD: 62 D0 00 MOV   REG[208],0
16B0: 53 9D    MOV   [__r0],A
16B2: 5A 9C    MOV   [__r1],X
16B4: 20       POP   X
16B5: 51 9C    MOV   A,[__r1]
16B7: 54 01    MOV   [X+1],A
16B9: 51 9D    MOV   A,[__r0]
16BB: 54 00    MOV   [X+0],A
16BD: 3C 9D 00 CMP   [__r0],0
16C0: B0 06    JNZ   0x16C7
16C2: 3C 9C 00 CMP   [__r1],0
16C5: A5 4B    JZ    0x1C11
(0389) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte one
(0390) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte two
(0391) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte two
16C7: 52 00    MOV   A,[X+0]
16C9: 08       PUSH  A
16CA: 52 01    MOV   A,[X+1]
16CC: 08       PUSH  A
16CD: 7C 23 A0 LCALL _atoi
16D0: 38 FE    ADD   SP,254
16D2: 62 D0 00 MOV   REG[208],0
16D5: 51 9C    MOV   A,[__r1]
16D7: 54 05    MOV   [X+5],A
(0392) 	TX_REPEATER_14_PutChar(PARENT_ID);			// My ID
(0393) 	TX_REPEATER_23_PutChar(PARENT_ID);			// My ID
16D9: 10       PUSH  X
16DA: 7C 11 96 LCALL 0x1196
16DD: 62 D0 00 MOV   REG[208],0
16E0: 53 9D    MOV   [__r0],A
16E2: 5A 9C    MOV   [__r1],X
16E4: 20       POP   X
16E5: 51 9C    MOV   A,[__r1]
16E7: 54 01    MOV   [X+1],A
16E9: 51 9D    MOV   A,[__r0]
16EB: 54 00    MOV   [X+0],A
16ED: 3C 9D 00 CMP   [__r0],0
16F0: B0 06    JNZ   0x16F7
16F2: 3C 9C 00 CMP   [__r1],0
16F5: A5 1B    JZ    0x1C11
(0394) 	TX_REPEATER_14_PutChar(BLANK_MODULE_ID);	// Destination ID
(0395) 	TX_REPEATER_23_PutChar(BLANK_MODULE_ID);	// Destination ID
16F7: 62 D0 00 MOV   REG[208],0
16FA: 52 01    MOV   A,[X+1]
16FC: 53 9C    MOV   [__r1],A
16FE: 52 00    MOV   A,[X+0]
1700: 60 D4    MOV   REG[212],A
1702: 3E 9C    MVI   A,[__r1]
1704: 53 9C    MOV   [__r1],A
1706: 55 9D 00 MOV   [__r0],0
1709: 3C 9D 00 CMP   [__r0],0
170C: B0 05    JNZ   0x1712
170E: 39 61    CMP   A,97
1710: A0 0E    JZ    0x171F
1712: 62 D0 00 MOV   REG[208],0
1715: 3C 9D 00 CMP   [__r0],0
1718: B0 84    JNZ   0x179D
171A: 3C 9C 41 CMP   [__r1],65
171D: B0 7F    JNZ   0x179D
(0396) 	TX_REPEATER_14_PutChar(HELLO_BYTE);		// This is a hello message
(0397) 	TX_REPEATER_23_PutChar(HELLO_BYTE);			// This is a hello message
171F: 10       PUSH  X
1720: 7C 11 96 LCALL 0x1196
1723: 62 D0 00 MOV   REG[208],0
1726: 53 9D    MOV   [__r0],A
1728: 5A 9C    MOV   [__r1],X
172A: 20       POP   X
172B: 51 9C    MOV   A,[__r1]
172D: 54 01    MOV   [X+1],A
172F: 51 9D    MOV   A,[__r0]
1731: 54 00    MOV   [X+0],A
1733: 3C 9D 00 CMP   [__r0],0
1736: B0 06    JNZ   0x173D
1738: 3C 9C 00 CMP   [__r1],0
173B: A4 D5    JZ    0x1C11
(0398) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0399) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0400) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
173D: 52 00    MOV   A,[X+0]
173F: 08       PUSH  A
1740: 52 01    MOV   A,[X+1]
1742: 08       PUSH  A
1743: 7C 23 A0 LCALL _atoi
1746: 38 FE    ADD   SP,254
1748: 62 D0 00 MOV   REG[208],0
174B: 51 9C    MOV   A,[__r1]
174D: 54 07    MOV   [X+7],A
174F: 51 9D    MOV   A,[__r0]
1751: 54 06    MOV   [X+6],A
(0401) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0402) 	
(0403) 	// Wait for the transmission to finish.
1753: 50 01    MOV   A,1
1755: 08       PUSH  A
1756: 50 00    MOV   A,0
1758: 08       PUSH  A
1759: 52 06    MOV   A,[X+6]
175B: 08       PUSH  A
175C: 52 07    MOV   A,[X+7]
175E: 08       PUSH  A
175F: 7C 23 0E LCALL __divmod_16X16_16
1762: 38 FE    ADD   SP,254
1764: 18       POP   A
1765: 53 9C    MOV   [__r1],A
1767: 18       POP   A
1768: 51 9C    MOV   A,[__r1]
176A: 54 08    MOV   [X+8],A
(0404) 	while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
176C: 50 01    MOV   A,1
176E: 08       PUSH  A
176F: 50 00    MOV   A,0
1771: 08       PUSH  A
1772: 52 06    MOV   A,[X+6]
1774: 08       PUSH  A
1775: 52 07    MOV   A,[X+7]
1777: 08       PUSH  A
1778: 7C 23 0E LCALL __divmod_16X16_16
177B: 18       POP   A
177C: 53 9C    MOV   [__r1],A
177E: 18       POP   A
177F: 38 FE    ADD   SP,254
1781: 51 9C    MOV   A,[__r1]
1783: 54 09    MOV   [X+9],A
(0405) 	while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
(0406) 	
(0407) 	// Make completely sure we're done.
1785: 52 09    MOV   A,[X+9]
1787: 08       PUSH  A
1788: 52 08    MOV   A,[X+8]
178A: 08       PUSH  A
178B: 50 1E    MOV   A,30
178D: 08       PUSH  A
178E: 50 03    MOV   A,3
1790: 08       PUSH  A
1791: 50 05    MOV   A,5
1793: 08       PUSH  A
1794: 52 05    MOV   A,[X+5]
1796: 08       PUSH  A
1797: 95 8D    CALL  _longServoInstruction
1799: 38 FA    ADD   SP,250
(0408) 	xmitWait();
(0409) 	
179B: 84 75    JMP   0x1C11
(0410) 	// Switch back to listening mode.
179D: 62 D0 00 MOV   REG[208],0
17A0: 52 01    MOV   A,[X+1]
17A2: 53 9C    MOV   [__r1],A
17A4: 52 00    MOV   A,[X+0]
17A6: 60 D4    MOV   REG[212],A
17A8: 3E 9C    MVI   A,[__r1]
17AA: 53 9C    MOV   [__r1],A
17AC: 55 9D 00 MOV   [__r0],0
17AF: 3C 9D 00 CMP   [__r0],0
17B2: B0 05    JNZ   0x17B8
17B4: 39 70    CMP   A,112
17B6: A0 0E    JZ    0x17C5
17B8: 62 D0 00 MOV   REG[208],0
17BB: 3C 9D 00 CMP   [__r0],0
17BE: B0 45    JNZ   0x1804
17C0: 3C 9C 50 CMP   [__r1],80
17C3: B0 40    JNZ   0x1804
(0411) 	configToggle(RX_MODE);
(0412) }
17C5: 10       PUSH  X
17C6: 7C 11 96 LCALL 0x1196
17C9: 62 D0 00 MOV   REG[208],0
17CC: 53 9D    MOV   [__r0],A
17CE: 5A 9C    MOV   [__r1],X
17D0: 20       POP   X
17D1: 51 9C    MOV   A,[__r1]
17D3: 54 01    MOV   [X+1],A
17D5: 51 9D    MOV   A,[__r0]
17D7: 54 00    MOV   [X+0],A
17D9: 3C 9D 00 CMP   [__r0],0
17DC: B0 06    JNZ   0x17E3
17DE: 3C 9C 00 CMP   [__r1],0
17E1: A4 2F    JZ    0x1C11
(0413) 
(0414) // This function returns whether or not a valid transmission has been received.
(0415) int validTransmission(void)
17E3: 52 00    MOV   A,[X+0]
17E5: 08       PUSH  A
17E6: 52 01    MOV   A,[X+1]
17E8: 08       PUSH  A
17E9: 7C 23 A0 LCALL _atoi
17EC: 62 D0 00 MOV   REG[208],0
17EF: 51 9C    MOV   A,[__r1]
17F1: 08       PUSH  A
17F2: 50 18    MOV   A,24
17F4: 08       PUSH  A
17F5: 50 03    MOV   A,3
17F7: 08       PUSH  A
17F8: 50 04    MOV   A,4
17FA: 08       PUSH  A
17FB: 52 05    MOV   A,[X+5]
17FD: 08       PUSH  A
17FE: 94 3C    CALL  _servoInstruction
1800: 38 F9    ADD   SP,249
(0416) {
(0417) 	int i = 0;			// Index for looping.
1802: 84 0E    JMP   0x1C11
(0418) 	char tempByte = 0;	// Temporary byte storage.
1804: 62 D0 00 MOV   REG[208],0
1807: 52 01    MOV   A,[X+1]
1809: 53 9C    MOV   [__r1],A
180B: 52 00    MOV   A,[X+0]
180D: 60 D4    MOV   REG[212],A
180F: 3E 9C    MVI   A,[__r1]
1811: 53 9C    MOV   [__r1],A
1813: 55 9D 00 MOV   [__r0],0
1816: 3C 9D 00 CMP   [__r0],0
1819: B0 05    JNZ   0x181F
181B: 39 73    CMP   A,115
181D: A0 0E    JZ    0x182C
181F: 62 D0 00 MOV   REG[208],0
1822: 3C 9D 00 CMP   [__r0],0
1825: B3 EB    JNZ   0x1C11
1827: 3C 9C 53 CMP   [__r1],83
182A: B3 E6    JNZ   0x1C11
(0419) 	
(0420) 	// These loops and conditionals are arranged in a way that allows this read
182C: 10       PUSH  X
182D: 7C 11 96 LCALL 0x1196
1830: 62 D0 00 MOV   REG[208],0
1833: 53 9D    MOV   [__r0],A
1835: 5A 9C    MOV   [__r1],X
1837: 20       POP   X
1838: 51 9C    MOV   A,[__r1]
183A: 54 01    MOV   [X+1],A
183C: 51 9D    MOV   A,[__r0]
183E: 54 00    MOV   [X+0],A
1840: 3C 9D 00 CMP   [__r0],0
1843: B0 06    JNZ   0x184A
1845: 3C 9C 00 CMP   [__r1],0
1848: A3 C8    JZ    0x1C11
(0421) 	// operation to be completely non-blocking.
(0422) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
(0423) 	{
184A: 52 00    MOV   A,[X+0]
184C: 08       PUSH  A
184D: 52 01    MOV   A,[X+1]
184F: 08       PUSH  A
1850: 7C 23 A0 LCALL _atoi
1853: 38 FE    ADD   SP,254
1855: 62 D0 00 MOV   REG[208],0
1858: 51 9C    MOV   A,[__r1]
185A: 54 07    MOV   [X+7],A
185C: 51 9D    MOV   A,[__r0]
185E: 54 06    MOV   [X+6],A
(0424) 		// Wait until we read a start transmit byte.
(0425) 		if(iReadChar() == START_TRANSMIT)
(0426) 		{
1860: 3D 06 00 CMP   [X+6],0
1863: B0 06    JNZ   0x186A
1865: 3D 07 00 CMP   [X+7],0
1868: A3 A8    JZ    0x1C11
(0427) 			// While we haven't timed out, look for something other than a start byte.
(0428) 			while(TIMEOUT < RX_TIMEOUT_DURATION)
(0429) 			{
186A: 62 D0 00 MOV   REG[208],0
186D: 50 01    MOV   A,1
186F: 08       PUSH  A
1870: 50 00    MOV   A,0
1872: 08       PUSH  A
1873: 52 06    MOV   A,[X+6]
1875: 08       PUSH  A
1876: 52 07    MOV   A,[X+7]
1878: 08       PUSH  A
1879: 7C 23 0E LCALL __divmod_16X16_16
187C: 38 FE    ADD   SP,254
187E: 18       POP   A
187F: 53 9C    MOV   [__r1],A
1881: 18       POP   A
1882: 51 9C    MOV   A,[__r1]
1884: 54 0A    MOV   [X+10],A
(0430) 				// If we find a nonzero byte...
1886: 50 01    MOV   A,1
1888: 08       PUSH  A
1889: 50 00    MOV   A,0
188B: 08       PUSH  A
188C: 52 06    MOV   A,[X+6]
188E: 08       PUSH  A
188F: 52 07    MOV   A,[X+7]
1891: 08       PUSH  A
1892: 7C 23 0E LCALL __divmod_16X16_16
1895: 18       POP   A
1896: 53 9C    MOV   [__r1],A
1898: 18       POP   A
1899: 38 FE    ADD   SP,254
189B: 51 9C    MOV   A,[__r1]
189D: 54 0B    MOV   [X+11],A
(0431) 				if(tempByte = iReadChar())
(0432) 				{
(0433) 					// If the byte we found isn't a start byte...
189F: 52 0B    MOV   A,[X+11]
18A1: 08       PUSH  A
18A2: 52 0A    MOV   A,[X+10]
18A4: 08       PUSH  A
18A5: 50 20    MOV   A,32
18A7: 08       PUSH  A
18A8: 50 03    MOV   A,3
18AA: 08       PUSH  A
18AB: 50 05    MOV   A,5
18AD: 08       PUSH  A
18AE: 52 05    MOV   A,[X+5]
18B0: 08       PUSH  A
18B1: 94 73    CALL  _longServoInstruction
18B3: 38 FA    ADD   SP,250
(0434) 					if(tempByte != START_TRANSMIT)
(0435) 					{
(0436) 						// This byte is probably the command source.
(0437) 						COMMAND_SOURCE = tempByte;
(0438) 						
(0439) 						// Look for the rest of the command before we time out.
18B5: 83 5B    JMP   0x1C11
(0440) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
18B7: 62 D0 00 MOV   REG[208],0
18BA: 52 01    MOV   A,[X+1]
18BC: 53 9C    MOV   [__r1],A
18BE: 52 00    MOV   A,[X+0]
18C0: 60 D4    MOV   REG[212],A
18C2: 3E 9C    MVI   A,[__r1]
18C4: 53 9C    MOV   [__r1],A
18C6: 55 9D 00 MOV   [__r0],0
18C9: 3C 9D 00 CMP   [__r0],0
18CC: B0 05    JNZ   0x18D2
18CE: 39 72    CMP   A,114
18D0: A0 0E    JZ    0x18DF
18D2: 62 D0 00 MOV   REG[208],0
18D5: 3C 9D 00 CMP   [__r0],0
18D8: B3 38    JNZ   0x1C11
18DA: 3C 9C 52 CMP   [__r1],82
18DD: B3 33    JNZ   0x1C11
(0441) 						{
(0442) 							// If we read another nonzero byte...
18DF: 10       PUSH  X
18E0: 7C 11 96 LCALL 0x1196
18E3: 62 D0 00 MOV   REG[208],0
18E6: 53 9D    MOV   [__r0],A
18E8: 5A 9C    MOV   [__r1],X
18EA: 20       POP   X
18EB: 51 9C    MOV   A,[__r1]
18ED: 54 01    MOV   [X+1],A
18EF: 51 9D    MOV   A,[__r0]
18F1: 54 00    MOV   [X+0],A
18F3: 3C 9D 00 CMP   [__r0],0
18F6: B0 06    JNZ   0x18FD
18F8: 3C 9C 00 CMP   [__r1],0
18FB: A3 15    JZ    0x1C11
(0443) 							if(tempByte = iReadChar())
(0444) 							{
(0445) 								// If that byte is in the command type indicator space...
18FD: 52 00    MOV   A,[X+0]
18FF: 08       PUSH  A
1900: 52 01    MOV   A,[X+1]
1902: 08       PUSH  A
1903: 7C 23 A0 LCALL _atoi
1906: 38 FE    ADD   SP,254
1908: 62 D0 00 MOV   REG[208],0
190B: 51 9C    MOV   A,[__r1]
190D: 54 05    MOV   [X+5],A
(0446) 								if(tempByte >= COMMAND_TYPE_SPACE)
(0447) 								{
190F: 10       PUSH  X
1910: 7C 11 96 LCALL 0x1196
1913: 62 D0 00 MOV   REG[208],0
1916: 53 9D    MOV   [__r0],A
1918: 5A 9C    MOV   [__r1],X
191A: 20       POP   X
191B: 51 9C    MOV   A,[__r1]
191D: 54 01    MOV   [X+1],A
191F: 51 9D    MOV   A,[__r0]
1921: 54 00    MOV   [X+0],A
1923: 3C 9D 00 CMP   [__r0],0
1926: B0 06    JNZ   0x192D
1928: 3C 9C 00 CMP   [__r1],0
192B: A2 E5    JZ    0x1C11
(0448) 									// Store the command type.
(0449) 									COMMAND_TYPE = tempByte;
192D: 62 D0 00 MOV   REG[208],0
1930: 52 01    MOV   A,[X+1]
1932: 53 9C    MOV   [__r1],A
1934: 52 00    MOV   A,[X+0]
1936: 60 D4    MOV   REG[212],A
1938: 3E 9C    MVI   A,[__r1]
193A: 53 9C    MOV   [__r1],A
193C: 55 9D 00 MOV   [__r0],0
193F: 3C 9D 00 CMP   [__r0],0
1942: B0 05    JNZ   0x1948
1944: 39 61    CMP   A,97
1946: A0 0E    JZ    0x1955
1948: 62 D0 00 MOV   REG[208],0
194B: 3C 9D 00 CMP   [__r0],0
194E: B0 C7    JNZ   0x1A16
1950: 3C 9C 41 CMP   [__r1],65
1953: B0 C2    JNZ   0x1A16
(0450) 									
(0451) 									// Continue reading if we have not timed out yet.
(0452) 									while(TIMEOUT < RX_TIMEOUT_DURATION)
1955: 56 08 00 MOV   [X+8],0
(0453) 									{
1958: 56 09 00 MOV   [X+9],0
(0454) 										// If we read a nonzero byte...
(0455) 										if(tempByte = iReadChar())
(0456) 										{
195B: 50 02    MOV   A,2
195D: 08       PUSH  A
195E: 50 24    MOV   A,36
1960: 08       PUSH  A
1961: 50 02    MOV   A,2
1963: 08       PUSH  A
1964: 50 04    MOV   A,4
1966: 08       PUSH  A
1967: 52 05    MOV   A,[X+5]
1969: 08       PUSH  A
196A: 92 D0    CALL  _servoInstruction
(0457) 											// Store the parameter if it is not the end indicator.
(0458) 											if(tempByte != END_TRANSMIT)
(0459) 											{
196C: 50 00    MOV   A,0
196E: 08       PUSH  A
196F: 50 02    MOV   A,2
1971: 08       PUSH  A
1972: 94 B1    CALL  _configToggle
1974: 38 F9    ADD   SP,249
1976: 80 8E    JMP   0x1A05
(0460) 												PARAM[i] = tempByte;
(0461) 												i++;
(0462) 											}
(0463) 											else
(0464) 											{
(0465) 												return 1;
1978: 7C 21 8C LCALL _iReadChar
197B: 62 D0 00 MOV   REG[208],0
197E: 3B 05    CMP   A,[X+5]
1980: B0 84    JNZ   0x1A05
(0466) 											}
1982: 80 73    JMP   0x19F6
(0467) 										}
(0468) 									}
(0469) 								}
(0470) 							}
1984: 7C 21 8C LCALL _iReadChar
1987: 62 D0 00 MOV   REG[208],0
198A: 39 04    CMP   A,4
198C: B0 69    JNZ   0x19F6
(0471) 						}
(0472) 					}
(0473) 				}
198E: 7C 21 DA LCALL _readChar
1991: 62 D0 00 MOV   REG[208],0
1994: 39 00    CMP   A,0
1996: B0 56    JNZ   0x19ED
(0474) 			}
(0475) 		}
(0476) 	}
1998: 7C 21 DA LCALL _readChar
199B: 62 D0 00 MOV   REG[208],0
199E: 54 08    MOV   [X+8],A
(0477) 	
19A0: 7C 21 DA LCALL _readChar
19A3: 62 D0 00 MOV   REG[208],0
19A6: 54 09    MOV   [X+9],A
(0478) 	return 0;
(0479) }
(0480) 
19A8: 50 00    MOV   A,0
19AA: 08       PUSH  A
19AB: 50 01    MOV   A,1
19AD: 08       PUSH  A
19AE: 94 75    CALL  _configToggle
(0481) // This function decodes the transmission and takes the correct action.
(0482) void decodeTransmission(void)
(0483) {
19B0: 52 08    MOV   A,[X+8]
19B2: 54 07    MOV   [X+7],A
19B4: 52 09    MOV   A,[X+9]
19B6: 54 06    MOV   [X+6],A
(0484) 	char* param;			// Stores the most recent parameter from the buffer.
(0485) 	char ID = 0;			// Stores the target module ID.
(0486) 	char tempByte = 0;		// Temporary byte storage.
19B8: 50 00    MOV   A,0
19BA: 08       PUSH  A
19BB: 50 0A    MOV   A,10
19BD: 08       PUSH  A
19BE: 52 06    MOV   A,[X+6]
19C0: 08       PUSH  A
19C1: 52 07    MOV   A,[X+7]
19C3: 08       PUSH  A
19C4: 52 00    MOV   A,[X+0]
19C6: 08       PUSH  A
19C7: 52 01    MOV   A,[X+1]
19C9: 08       PUSH  A
19CA: 7C 24 E1 LCALL _itoa
19CD: 38 F8    ADD   SP,248
(0487) 	char angle[2];			// Store the two angle bytes for the servo.
(0488) 	char speed[2];			// Store the two speed bytes for the servo.
(0489) 	int total = 0;			// Used to store the converted total of angle or speed bytes.
19CF: 10       PUSH  X
19D0: 52 00    MOV   A,[X+0]
19D2: 08       PUSH  A
19D3: 52 01    MOV   A,[X+1]
19D5: 5C       MOV   X,A
19D6: 18       POP   A
19D7: 7C 10 E6 LCALL 0x10E6
19DA: 20       POP   X
(0490) 	int runningTotal = 0;	// Used as part of the dynamic checksum calculation.
19DB: 10       PUSH  X
19DC: 50 0A    MOV   A,10
19DE: 7C 10 A9 LCALL 0x10A9
19E1: 20       POP   X
(0491) 	
(0492) 	// Read a parameter from the buffer.
(0493) 	if(param = COMP_SERIAL_szGetParam())
19E2: 62 D0 00 MOV   REG[208],0
19E5: 55 9F 05 MOV   [TIMEOUT+1],5
19E8: 55 9E 00 MOV   [TIMEOUT],0
(0494) 	{
19EB: 80 0A    JMP   0x19F6
(0495) 		if((param[0] == 'x') || (param[0] == 'X'))
(0496) 		{
(0497) 			// Reset the robot.
(0498) 			NUM_MODULES = 0;
19ED: 62 D0 00 MOV   REG[208],0
19F0: 55 9F 05 MOV   [TIMEOUT+1],5
19F3: 55 9E 00 MOV   [TIMEOUT],0
19F6: 62 D0 00 MOV   REG[208],0
19F9: 51 9F    MOV   A,[TIMEOUT+1]
19FB: 11 05    SUB   A,5
19FD: 51 9E    MOV   A,[TIMEOUT]
19FF: 31 80    XOR   A,128
1A01: 19 80    SBB   A,128
1A03: CF 80    JC    0x1984
1A05: 62 D0 00 MOV   REG[208],0
1A08: 51 9F    MOV   A,[TIMEOUT+1]
1A0A: 11 05    SUB   A,5
1A0C: 51 9E    MOV   A,[TIMEOUT]
1A0E: 31 80    XOR   A,128
1A10: 19 80    SBB   A,128
1A12: CF 65    JC    0x1978
(0499) 		}
(0500) 		else if((param[0] == 'n') || (param[0] == 'N'))
(0501) 		{
(0502) 			itoa(param,NUM_MODULES,10);		// Convert the NUM_MODULES int to a char array.
(0503) 			COMP_SERIAL_PutString(param);	// Send that array out to the PC.
(0504) 			COMP_SERIAL_PutChar('\n');		// End the transmission with the PC.
1A14: 81 FC    JMP   0x1C11
(0505) 		}
1A16: 62 D0 00 MOV   REG[208],0
1A19: 52 01    MOV   A,[X+1]
1A1B: 53 9C    MOV   [__r1],A
1A1D: 52 00    MOV   A,[X+0]
1A1F: 60 D4    MOV   REG[212],A
1A21: 3E 9C    MVI   A,[__r1]
1A23: 53 9C    MOV   [__r1],A
1A25: 55 9D 00 MOV   [__r0],0
1A28: 3C 9D 00 CMP   [__r0],0
1A2B: B0 05    JNZ   0x1A31
1A2D: 39 70    CMP   A,112
1A2F: A0 0E    JZ    0x1A3E
1A31: 62 D0 00 MOV   REG[208],0
1A34: 3C 9D 00 CMP   [__r0],0
1A37: B0 E6    JNZ   0x1B1E
1A39: 3C 9C 50 CMP   [__r1],80
1A3C: B0 E1    JNZ   0x1B1E
(0506) 		else if((param[0] == 'w') || (param[0] == 'W'))
(0507) 		{
(0508) 			if(param = COMP_SERIAL_szGetParam())
1A3E: 50 01    MOV   A,1
1A40: 08       PUSH  A
1A41: 50 18    MOV   A,24
1A43: 08       PUSH  A
1A44: 50 02    MOV   A,2
1A46: 08       PUSH  A
1A47: 50 04    MOV   A,4
1A49: 08       PUSH  A
1A4A: 52 05    MOV   A,[X+5]
1A4C: 08       PUSH  A
1A4D: 91 ED    CALL  _servoInstruction
(0509) 			{
(0510) 				// Convert the ID parameter to a char byte.
(0511) 				ID = atoi(param);
1A4F: 50 00    MOV   A,0
1A51: 08       PUSH  A
1A52: 50 02    MOV   A,2
1A54: 08       PUSH  A
1A55: 93 CE    CALL  _configToggle
1A57: 38 F9    ADD   SP,249
1A59: 80 B3    JMP   0x1B0D
(0512) 				
(0513) 				if(param = COMP_SERIAL_szGetParam())
(0514) 				{
(0515) 					if((param[0] == 'a') || (param[0] == 'A'))
(0516) 					{
1A5B: 97 2F    CALL  _iReadChar
1A5D: 62 D0 00 MOV   REG[208],0
1A60: 3B 05    CMP   A,[X+5]
1A62: B0 AA    JNZ   0x1B0D
(0517) 						if(param = COMP_SERIAL_szGetParam())
(0518) 						{
1A64: 52 05    MOV   A,[X+5]
1A66: 54 04    MOV   [X+4],A
1A68: 56 03 00 MOV   [X+3],0
1A6B: 80 92    JMP   0x1AFE
(0519) 							// Get the angle parameter and convert it to an integer.
(0520) 							total = atoi(param);
(0521) 							
(0522) 							// Convert the integer into bytes.
(0523) 							angle[0] = total%256;
1A6D: 97 1D    CALL  _iReadChar
1A6F: 62 D0 00 MOV   REG[208],0
1A72: 39 03    CMP   A,3
1A74: B0 89    JNZ   0x1AFE
(0524) 							angle[1] = total/256;
(0525) 							
(0526) 							// Send the servo the angle.
1A76: 07 04 03 ADD   [X+4],3
1A79: 0F 03 00 ADC   [X+3],0
1A7C: 80 72    JMP   0x1AEF
(0527) 							longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
(0528) 						}
(0529) 					}
(0530) 					else if((param[0] == 'p') || (param[0] == 'P'))
(0531) 					{
(0532) 						if(param = COMP_SERIAL_szGetParam())
1A7E: 97 0C    CALL  _iReadChar
1A80: 62 D0 00 MOV   REG[208],0
1A83: 54 02    MOV   [X+2],A
1A85: 39 00    CMP   A,0
1A87: A0 67    JZ    0x1AEF
(0533) 						{
(0534) 							// Send the servo the desired power value.
(0535) 							servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
1A89: 50 00    MOV   A,0
1A8B: 08       PUSH  A
1A8C: 50 01    MOV   A,1
1A8E: 08       PUSH  A
1A8F: 93 94    CALL  _configToggle
1A91: 38 FE    ADD   SP,254
(0536) 						}
(0537) 					}
1A93: 62 D0 00 MOV   REG[208],0
1A96: 52 02    MOV   A,[X+2]
1A98: 53 9C    MOV   [__r1],A
1A9A: 55 9D 00 MOV   [__r0],0
1A9D: 50 FF    MOV   A,255
1A9F: 12 9C    SUB   A,[__r1]
1AA1: 53 9C    MOV   [__r1],A
1AA3: 50 00    MOV   A,0
1AA5: 1A 9D    SBB   A,[__r0]
1AA7: 53 9D    MOV   [__r0],A
1AA9: 50 01    MOV   A,1
1AAB: 08       PUSH  A
1AAC: 50 00    MOV   A,0
1AAE: 08       PUSH  A
1AAF: 52 03    MOV   A,[X+3]
1AB1: 08       PUSH  A
1AB2: 52 04    MOV   A,[X+4]
1AB4: 08       PUSH  A
1AB5: 7C 23 0E LCALL __divmod_16X16_16
1AB8: 38 FE    ADD   SP,254
1ABA: 18       POP   A
1ABB: 53 9A    MOV   [__r3],A
1ABD: 18       POP   A
1ABE: 3A 9D    CMP   A,[__r0]
1AC0: B0 17    JNZ   0x1AD8
1AC2: 51 9A    MOV   A,[__r3]
1AC4: 3A 9C    CMP   A,[__r1]
1AC6: B0 11    JNZ   0x1AD8
(0538) 					else if((param[0] == 's') || (param[0] == 'S'))
(0539) 					{
(0540) 						if(param = COMP_SERIAL_szGetParam())
1AC8: 10       PUSH  X
1AC9: 50 30    MOV   A,48
1ACB: 7C 10 A9 LCALL 0x10A9
1ACE: 20       POP   X
(0541) 						{
1ACF: 10       PUSH  X
1AD0: 50 0A    MOV   A,10
1AD2: 7C 10 A9 LCALL 0x10A9
1AD5: 20       POP   X
(0542) 							// Get the speed parameter and convert it to an integer.
1AD6: 80 0F    JMP   0x1AE6
(0543) 							total = atoi(param);
(0544) 							
(0545) 							// If no total, do nothing because 0 is no speed control (undesired).
(0546) 							if(total)
1AD8: 10       PUSH  X
1AD9: 50 31    MOV   A,49
1ADB: 7C 10 A9 LCALL 0x10A9
1ADE: 20       POP   X
(0547) 							{
1ADF: 10       PUSH  X
1AE0: 50 0A    MOV   A,10
1AE2: 7C 10 A9 LCALL 0x10A9
1AE5: 20       POP   X
(0548) 								// Convert the integer into bytes.
(0549) 								speed[0] = total%256;
(0550) 								speed[1] = total/256;
1AE6: 62 D0 00 MOV   REG[208],0
1AE9: 55 9F 05 MOV   [TIMEOUT+1],5
1AEC: 55 9E 00 MOV   [TIMEOUT],0
1AEF: 62 D0 00 MOV   REG[208],0
1AF2: 51 9F    MOV   A,[TIMEOUT+1]
1AF4: 11 05    SUB   A,5
1AF6: 51 9E    MOV   A,[TIMEOUT]
1AF8: 31 80    XOR   A,128
1AFA: 19 80    SBB   A,128
1AFC: CF 81    JC    0x1A7E
1AFE: 62 D0 00 MOV   REG[208],0
1B01: 51 9F    MOV   A,[TIMEOUT+1]
1B03: 11 05    SUB   A,5
1B05: 51 9E    MOV   A,[TIMEOUT]
1B07: 31 80    XOR   A,128
1B09: 19 80    SBB   A,128
1B0B: CF 61    JC    0x1A6D
1B0D: 62 D0 00 MOV   REG[208],0
1B10: 51 9F    MOV   A,[TIMEOUT+1]
1B12: 11 05    SUB   A,5
1B14: 51 9E    MOV   A,[TIMEOUT]
1B16: 31 80    XOR   A,128
1B18: 19 80    SBB   A,128
1B1A: CF 40    JC    0x1A5B
(0551) 								
(0552) 								// Write the speed value to the servo.
(0553) 								longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
(0554) 							}
(0555) 						}
(0556) 					}
(0557) 				}
1B1C: 80 F4    JMP   0x1C11
(0558) 			}
1B1E: 62 D0 00 MOV   REG[208],0
1B21: 52 01    MOV   A,[X+1]
1B23: 53 9C    MOV   [__r1],A
1B25: 52 00    MOV   A,[X+0]
1B27: 60 D4    MOV   REG[212],A
1B29: 3E 9C    MVI   A,[__r1]
1B2B: 53 9C    MOV   [__r1],A
1B2D: 55 9D 00 MOV   [__r0],0
1B30: 3C 9D 00 CMP   [__r0],0
1B33: B0 05    JNZ   0x1B39
1B35: 39 74    CMP   A,116
1B37: A0 0E    JZ    0x1B46
1B39: 62 D0 00 MOV   REG[208],0
1B3C: 3C 9D 00 CMP   [__r0],0
1B3F: B0 57    JNZ   0x1B97
1B41: 3C 9C 54 CMP   [__r1],84
1B44: B0 52    JNZ   0x1B97
(0559) 		}
(0560) 		else if((param[0] == 'r') || (param[0] == 'R'))
(0561) 		{			
(0562) 			if(param = COMP_SERIAL_szGetParam())
1B46: 3D 05 00 CMP   [X+5],0
1B49: B0 11    JNZ   0x1B5B
(0563) 			{
(0564) 				// Extract the target ID param and convert it to an integer.
1B4B: 10       PUSH  X
1B4C: 50 32    MOV   A,50
1B4E: 7C 10 A9 LCALL 0x10A9
1B51: 20       POP   X
(0565) 				ID = atoi(param);
1B52: 10       PUSH  X
1B53: 50 0A    MOV   A,10
1B55: 7C 10 A9 LCALL 0x10A9
1B58: 20       POP   X
(0566) 				
1B59: 80 B7    JMP   0x1C11
(0567) 				if(param = COMP_SERIAL_szGetParam())
1B5B: 62 D0 00 MOV   REG[208],0
1B5E: 52 05    MOV   A,[X+5]
1B60: 53 9C    MOV   [__r1],A
1B62: 50 00    MOV   A,0
1B64: 08       PUSH  A
1B65: 51 9C    MOV   A,[__r1]
1B67: 08       PUSH  A
1B68: 7C 12 3D LCALL _pingModule
1B6B: 38 FE    ADD   SP,254
1B6D: 62 D0 00 MOV   REG[208],0
1B70: 3C 9D 00 CMP   [__r0],0
1B73: B0 06    JNZ   0x1B7A
1B75: 3C 9C 00 CMP   [__r1],0
1B78: A0 98    JZ    0x1C11
(0568) 				{
(0569) 					if((param[0] == 'a') || (param[0] == 'A'))
1B7A: 50 00    MOV   A,0
1B7C: 08       PUSH  A
1B7D: 50 01    MOV   A,1
1B7F: 08       PUSH  A
1B80: 92 A3    CALL  _configToggle
1B82: 38 FE    ADD   SP,254
(0570) 					{
(0571) 						// Initialize the angle bytes to 0.
1B84: 10       PUSH  X
1B85: 62 D0 00 MOV   REG[208],0
1B88: 51 8B    MOV   A,[PARAM]
1B8A: 7C 10 A9 LCALL 0x10A9
1B8D: 20       POP   X
(0572) 						angle[0] = 0;
1B8E: 10       PUSH  X
1B8F: 50 0A    MOV   A,10
1B91: 7C 10 A9 LCALL 0x10A9
1B94: 20       POP   X
(0573) 						angle[1] = 0;
(0574) 						
1B95: 80 7B    JMP   0x1C11
(0575) 						// Send a request to the servo for its angle.
1B97: 62 D0 00 MOV   REG[208],0
1B9A: 52 01    MOV   A,[X+1]
1B9C: 53 9C    MOV   [__r1],A
1B9E: 52 00    MOV   A,[X+0]
1BA0: 60 D4    MOV   REG[212],A
1BA2: 3E 9C    MVI   A,[__r1]
1BA4: 53 9C    MOV   [__r1],A
1BA6: 55 9D 00 MOV   [__r0],0
1BA9: 3C 9D 00 CMP   [__r0],0
1BAC: B0 05    JNZ   0x1BB2
1BAE: 39 63    CMP   A,99
1BB0: A0 0E    JZ    0x1BBF
1BB2: 62 D0 00 MOV   REG[208],0
1BB5: 3C 9D 00 CMP   [__r0],0
1BB8: B0 58    JNZ   0x1C11
1BBA: 3C 9C 43 CMP   [__r1],67
1BBD: B0 53    JNZ   0x1C11
(0576) 						servoInstruction(ID,4,READ_SERVO,36,2);
(0577) 						
(0578) 						// Switch to read the response.
(0579) 						configToggle(RX_MODE);
1BBF: 3D 05 00 CMP   [X+5],0
1BC2: B0 14    JNZ   0x1BD7
(0580) 							
(0581) 						// Loop until we read a response or time out.
1BC4: 10       PUSH  X
1BC5: 62 D0 00 MOV   REG[208],0
1BC8: 51 AC    MOV   A,[CHILD]
1BCA: 7C 10 A9 LCALL 0x10A9
1BCD: 20       POP   X
(0582) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
1BCE: 10       PUSH  X
1BCF: 50 0A    MOV   A,10
1BD1: 7C 10 A9 LCALL 0x10A9
1BD4: 20       POP   X
(0583) 						{
1BD5: 80 3B    JMP   0x1C11
(0584) 							// If the response is from the right ID...
1BD7: 62 D0 00 MOV   REG[208],0
1BDA: 52 05    MOV   A,[X+5]
1BDC: 53 9C    MOV   [__r1],A
1BDE: 50 00    MOV   A,0
1BE0: 08       PUSH  A
1BE1: 51 9C    MOV   A,[__r1]
1BE3: 08       PUSH  A
1BE4: 7C 12 3D LCALL _pingModule
1BE7: 38 FE    ADD   SP,254
1BE9: 62 D0 00 MOV   REG[208],0
1BEC: 3C 9D 00 CMP   [__r0],0
1BEF: B0 06    JNZ   0x1BF6
1BF1: 3C 9C 00 CMP   [__r1],0
1BF4: A0 1C    JZ    0x1C11
(0585) 							if(iReadChar() == ID)
(0586) 							{
1BF6: 50 00    MOV   A,0
1BF8: 08       PUSH  A
1BF9: 50 01    MOV   A,1
1BFB: 08       PUSH  A
1BFC: 92 27    CALL  _configToggle
1BFE: 38 FE    ADD   SP,254
(0587) 								while(TIMEOUT < RX_TIMEOUT_DURATION)
(0588) 								{
1C00: 10       PUSH  X
1C01: 62 D0 00 MOV   REG[208],0
1C04: 51 8C    MOV   A,[PARAM+1]
1C06: 7C 10 A9 LCALL 0x10A9
1C09: 20       POP   X
(0589) 									// The length of the response remainder should be 4.
1C0A: 10       PUSH  X
1C0B: 50 0A    MOV   A,10
1C0D: 7C 10 A9 LCALL 0x10A9
1C10: 20       POP   X
(0590) 									if(iReadChar() == 4)
(0591) 									{
(0592) 										// The error value should be 0 if successful.
(0593) 										if(readChar() == 0)
(0594) 										{
(0595) 											// Grab the bytes from the buffer.
(0596) 											angle[0] = readChar();
(0597) 											angle[1] = readChar();
(0598) 											
1C11: 62 D0 00 MOV   REG[208],0
1C14: 3C A0 00 CMP   [STATE],0
1C17: B0 06    JNZ   0x1C1E
1C19: 3C A1 01 CMP   [STATE+1],1
1C1C: A0 0D    JZ    0x1C2A
(0599) 											// Switch to PC mode to forward the response.
(0600) 											configToggle(PC_MODE);
1C1E: 50 00    MOV   A,0
1C20: 08       PUSH  A
1C21: 50 01    MOV   A,1
1C23: 08       PUSH  A
1C24: 91 FF    CALL  _configToggle
1C26: 38 FE    ADD   SP,254
(0601) 											
1C28: 80 0F    JMP   0x1C38
(0602) 											// Convert the bytes to an integer.
(0603) 											total = ((angle[1])*256) + angle[0];
(0604) 											
1C2A: 62 D0 00 MOV   REG[208],0
1C2D: 55 9F 00 MOV   [TIMEOUT+1],0
1C30: 55 9E 00 MOV   [TIMEOUT],0
(0605) 											// Convert the integer to a character array.
1C33: 10       PUSH  X
1C34: 7C 11 67 LCALL 0x1167
1C37: 20       POP   X
(0606) 											itoa(param,total,10);
1C38: 38 F4    ADD   SP,244
1C3A: 20       POP   X
1C3B: 7F       RET   
(0607) 											
(0608) 											// Write the response to the computer.
(0609) 											COMP_SERIAL_PutString(param);
(0610) 											COMP_SERIAL_PutChar('\n');
(0611) 
(0612) 											// Force a timeout to exit all loops.
_servoInstruction:
  total                --> X+1
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
1C3C: 10       PUSH  X
1C3D: 4F       MOV   X,SP
1C3E: 38 03    ADD   SP,3
(0613) 											TIMEOUT = RX_TIMEOUT_DURATION;
(0614) 										}
(0615) 										else
(0616) 										{
(0617) 											// Force a timeout to exit all loops.
1C40: 62 D0 00 MOV   REG[208],0
1C43: 52 FB    MOV   A,[X-5]
1C45: 53 9C    MOV   [__r1],A
1C47: 55 9D 00 MOV   [__r0],0
1C4A: 52 FC    MOV   A,[X-4]
1C4C: 02 9C    ADD   A,[__r1]
1C4E: 53 9C    MOV   [__r1],A
1C50: 50 00    MOV   A,0
1C52: 0A 9D    ADC   A,[__r0]
1C54: 53 9D    MOV   [__r0],A
1C56: 52 FA    MOV   A,[X-6]
1C58: 04 9C    ADD   [__r1],A
1C5A: 0E 9D 00 ADC   [__r0],0
1C5D: 52 F9    MOV   A,[X-7]
1C5F: 04 9C    ADD   [__r1],A
1C61: 0E 9D 00 ADC   [__r0],0
1C64: 52 F8    MOV   A,[X-8]
1C66: 53 9A    MOV   [__r3],A
1C68: 55 9B 00 MOV   [__r2],0
1C6B: 51 9C    MOV   A,[__r1]
1C6D: 02 9A    ADD   A,[__r3]
1C6F: 54 02    MOV   [X+2],A
1C71: 51 9D    MOV   A,[__r0]
1C73: 0A 9B    ADC   A,[__r2]
1C75: 54 01    MOV   [X+1],A
(0618) 											TIMEOUT = RX_TIMEOUT_DURATION;
(0619) 										}
(0620) 									}
1C77: 50 01    MOV   A,1
1C79: 08       PUSH  A
1C7A: 50 00    MOV   A,0
1C7C: 08       PUSH  A
1C7D: 52 01    MOV   A,[X+1]
1C7F: 08       PUSH  A
1C80: 52 02    MOV   A,[X+2]
1C82: 08       PUSH  A
1C83: 7C 23 0E LCALL __divmod_16X16_16
1C86: 38 FE    ADD   SP,254
1C88: 18       POP   A
1C89: 53 9C    MOV   [__r1],A
1C8B: 18       POP   A
1C8C: 50 FF    MOV   A,255
1C8E: 12 9C    SUB   A,[__r1]
1C90: 54 00    MOV   [X+0],A
(0621) 								}
(0622) 							}
(0623) 						}
1C92: 10       PUSH  X
1C93: 50 FF    MOV   A,255
1C95: 7C 09 57 LCALL 0x0957
1C98: 20       POP   X
(0624) 					}
1C99: 10       PUSH  X
1C9A: 50 FF    MOV   A,255
1C9C: 7C 08 7E LCALL 0x087E
1C9F: 20       POP   X
(0625) 					else if ((param[0] == 'p') || (param[0] == 'P'))
1CA0: 10       PUSH  X
1CA1: 50 FF    MOV   A,255
1CA3: 7C 09 57 LCALL 0x0957
1CA6: 20       POP   X
(0626) 					{
1CA7: 10       PUSH  X
1CA8: 50 FF    MOV   A,255
1CAA: 7C 08 7E LCALL 0x087E
1CAD: 20       POP   X
(0627) 						// Send a request to the servo for its power status.
1CAE: 10       PUSH  X
1CAF: 52 FC    MOV   A,[X-4]
1CB1: 7C 09 57 LCALL 0x0957
1CB4: 20       POP   X
(0628) 						servoInstruction(ID,4,READ_SERVO,24,1);
1CB5: 10       PUSH  X
1CB6: 52 FC    MOV   A,[X-4]
1CB8: 7C 08 7E LCALL 0x087E
1CBB: 20       POP   X
(0629) 						
1CBC: 10       PUSH  X
1CBD: 52 FB    MOV   A,[X-5]
1CBF: 7C 09 57 LCALL 0x0957
1CC2: 20       POP   X
(0630) 						// Switch to read the response.
1CC3: 10       PUSH  X
1CC4: 52 FB    MOV   A,[X-5]
1CC6: 7C 08 7E LCALL 0x087E
1CC9: 20       POP   X
(0631) 						configToggle(RX_MODE);
1CCA: 10       PUSH  X
1CCB: 52 FA    MOV   A,[X-6]
1CCD: 7C 09 57 LCALL 0x0957
1CD0: 20       POP   X
(0632) 						
1CD1: 10       PUSH  X
1CD2: 52 FA    MOV   A,[X-6]
1CD4: 7C 08 7E LCALL 0x087E
1CD7: 20       POP   X
(0633) 						// Loop until we read a response or time out.
1CD8: 10       PUSH  X
1CD9: 52 F9    MOV   A,[X-7]
1CDB: 7C 09 57 LCALL 0x0957
1CDE: 20       POP   X
(0634) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
1CDF: 10       PUSH  X
1CE0: 52 F9    MOV   A,[X-7]
1CE2: 7C 08 7E LCALL 0x087E
1CE5: 20       POP   X
(0635) 						{
1CE6: 10       PUSH  X
1CE7: 52 F8    MOV   A,[X-8]
1CE9: 7C 09 57 LCALL 0x0957
1CEC: 20       POP   X
(0636) 							if(iReadChar() == ID)
1CED: 10       PUSH  X
1CEE: 52 F8    MOV   A,[X-8]
1CF0: 7C 08 7E LCALL 0x087E
1CF3: 20       POP   X
(0637) 							{
1CF4: 10       PUSH  X
1CF5: 52 00    MOV   A,[X+0]
1CF7: 7C 09 57 LCALL 0x0957
1CFA: 20       POP   X
(0638) 								runningTotal = ID;
1CFB: 10       PUSH  X
1CFC: 52 00    MOV   A,[X+0]
1CFE: 7C 08 7E LCALL 0x087E
1D01: 20       POP   X
(0639) 								// Loop until we read a response or time out.
(0640) 								while(TIMEOUT < RX_TIMEOUT_DURATION)
(0641) 								{
1D02: 10       PUSH  X
1D03: 7C 09 2A LCALL 0x092A
1D06: 62 D0 00 MOV   REG[208],0
1D09: 20       POP   X
1D0A: 53 9D    MOV   [__r0],A
1D0C: 47 9D 20 TST   [__r0],32
1D0F: AF F2    JZ    0x1D02
(0642) 									// Check the length of the packet.
1D11: 10       PUSH  X
1D12: 7C 08 51 LCALL 0x0851
1D15: 62 D0 00 MOV   REG[208],0
1D18: 20       POP   X
1D19: 53 9D    MOV   [__r0],A
1D1B: 47 9D 20 TST   [__r0],32
1D1E: AF F2    JZ    0x1D11
(0643) 									if(iReadChar() == 3)
(0644) 									{
(0645) 										// Tack the value onto our running total.
1D20: 95 06    CALL  _xmitWait
1D22: 38 FD    ADD   SP,253
1D24: 20       POP   X
1D25: 7F       RET   
(0646) 										runningTotal += 3;
(0647) 										
(0648) 										// Loop until we read a response or time out.
(0649) 										while(TIMEOUT < RX_TIMEOUT_DURATION)
(0650) 										{
_longServoInstruction:
  total                --> X+1
  checksum             --> X+0
  value2               --> X-9
  value1               --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
1D26: 10       PUSH  X
1D27: 4F       MOV   X,SP
1D28: 38 03    ADD   SP,3
(0651) 											// Check for the checksum or 1.
(0652) 											if(tempByte = iReadChar())
(0653) 											{
(0654) 												// Switch to PC mode to forward the result.
(0655) 												configToggle(PC_MODE);
1D2A: 62 D0 00 MOV   REG[208],0
1D2D: 52 FB    MOV   A,[X-5]
1D2F: 53 9C    MOV   [__r1],A
1D31: 55 9D 00 MOV   [__r0],0
1D34: 52 FC    MOV   A,[X-4]
1D36: 02 9C    ADD   A,[__r1]
1D38: 53 9C    MOV   [__r1],A
1D3A: 50 00    MOV   A,0
1D3C: 0A 9D    ADC   A,[__r0]
1D3E: 53 9D    MOV   [__r0],A
1D40: 52 FA    MOV   A,[X-6]
1D42: 04 9C    ADD   [__r1],A
1D44: 0E 9D 00 ADC   [__r0],0
1D47: 52 F9    MOV   A,[X-7]
1D49: 04 9C    ADD   [__r1],A
1D4B: 0E 9D 00 ADC   [__r0],0
1D4E: 52 F8    MOV   A,[X-8]
1D50: 04 9C    ADD   [__r1],A
1D52: 0E 9D 00 ADC   [__r0],0
1D55: 52 F7    MOV   A,[X-9]
1D57: 53 9A    MOV   [__r3],A
1D59: 55 9B 00 MOV   [__r2],0
1D5C: 51 9C    MOV   A,[__r1]
1D5E: 02 9A    ADD   A,[__r3]
1D60: 54 02    MOV   [X+2],A
1D62: 51 9D    MOV   A,[__r0]
1D64: 0A 9B    ADC   A,[__r2]
1D66: 54 01    MOV   [X+1],A
(0656) 												
(0657) 												if((runningTotal%256) == (255-tempByte))
(0658) 												{
1D68: 50 01    MOV   A,1
1D6A: 08       PUSH  A
1D6B: 50 00    MOV   A,0
1D6D: 08       PUSH  A
1D6E: 52 01    MOV   A,[X+1]
1D70: 08       PUSH  A
1D71: 52 02    MOV   A,[X+2]
1D73: 08       PUSH  A
1D74: 7C 23 0E LCALL __divmod_16X16_16
1D77: 38 FE    ADD   SP,254
1D79: 18       POP   A
1D7A: 53 9C    MOV   [__r1],A
1D7C: 18       POP   A
1D7D: 50 FF    MOV   A,255
1D7F: 12 9C    SUB   A,[__r1]
1D81: 54 00    MOV   [X+0],A
(0659) 													// Send a 0 if we hit the checksum.
(0660) 													COMP_SERIAL_PutChar('0');
(0661) 													COMP_SERIAL_PutChar('\n');
1D83: 10       PUSH  X
1D84: 50 FF    MOV   A,255
1D86: 7C 09 57 LCALL 0x0957
1D89: 20       POP   X
(0662) 												}
1D8A: 10       PUSH  X
1D8B: 50 FF    MOV   A,255
1D8D: 7C 08 7E LCALL 0x087E
1D90: 20       POP   X
(0663) 												else
1D91: 10       PUSH  X
1D92: 50 FF    MOV   A,255
1D94: 7C 09 57 LCALL 0x0957
1D97: 20       POP   X
(0664) 												{
1D98: 10       PUSH  X
1D99: 50 FF    MOV   A,255
1D9B: 7C 08 7E LCALL 0x087E
1D9E: 20       POP   X
(0665) 													// Send a 1 if we hit it first.
1D9F: 10       PUSH  X
1DA0: 52 FC    MOV   A,[X-4]
1DA2: 7C 09 57 LCALL 0x0957
1DA5: 20       POP   X
(0666) 													COMP_SERIAL_PutChar('1');
1DA6: 10       PUSH  X
1DA7: 52 FC    MOV   A,[X-4]
1DA9: 7C 08 7E LCALL 0x087E
1DAC: 20       POP   X
(0667) 													COMP_SERIAL_PutChar('\n');
1DAD: 10       PUSH  X
1DAE: 52 FB    MOV   A,[X-5]
1DB0: 7C 09 57 LCALL 0x0957
1DB3: 20       POP   X
(0668) 												}
1DB4: 10       PUSH  X
1DB5: 52 FB    MOV   A,[X-5]
1DB7: 7C 08 7E LCALL 0x087E
1DBA: 20       POP   X
(0669) 		
1DBB: 10       PUSH  X
1DBC: 52 FA    MOV   A,[X-6]
1DBE: 7C 09 57 LCALL 0x0957
1DC1: 20       POP   X
(0670) 												TIMEOUT = RX_TIMEOUT_DURATION;
1DC2: 10       PUSH  X
1DC3: 52 FA    MOV   A,[X-6]
1DC5: 7C 08 7E LCALL 0x087E
1DC8: 20       POP   X
(0671) 											}
1DC9: 10       PUSH  X
1DCA: 52 F9    MOV   A,[X-7]
1DCC: 7C 09 57 LCALL 0x0957
1DCF: 20       POP   X
(0672) 										}
1DD0: 10       PUSH  X
1DD1: 52 F9    MOV   A,[X-7]
1DD3: 7C 08 7E LCALL 0x087E
1DD6: 20       POP   X
(0673) 									}
1DD7: 10       PUSH  X
1DD8: 52 F8    MOV   A,[X-8]
1DDA: 7C 09 57 LCALL 0x0957
1DDD: 20       POP   X
(0674) 								}
1DDE: 10       PUSH  X
1DDF: 52 F8    MOV   A,[X-8]
1DE1: 7C 08 7E LCALL 0x087E
1DE4: 20       POP   X
(0675) 							}
1DE5: 10       PUSH  X
1DE6: 52 F7    MOV   A,[X-9]
1DE8: 7C 09 57 LCALL 0x0957
1DEB: 20       POP   X
(0676) 						}
1DEC: 10       PUSH  X
1DED: 52 F7    MOV   A,[X-9]
1DEF: 7C 08 7E LCALL 0x087E
1DF2: 20       POP   X
(0677) 					}
1DF3: 10       PUSH  X
1DF4: 52 00    MOV   A,[X+0]
1DF6: 7C 09 57 LCALL 0x0957
1DF9: 20       POP   X
(0678) 					else if ((param[0] == 't') || (param[0] == 'T'))
1DFA: 10       PUSH  X
1DFB: 52 00    MOV   A,[X+0]
1DFD: 7C 08 7E LCALL 0x087E
1E00: 20       POP   X
(0679) 					{
(0680) 						// If this isn't for the parent, ping the module to get a
(0681) 						// status packet and return the data.
1E01: 10       PUSH  X
1E02: 7C 09 2A LCALL 0x092A
1E05: 62 D0 00 MOV   REG[208],0
1E08: 20       POP   X
1E09: 53 9D    MOV   [__r0],A
1E0B: 47 9D 20 TST   [__r0],32
1E0E: AF F2    JZ    0x1E01
(0682) 						if(ID == 0)
1E10: 10       PUSH  X
1E11: 7C 08 51 LCALL 0x0851
1E14: 62 D0 00 MOV   REG[208],0
1E17: 20       POP   X
1E18: 53 9D    MOV   [__r0],A
1E1A: 47 9D 20 TST   [__r0],32
1E1D: AF F2    JZ    0x1E10
(0683) 						{
(0684) 							COMP_SERIAL_PutChar(TYPE);
(0685) 							COMP_SERIAL_PutChar('\n');
1E1F: 94 07    CALL  _xmitWait
1E21: 38 FD    ADD   SP,253
1E23: 20       POP   X
1E24: 7F       RET   
(0686) 						}
(0687) 						else if(pingModule(ID))
(0688) 						{
(0689) 							configToggle(PC_MODE);
(0690) 												
(0691) 							COMP_SERIAL_PutChar(PARAM[0]);
_configToggle:
  mode                 --> X-5
1E25: 10       PUSH  X
1E26: 4F       MOV   X,SP
(0692) 							COMP_SERIAL_PutChar('\n');
(0693) 						}
1E27: 43 00 FF OR    REG[0],255
(0694) 					}
1E2A: 62 02 00 MOV   REG[2],0
(0695) 					else if ((param[0] == 'c') || (param[0] == 'C'))
(0696) 					{
(0697) 						// If this isn't for the parent, ping the module to get a
(0698) 						// status packet and return the data.
1E2D: 62 D0 00 MOV   REG[208],0
1E30: 3C A0 00 CMP   [STATE],0
1E33: B0 06    JNZ   0x1E3A
1E35: 3C A1 00 CMP   [STATE+1],0
1E38: A0 10    JZ    0x1E49
(0699) 						if(ID == 0)
(0700) 						{
1E3A: 62 D0 00 MOV   REG[208],0
1E3D: 51 A0    MOV   A,[STATE]
1E3F: 08       PUSH  A
1E40: 51 A1    MOV   A,[STATE+1]
1E42: 08       PUSH  A
1E43: 90 BA    CALL  _unloadConfig
1E45: 38 FE    ADD   SP,254
(0701) 							COMP_SERIAL_PutChar(CHILD);
1E47: 80 03    JMP   0x1E4B
(0702) 							COMP_SERIAL_PutChar('\n');
(0703) 						}
(0704) 						else if(pingModule(ID))
1E49: 90 AD    CALL  _unloadAllConfigs
(0705) 						{	
(0706) 							configToggle(PC_MODE);
(0707) 							
1E4B: 3D FB 00 CMP   [X-5],0
1E4E: B0 61    JNZ   0x1EB0
1E50: 3D FC 01 CMP   [X-4],1
1E53: B0 5C    JNZ   0x1EB0
(0708) 							COMP_SERIAL_PutChar(PARAM[1]);
(0709) 							COMP_SERIAL_PutChar('\n');
1E55: 7C 06 9E LCALL 0x069E
(0710) 						}
(0711) 					}
1E58: 10       PUSH  X
1E59: 7C 11 67 LCALL 0x1167
1E5C: 20       POP   X
(0712) 				}
1E5D: 10       PUSH  X
1E5E: 50 01    MOV   A,1
1E60: 7C 10 64 LCALL 0x1064
1E63: 20       POP   X
(0713) 			}
1E64: 10       PUSH  X
1E65: 50 00    MOV   A,0
1E67: 7C 10 35 LCALL 0x1035
1E6A: 20       POP   X
(0714) 		}
(0715) 	}
1E6B: 10       PUSH  X
1E6C: 50 00    MOV   A,0
1E6E: 7C 09 1E LCALL 0x091E
1E71: 20       POP   X
(0716) 	
1E72: 10       PUSH  X
1E73: 50 00    MOV   A,0
1E75: 7C 08 45 LCALL 0x0845
1E78: 20       POP   X
(0717) 	// Reset the timeout and switch to PC mode.
(0718) 	if(STATE != PC_MODE)
1E79: 62 D0 00 MOV   REG[208],0
1E7C: 55 9F 00 MOV   [TIMEOUT+1],0
1E7F: 55 9E 00 MOV   [TIMEOUT],0
(0719) 	{
1E82: 10       PUSH  X
1E83: 7C 07 CA LCALL 0x07CA
(0720) 		configToggle(PC_MODE);
1E86: 7C 07 D2 LCALL 0x07D2
1E89: 20       POP   X
(0721) 	}
(0722) 	else
(0723) 	{
1E8A: 62 D0 00 MOV   REG[208],0
1E8D: 3C 9E 00 CMP   [TIMEOUT],0
1E90: B0 06    JNZ   0x1E97
1E92: 3C 9F 00 CMP   [TIMEOUT+1],0
1E95: AF F4    JZ    0x1E8A
(0724) 		TIMEOUT = 0;
(0725) 		COMP_SERIAL_CmdReset();
(0726) 	}
1E97: 10       PUSH  X
1E98: 7C 07 D6 LCALL 0x07D6
1E9B: 20       POP   X
(0727) }
1E9C: 62 D0 00 MOV   REG[208],0
1E9F: 55 9F 00 MOV   [TIMEOUT+1],0
1EA2: 55 9E 00 MOV   [TIMEOUT],0
(0728) 
(0729) // This function receives a destination, command length, instruction type, address, and value.
(0730) // With these parameters, the function sends a packet to the communication bus.
1EA5: 62 D0 00 MOV   REG[208],0
1EA8: 55 A1 01 MOV   [STATE+1],1
1EAB: 55 A0 00 MOV   [STATE],0
(0731) void servoInstruction(char id, char length, char instruction, char address, char value)
1EAE: 80 44    JMP   0x1EF3
(0732) {
1EB0: 3D FB 00 CMP   [X-5],0
1EB3: B0 3F    JNZ   0x1EF3
1EB5: 3D FC 02 CMP   [X-4],2
1EB8: B0 3A    JNZ   0x1EF3
(0733) 	char checksum;	// The checksum byte value.
(0734) 	int total;		// The total for use in calculating the checksum.
1EBA: 7C 06 35 LCALL 0x0635
(0735) 	
(0736) 	// Get the total of all bytes.
(0737) 	total = id + length + instruction + address + value;
(0738) 	
(0739) 	// Calculate the checksum value for our servo communication.
(0740) 	checksum = 255-(total%256);
1EBD: 10       PUSH  X
1EBE: 50 00    MOV   A,0
1EC0: 7C 0E C3 LCALL 0x0EC3
1EC3: 20       POP   X
(0741) 	
(0742) 	// Talk to the servo.
(0743) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte one
(0744) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte one
(0745) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte two
1EC4: 10       PUSH  X
1EC5: 50 00    MOV   A,0
1EC7: 7C 0D 6A LCALL 0x0D6A
1ECA: 20       POP   X
(0746) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte two
(0747) 	TX_REPEATER_14_PutChar(id);			// The servo ID
(0748) 	TX_REPEATER_23_PutChar(id);				// The servo ID
(0749) 	TX_REPEATER_14_PutChar(length);		// Remaining packet length
(0750) 	TX_REPEATER_23_PutChar(length);			// Remaining packet length
1ECB: 10       PUSH  X
1ECC: 50 00    MOV   A,0
1ECE: 7C 0C 11 LCALL 0x0C11
1ED1: 20       POP   X
(0751) 	TX_REPEATER_14_PutChar(instruction);	// Servo instruction
(0752) 	TX_REPEATER_23_PutChar(instruction);	// Servo instruction
(0753) 	TX_REPEATER_14_PutChar(address);		// Target memory address on the servo EEPROM
(0754) 	TX_REPEATER_23_PutChar(address);		// Target memory address on the servo EEPROM
(0755) 	TX_REPEATER_14_PutChar(value);			// The write value or number of bytes to read
1ED2: 10       PUSH  X
1ED3: 50 00    MOV   A,0
1ED5: 7C 0A B8 LCALL 0x0AB8
1ED8: 20       POP   X
(0756) 	TX_REPEATER_23_PutChar(value);			// The write value or number of bytes to read
(0757) 	TX_REPEATER_14_PutChar(checksum);		// This is the end of this transmission
(0758) 	TX_REPEATER_23_PutChar(checksum);		// This is the end of this transmission
(0759) 	
1ED9: 62 D0 00 MOV   REG[208],0
1EDC: 55 9F 00 MOV   [TIMEOUT+1],0
1EDF: 55 9E 00 MOV   [TIMEOUT],0
(0760) 	// Wait for the transmission to finish.
1EE2: 10       PUSH  X
1EE3: 7C 09 DC LCALL 0x09DC
(0761) 	while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
1EE6: 7C 09 E4 LCALL 0x09E4
1EE9: 20       POP   X
(0762) 	while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
(0763) 	
(0764) 	// Make completely sure we're done.
1EEA: 62 D0 00 MOV   REG[208],0
1EED: 55 A1 02 MOV   [STATE+1],2
1EF0: 55 A0 00 MOV   [STATE],0
(0765) 	xmitWait();
(0766) }
(0767) 
(0768) // This function receives a destination, command length, instruction type, address, and two values.
1EF3: 43 02 FF OR    REG[2],255
1EF6: 20       POP   X
1EF7: 7F       RET   
(0769) void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
(0770) {
(0771) 	char checksum;	// The checksum byte value.
(0772) 	int total;		// The total for use in calculating the checksum.
(0773) 	
(0774) 	// Get the total of all bytes.
(0775) 	total = id + length + instruction + address + value1 + value2;
_unloadAllConfigs:
1EF8: 7C 07 06 LCALL 0x0706
(0776) 	
1EFB: 7C 06 79 LCALL 0x0679
1EFE: 7F       RET   
(0777) 	// Calculate the checksum value for our servo communication.
(0778) 	checksum = 255-(total%256);
(0779) 	
(0780) 	// Talk to the servo.
(0781) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte one
(0782) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte one
_unloadConfig:
  config_num           --> X-5
1EFF: 10       PUSH  X
1F00: 4F       MOV   X,SP
(0783) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte two
1F01: 3D FB 00 CMP   [X-5],0
1F04: B0 0B    JNZ   0x1F10
1F06: 3D FC 01 CMP   [X-4],1
1F09: B0 06    JNZ   0x1F10
(0784) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte two
(0785) 	TX_REPEATER_14_PutChar(id);			// The servo ID
1F0B: 7C 07 06 LCALL 0x0706
(0786) 	TX_REPEATER_23_PutChar(id);				// The servo ID
1F0E: 80 0E    JMP   0x1F1D
(0787) 	TX_REPEATER_14_PutChar(length);		// Remaining packet length
1F10: 3D FB 00 CMP   [X-5],0
1F13: B0 09    JNZ   0x1F1D
1F15: 3D FC 02 CMP   [X-4],2
1F18: B0 04    JNZ   0x1F1D
(0788) 	TX_REPEATER_23_PutChar(length);			// Remaining packet length
(0789) 	TX_REPEATER_14_PutChar(instruction);	// Servo instruction
1F1A: 7C 06 79 LCALL 0x0679
(0790) 	TX_REPEATER_23_PutChar(instruction);	// Servo instruction
1F1D: 20       POP   X
1F1E: 7F       RET   
(0791) 	TX_REPEATER_14_PutChar(address);		// Target memory address on the servo EEPROM
(0792) 	TX_REPEATER_23_PutChar(address);		// Target memory address on the servo EEPROM
(0793) 	TX_REPEATER_14_PutChar(value1);		// The first write value
(0794) 	TX_REPEATER_23_PutChar(value1);			// The first write value
_initializeChildren:
  num_timeouts         --> X+4
  ping_tries           --> X+2
  i                    --> X+0
1F1F: 10       PUSH  X
1F20: 4F       MOV   X,SP
1F21: 38 06    ADD   SP,6
(0795) 	TX_REPEATER_14_PutChar(value2);		// The second write value
1F23: 56 05 00 MOV   [X+5],0
1F26: 56 04 00 MOV   [X+4],0
(0796) 	TX_REPEATER_23_PutChar(value2);			// The second write value
1F29: 56 03 05 MOV   [X+3],5
1F2C: 56 02 00 MOV   [X+2],0
(0797) 	TX_REPEATER_14_PutChar(checksum);		// This is the end of this transmission
1F2F: 56 01 00 MOV   [X+1],0
1F32: 56 00 00 MOV   [X+0],0
(0798) 	TX_REPEATER_23_PutChar(checksum);		// This is the end of this transmission
(0799) 	
(0800) 	// Wait for the transmission to finish.
1F35: 62 D0 00 MOV   REG[208],0
1F38: 55 A3 00 MOV   [NUM_MODULES+1],0
1F3B: 55 A2 00 MOV   [NUM_MODULES],0
(0801) 	while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
(0802) 	while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
(0803) 	
1F3E: 62 D0 00 MOV   REG[208],0
1F41: 55 AC 00 MOV   [CHILD],0
1F44: 80 06    JMP   0x1F4B
(0804) 	// Make completely sure we're done.
(0805) 	xmitWait();
(0806) }
(0807) 
(0808) // This function allows the program to pass an RX or TX mode flag for switching between modes on the
1F46: 7C 14 61 LCALL _sayHello
(0809) // half duplex UART serial communication line.
(0810) void configToggle(int mode)
(0811) {
1F49: 91 79    CALL  _childListen
1F4B: 62 D0 00 MOV   REG[208],0
1F4E: 3C AC 00 CMP   [CHILD],0
1F51: AF F4    JZ    0x1F46
(0812) 	// Disconnect from the global bus and leave the pin high.
(0813) 	PRT0DR |= 0b11111111;
(0814) 	PRT0GS &= 0b00000000;
(0815) 
1F53: 7C 14 61 LCALL _sayHello
1F56: 80 EA    JMP   0x2041
(0816) 	// Unload the configuration of the current state.
(0817) 	// If there is no state, blindly wipe all configurations.
(0818) 	if(STATE)
(0819) 	{
(0820) 		unloadConfig(STATE);
(0821) 	}
1F58: 7C 14 FB LCALL _validTransmission
1F5B: 62 D0 00 MOV   REG[208],0
1F5E: 3C 9D 00 CMP   [__r0],0
1F61: B0 06    JNZ   0x1F68
1F63: 3C 9C 00 CMP   [__r1],0
1F66: A0 96    JZ    0x1FFD
(0822) 	else
(0823) 	{
1F68: 62 D0 00 MOV   REG[208],0
1F6B: 3C A9 C8 CMP   [COMMAND_TYPE],200
1F6E: B0 D2    JNZ   0x2041
(0824) 		unloadAllConfigs();
(0825) 	}
(0826) 	
1F70: 62 D0 00 MOV   REG[208],0
1F73: 3C AA 00 CMP   [COMMAND_DESTINATION],0
1F76: B0 CA    JNZ   0x2041
(0827) 	if(mode == PC_MODE)
(0828) 	{
1F78: 62 D0 00 MOV   REG[208],0
1F7B: 76 A3    INC   [NUM_MODULES+1]
1F7D: 0E A2 00 ADC   [NUM_MODULES],0
(0829) 		LoadConfig_pc_listener();
1F80: 56 05 00 MOV   [X+5],0
1F83: 56 04 00 MOV   [X+4],0
(0830) 
(0831) 		COMP_SERIAL_CmdReset();								// Initialize the buffer.
1F86: 51 A2    MOV   A,[NUM_MODULES]
1F88: 08       PUSH  A
1F89: 51 A3    MOV   A,[NUM_MODULES+1]
1F8B: 08       PUSH  A
1F8C: 7C 13 48 LCALL _assignID
1F8F: 38 FE    ADD   SP,254
1F91: 62 D0 00 MOV   REG[208],0
1F94: 3C 9D 00 CMP   [__r0],0
1F97: B0 A9    JNZ   0x2041
1F99: 3C 9C 00 CMP   [__r1],0
1F9C: B0 A4    JNZ   0x2041
(0832) 		COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); 	// Enable RX interrupts  
(0833) 		COMP_SERIAL_Start(UART_PARITY_NONE);				// Starts the UART.
(0834) 		
(0835) 		TX_REPEATER_14_Start(TX_REPEATER_14_PARITY_NONE);	// Start the 014 TX repeater.
(0836) 		TX_REPEATER_23_Start(TX_REPEATER_23_PARITY_NONE);	// Start the 23 TX repeater.
1F9E: 56 01 00 MOV   [X+1],0
1FA1: 56 00 00 MOV   [X+0],0
1FA4: 80 2D    JMP   0x1FD2
(0837) 		
(0838) 		TIMEOUT = 0;			// Clear the timeout flag.
1FA6: 62 D0 00 MOV   REG[208],0
1FA9: 51 A2    MOV   A,[NUM_MODULES]
1FAB: 08       PUSH  A
1FAC: 51 A3    MOV   A,[NUM_MODULES+1]
1FAE: 08       PUSH  A
1FAF: 7C 12 3D LCALL _pingModule
1FB2: 38 FE    ADD   SP,254
1FB4: 62 D0 00 MOV   REG[208],0
1FB7: 3C 9D 00 CMP   [__r0],0
1FBA: B0 06    JNZ   0x1FC1
1FBC: 3C 9C 00 CMP   [__r1],0
1FBF: A0 0D    JZ    0x1FCD
(0839) 		TX_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
(0840) 		TX_TIMEOUT_Start();		// Start the timer.
1FC1: 52 03    MOV   A,[X+3]
1FC3: 01 01    ADD   A,1
1FC5: 54 01    MOV   [X+1],A
1FC7: 52 02    MOV   A,[X+2]
1FC9: 09 00    ADC   A,0
1FCB: 54 00    MOV   [X+0],A
1FCD: 77 01    INC   [X+1]
1FCF: 0F 00 00 ADC   [X+0],0
1FD2: 52 01    MOV   A,[X+1]
1FD4: 13 03    SUB   A,[X+3]
1FD6: 52 02    MOV   A,[X+2]
1FD8: 31 80    XOR   A,128
1FDA: 62 D0 00 MOV   REG[208],0
1FDD: 53 97    MOV   [__rX],A
1FDF: 52 00    MOV   A,[X+0]
1FE1: 31 80    XOR   A,128
1FE3: 1A 97    SBB   A,[__rX]
1FE5: CF C0    JC    0x1FA6
(0841) 		
(0842) 		// Do nothing while we allow everyone to load the right configuration.
(0843) 		while(!TIMEOUT){ }
(0844) 		
(0845) 		// Stop the timer and reset the timeout flag.
1FE7: 52 00    MOV   A,[X+0]
1FE9: 3B 02    CMP   A,[X+2]
1FEB: B0 55    JNZ   0x2041
1FED: 52 01    MOV   A,[X+1]
1FEF: 3B 03    CMP   A,[X+3]
1FF1: B0 4F    JNZ   0x2041
(0846) 		TX_TIMEOUT_Stop();
(0847) 		TIMEOUT = 0;
1FF3: 62 D0 00 MOV   REG[208],0
1FF6: 7A A3    DEC   [NUM_MODULES+1]
1FF8: 1E A2 00 SBB   [NUM_MODULES],0
(0848) 		
(0849) 		// Store the state.
(0850) 		STATE = PC_MODE;
(0851) 	}
(0852) 	else if(mode == RX_MODE)
1FFB: 80 45    JMP   0x2041
(0853) 	{
1FFD: 62 D0 00 MOV   REG[208],0
2000: 51 9F    MOV   A,[TIMEOUT+1]
2002: 11 05    SUB   A,5
2004: 51 9E    MOV   A,[TIMEOUT]
2006: 31 80    XOR   A,128
2008: 19 80    SBB   A,128
200A: C0 36    JC    0x2041
(0854) 		LoadConfig_receiver_config();
(0855) 		
(0856) 		// Start the receivers.
200C: 62 D0 00 MOV   REG[208],0
200F: 3C A2 00 CMP   [NUM_MODULES],0
2012: B0 06    JNZ   0x2019
2014: 3C A3 00 CMP   [NUM_MODULES+1],0
2017: A0 08    JZ    0x2020
(0857) 		// The seemingly unnecessary brackets around each line are unfortunately needed.
(0858) 		{
2019: 77 05    INC   [X+5]
201B: 0F 04 00 ADC   [X+4],0
(0859) 		// Start listening for a response through child port 1.
201E: 80 10    JMP   0x202F
(0860) 		RECEIVE_1_Start(RECEIVE_1_PARITY_NONE);
(0861) 		}
(0862) 		
(0863) 		{
(0864) 		// Start listening for a response through child port 2.
2020: 62 D0 00 MOV   REG[208],0
2023: 51 9F    MOV   A,[TIMEOUT+1]
2025: 11 32    SUB   A,50
2027: 51 9E    MOV   A,[TIMEOUT]
2029: 31 80    XOR   A,128
202B: 19 80    SBB   A,128
202D: CF F2    JC    0x2020
(0865) 		RECEIVE_2_Start(RECEIVE_2_PARITY_NONE);
(0866) 		}
(0867) 		
(0868) 		{
202F: 62 D0 00 MOV   REG[208],0
2032: 51 A3    MOV   A,[NUM_MODULES+1]
2034: 11 FA    SUB   A,250
2036: 51 A2    MOV   A,[NUM_MODULES]
2038: 31 80    XOR   A,128
203A: 19 80    SBB   A,128
203C: D0 04    JNC   0x2041
(0869) 		// Start listening for a response through child port 3.
(0870) 		RECEIVE_3_Start(RECEIVE_3_PARITY_NONE);
203E: 7C 14 61 LCALL _sayHello
2041: 52 05    MOV   A,[X+5]
2043: 11 32    SUB   A,50
2045: 52 04    MOV   A,[X+4]
2047: 31 80    XOR   A,128
2049: 19 80    SBB   A,128
204B: CF 0C    JC    0x1F58
(0871) 		}
(0872) 		
(0873) 		{
(0874) 		// Start listening for a response through child port 4.
(0875) 		RECEIVE_4_Start(RECEIVE_4_PARITY_NONE);
(0876) 		}
204D: 62 D0 00 MOV   REG[208],0
2050: 3C A2 00 CMP   [NUM_MODULES],0
2053: B0 62    JNZ   0x20B6
2055: 3C A3 00 CMP   [NUM_MODULES+1],0
2058: B0 5D    JNZ   0x20B6
(0877) 		
(0878) 		// Start response timeout timer and enable its interrupt routine.
(0879) 		TIMEOUT = 0;
205A: 56 01 00 MOV   [X+1],0
205D: 56 00 00 MOV   [X+0],0
2060: 80 40    JMP   0x20A1
(0880) 		RX_TIMEOUT_EnableInt();
(0881) 		RX_TIMEOUT_Start();
2062: 62 D0 00 MOV   REG[208],0
2065: 51 A3    MOV   A,[NUM_MODULES+1]
2067: 01 01    ADD   A,1
2069: 62 D0 00 MOV   REG[208],0
206C: 53 9C    MOV   [__r1],A
206E: 62 D0 00 MOV   REG[208],0
2071: 51 A2    MOV   A,[NUM_MODULES]
2073: 09 00    ADC   A,0
2075: 62 D0 00 MOV   REG[208],0
2078: 08       PUSH  A
2079: 51 9C    MOV   A,[__r1]
207B: 08       PUSH  A
207C: 7C 12 3D LCALL _pingModule
207F: 38 FE    ADD   SP,254
2081: 62 D0 00 MOV   REG[208],0
2084: 3C 9D 00 CMP   [__r0],0
2087: B0 06    JNZ   0x208E
2089: 3C 9C 00 CMP   [__r1],0
208C: A0 0F    JZ    0x209C
(0882) 		
(0883) 		// Store the state.
208E: 62 D0 00 MOV   REG[208],0
2091: 76 A3    INC   [NUM_MODULES+1]
2093: 0E A2 00 ADC   [NUM_MODULES],0
(0884) 		STATE = RX_MODE;
2096: 56 01 00 MOV   [X+1],0
2099: 56 00 00 MOV   [X+0],0
209C: 77 01    INC   [X+1]
209E: 0F 00 00 ADC   [X+0],0
20A1: 52 01    MOV   A,[X+1]
20A3: 13 03    SUB   A,[X+3]
20A5: 52 02    MOV   A,[X+2]
20A7: 31 80    XOR   A,128
20A9: 62 D0 00 MOV   REG[208],0
20AC: 53 97    MOV   [__rX],A
20AE: 52 00    MOV   A,[X+0]
20B0: 31 80    XOR   A,128
20B2: 1A 97    SBB   A,[__rX]
20B4: CF AD    JC    0x2062
(0885) 	}
(0886) 	
(0887) 	// Reconnect to the global bus.
(0888) 	PRT0GS |= 0b11111111;
(0889) }
(0890) 
20B6: 50 00    MOV   A,0
20B8: 08       PUSH  A
20B9: 50 01    MOV   A,1
20BB: 08       PUSH  A
20BC: 9D 67    CALL  _configToggle
20BE: 38 FE    ADD   SP,254
20C0: 38 FA    ADD   SP,250
20C2: 20       POP   X
20C3: 7F       RET   
(0891) // This function blindly unloads all user configurations. This will be called once,
(0892) // when the system initially has no known state.
(0893) void unloadAllConfigs(void)
(0894) {
(0895) 	UnloadConfig_pc_listener();
_childListen:
20C4: 80 B7    JMP   0x217C
(0896) 	UnloadConfig_receiver_config();
(0897) }
(0898) 
(0899) // This function unloads the configuration corresponding to the config number passed to it.
(0900) // We do this instead of unloadAllConfigs to cut down on set up time.
(0901) void unloadConfig(int config_num)
20C6: 10       PUSH  X
20C7: 7C 0E DA LCALL 0x0EDA
20CA: 62 D0 00 MOV   REG[208],0
20CD: 20       POP   X
20CE: 39 FC    CMP   A,252
20D0: B0 23    JNZ   0x20F4
(0902) {
20D2: 80 10    JMP   0x20E3
(0903) 	if(config_num == PC_MODE)
(0904) 	{
(0905) 		UnloadConfig_pc_listener();
20D4: 10       PUSH  X
20D5: 7C 0E DA LCALL 0x0EDA
20D8: 20       POP   X
20D9: 39 FD    CMP   A,253
20DB: B0 07    JNZ   0x20E3
(0906) 	}
(0907) 	else if(config_num == RX_MODE)
20DD: 62 D0 00 MOV   REG[208],0
20E0: 55 AC 31 MOV   [CHILD],49
20E3: 62 D0 00 MOV   REG[208],0
20E6: 51 9F    MOV   A,[TIMEOUT+1]
20E8: 11 05    SUB   A,5
20EA: 51 9E    MOV   A,[TIMEOUT]
20EC: 31 80    XOR   A,128
20EE: 19 80    SBB   A,128
20F0: CF E3    JC    0x20D4
(0908) 	{
(0909) 		UnloadConfig_receiver_config();
(0910) 	}
20F2: 80 89    JMP   0x217C
(0911) }
20F4: 10       PUSH  X
20F5: 7C 0D 81 LCALL 0x0D81
20F8: 62 D0 00 MOV   REG[208],0
20FB: 20       POP   X
20FC: 39 FC    CMP   A,252
20FE: B0 23    JNZ   0x2122
(0912) 
2100: 80 10    JMP   0x2111
(0913) void initializeChildren(void)
(0914) {
(0915) 	int num_timeouts = 0;	// The number of consecutive timeouts.
2102: 10       PUSH  X
2103: 7C 0D 81 LCALL 0x0D81
2106: 20       POP   X
2107: 39 FD    CMP   A,253
2109: B0 07    JNZ   0x2111
(0916) 	int ping_tries = 5;		// The number of times to try a ping on an unregistered module.
(0917) 	int i = 0;				// An iterator for looping.
210B: 62 D0 00 MOV   REG[208],0
210E: 55 AC 32 MOV   [CHILD],50
2111: 62 D0 00 MOV   REG[208],0
2114: 51 9F    MOV   A,[TIMEOUT+1]
2116: 11 05    SUB   A,5
2118: 51 9E    MOV   A,[TIMEOUT]
211A: 31 80    XOR   A,128
211C: 19 80    SBB   A,128
211E: CF E3    JC    0x2102
(0918) 	
(0919) 	// Set num modules to zero.
(0920) 	NUM_MODULES = 0;
2120: 80 5B    JMP   0x217C
(0921) 	
2122: 10       PUSH  X
2123: 7C 0C 28 LCALL 0x0C28
2126: 62 D0 00 MOV   REG[208],0
2129: 20       POP   X
212A: 39 FC    CMP   A,252
212C: B0 23    JNZ   0x2150
(0922) 	// Set the child value to zero.
212E: 80 10    JMP   0x213F
(0923) 	CHILD = 0;	
(0924) 	
(0925) 	while(CHILD == 0)
2130: 10       PUSH  X
2131: 7C 0C 28 LCALL 0x0C28
2134: 20       POP   X
2135: 39 FD    CMP   A,253
2137: B0 07    JNZ   0x213F
(0926) 	{
(0927) 		// Send out a probing message.
2139: 62 D0 00 MOV   REG[208],0
213C: 55 AC 33 MOV   [CHILD],51
213F: 62 D0 00 MOV   REG[208],0
2142: 51 9F    MOV   A,[TIMEOUT+1]
2144: 11 05    SUB   A,5
2146: 51 9E    MOV   A,[TIMEOUT]
2148: 31 80    XOR   A,128
214A: 19 80    SBB   A,128
214C: CF E3    JC    0x2130
(0928) 		sayHello();
(0929) 		
(0930) 		// Listen for a response.
214E: 80 2D    JMP   0x217C
(0931) 		childListen();
2150: 10       PUSH  X
2151: 7C 0A CF LCALL 0x0ACF
2154: 62 D0 00 MOV   REG[208],0
2157: 20       POP   X
2158: 39 FC    CMP   A,252
215A: B0 21    JNZ   0x217C
(0932) 	}
215C: 80 10    JMP   0x216D
(0933) 	
(0934) 	// Send out a probing message.
(0935) 	sayHello();
215E: 10       PUSH  X
215F: 7C 0A CF LCALL 0x0ACF
2162: 20       POP   X
2163: 39 FD    CMP   A,253
2165: B0 07    JNZ   0x216D
(0936) 	
(0937) 	// This loop continuously probes and listens at intervals
2167: 62 D0 00 MOV   REG[208],0
216A: 55 AC 34 MOV   [CHILD],52
216D: 62 D0 00 MOV   REG[208],0
2170: 51 9F    MOV   A,[TIMEOUT+1]
2172: 11 05    SUB   A,5
2174: 51 9E    MOV   A,[TIMEOUT]
2176: 31 80    XOR   A,128
2178: 19 80    SBB   A,128
217A: CF E3    JC    0x215E
217C: 62 D0 00 MOV   REG[208],0
217F: 51 9F    MOV   A,[TIMEOUT+1]
2181: 11 05    SUB   A,5
2183: 51 9E    MOV   A,[TIMEOUT]
2185: 31 80    XOR   A,128
2187: 19 80    SBB   A,128
2189: CF 3C    JC    0x20C6
218B: 7F       RET   
(0938) 	// set by the RX_TIMEOUT_DURATION variable.
(0939) 	while(num_timeouts < MAX_TIMEOUTS)
(0940) 	{	
(0941) 		if(validTransmission())
(0942) 		{
(0943) 			if(COMMAND_TYPE == HELLO_BYTE)	// Someone else is out there!
(0944) 			{
(0945) 				// If this is for me, assign them an ID.
(0946) 				if(COMMAND_DESTINATION == PARENT_ID)
(0947) 				{
_iReadChar:
218C: 62 D0 00 MOV   REG[208],0
218F: 3C AC 31 CMP   [CHILD],49
2192: B0 0B    JNZ   0x219E
(0948) 					NUM_MODULES++;			// Increment the number of modules connected.
(0949) 					num_timeouts = 0;		// Reset number of timeouts since we found someone.
2194: 10       PUSH  X
2195: 7C 0E DA LCALL 0x0EDA
2198: 62 D0 00 MOV   REG[208],0
219B: 20       POP   X
219C: 80 3C    JMP   0x21D9
(0950) 		
(0951) 					if(!assignID(NUM_MODULES))
219E: 62 D0 00 MOV   REG[208],0
21A1: 3C AC 32 CMP   [CHILD],50
21A4: B0 0B    JNZ   0x21B0
(0952) 					{
(0953) 						// If the module did not respond that the ID was assigned,
21A6: 10       PUSH  X
21A7: 7C 0D 81 LCALL 0x0D81
21AA: 62 D0 00 MOV   REG[208],0
21AD: 20       POP   X
21AE: 80 2A    JMP   0x21D9
(0954) 						// make an effort to ping it in case that transmission was lost
(0955) 						// before ultimately deciding that the module didn't configure.
21B0: 62 D0 00 MOV   REG[208],0
21B3: 3C AC 33 CMP   [CHILD],51
21B6: B0 0B    JNZ   0x21C2
(0956) 						for(i = 0; i < ping_tries; i++)
(0957) 						{	
21B8: 10       PUSH  X
21B9: 7C 0C 28 LCALL 0x0C28
21BC: 62 D0 00 MOV   REG[208],0
21BF: 20       POP   X
21C0: 80 18    JMP   0x21D9
(0958) 							if(pingModule(NUM_MODULES))
(0959) 							{
21C2: 62 D0 00 MOV   REG[208],0
21C5: 3C AC 34 CMP   [CHILD],52
21C8: B0 0B    JNZ   0x21D4
(0960) 								i = ping_tries+1;
(0961) 							}
21CA: 10       PUSH  X
21CB: 7C 0A CF LCALL 0x0ACF
21CE: 62 D0 00 MOV   REG[208],0
21D1: 20       POP   X
21D2: 80 06    JMP   0x21D9
(0962) 						}
(0963) 						
(0964) 						// If we landed right at ping_tries, we failed.
(0965) 						if(i == ping_tries)
21D4: 62 D0 00 MOV   REG[208],0
21D7: 50 00    MOV   A,0
21D9: 7F       RET   
(0966) 						{
(0967) 							NUM_MODULES--;
(0968) 						}
(0969) 					}
(0970) 				}
(0971) 			}
(0972) 		}
_readChar:
21DA: 62 D0 00 MOV   REG[208],0
21DD: 3C AC 31 CMP   [CHILD],49
21E0: B0 0B    JNZ   0x21EC
(0973) 		else if(TIMEOUT >= RX_TIMEOUT_DURATION)
(0974) 		{	
21E2: 10       PUSH  X
21E3: 7C 0E D2 LCALL 0x0ED2
21E6: 62 D0 00 MOV   REG[208],0
21E9: 20       POP   X
21EA: 80 3C    JMP   0x2227
(0975) 			// Only increment the number of timeouts if we have found a module.
(0976) 			if(NUM_MODULES)
21EC: 62 D0 00 MOV   REG[208],0
21EF: 3C AC 32 CMP   [CHILD],50
21F2: B0 0B    JNZ   0x21FE
(0977) 			{
(0978) 				num_timeouts++;
21F4: 10       PUSH  X
21F5: 7C 0D 79 LCALL 0x0D79
21F8: 62 D0 00 MOV   REG[208],0
21FB: 20       POP   X
21FC: 80 2A    JMP   0x2227
(0979) 			}
(0980) 			else
21FE: 62 D0 00 MOV   REG[208],0
2201: 3C AC 33 CMP   [CHILD],51
2204: B0 0B    JNZ   0x2210
(0981) 			{
(0982) 				// Wait additional time between transmissions if no modules have been found.
2206: 10       PUSH  X
2207: 7C 0C 20 LCALL 0x0C20
220A: 62 D0 00 MOV   REG[208],0
220D: 20       POP   X
220E: 80 18    JMP   0x2227
(0983) 				// This is done to give the first child a chance to configure if it hasn't.
(0984) 				while(TIMEOUT < INIT_WAIT_TIME) { }
2210: 62 D0 00 MOV   REG[208],0
2213: 3C AC 34 CMP   [CHILD],52
2216: B0 0B    JNZ   0x2222
(0985) 			}
(0986) 			
2218: 10       PUSH  X
2219: 7C 0A C7 LCALL 0x0AC7
221C: 62 D0 00 MOV   REG[208],0
221F: 20       POP   X
2220: 80 06    JMP   0x2227
(0987) 			// If we are not maxed out on modules, look for more.
(0988) 			if(NUM_MODULES < MAX_MODULES)
(0989) 			{
(0990) 				sayHello();
2222: 62 D0 00 MOV   REG[208],0
2225: 50 00    MOV   A,0
2227: 7F       RET   
(0991) 			}
(0992) 		}
(0993) 	}
(0994) 	
(0995) 	// If we didn't find any new modules, check to see if some already exist.
_xmitWait:
  i                    --> X+0
2228: 10       PUSH  X
2229: 4F       MOV   X,SP
222A: 38 02    ADD   SP,2
(0996) 	if(!NUM_MODULES)
(0997) 	{
(0998) 		// Try to ping the next module up from our current number ping_tries times.
222C: 56 01 00 MOV   [X+1],0
222F: 56 00 00 MOV   [X+0],0
2232: 77 01    INC   [X+1]
2234: 0F 00 00 ADC   [X+0],0
2237: 52 01    MOV   A,[X+1]
2239: 11 19    SUB   A,25
223B: 52 00    MOV   A,[X+0]
223D: 31 80    XOR   A,128
223F: 19 80    SBB   A,128
2241: CF F0    JC    0x2232
2243: 38 FE    ADD   SP,254
2245: 20       POP   X
2246: 7F       RET   
(0999) 		for(i = 0; i < ping_tries; i++)
(1000) 		{	
(1001) 			if(pingModule(NUM_MODULES+1))
(1002) 			{
(1003) 				NUM_MODULES++;
(1004) 				i = 0;
(1005) 			}
_TX_TIMEOUT_ISR:
2247: 71 C0    OR    F,192
2249: 08       PUSH  A
224A: 5D D0    MOV   A,REG[208]
224C: 08       PUSH  A
(1006) 		}
(1007) 	}
224D: 62 D0 00 MOV   REG[208],0
2250: 76 9F    INC   [TIMEOUT+1]
2252: 0E 9E 00 ADC   [TIMEOUT],0
(1008) 	
(1009) 	// Switch back to PC mode.
2255: 62 DA FD MOV   REG[218],253
2258: 18       POP   A
2259: 60 D0    MOV   REG[208],A
225B: 18       POP   A
225C: 7E       RETI  
(1010) 	configToggle(PC_MODE);
(1011) }
(1012) 
(1013) // This function listens for children and registers the port that they talk to.
_RX_TIMEOUT_ISR:
225D: 71 C0    OR    F,192
225F: 08       PUSH  A
2260: 5D D0    MOV   A,REG[208]
2262: 08       PUSH  A
(1014) void childListen(void)
(1015) {	
2263: 62 D0 00 MOV   REG[208],0
2266: 76 9F    INC   [TIMEOUT+1]
2268: 0E 9E 00 ADC   [TIMEOUT],0
(1016) 	// Wait to either hear a child or time out.
(1017) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
226B: 62 DA FD MOV   REG[218],253
226E: 18       POP   A
226F: 60 D0    MOV   REG[208],A
2271: 18       POP   A
2272: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  thesis_masterINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_11
                                   (0021) export	Dispatch_INTERRUPT_14
                                   (0022) export	Dispatch_INTERRUPT_15
                                   (0023) export	Dispatch_INTERRUPT_9
                                   (0024) 
                                   (0025) 
                                   (0026) Dispatch_INTERRUPT_10:
2273: 08       PUSH  A             (0027) 	push	a
2274: 50 00    MOV   A,0           (0028) 	mov		a,0
2276: 47 08 02 TST   [8],2         (0029) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
2279: B0 0C    JNZ   0x2286        (0030) 	jnz		Dispatch_INTERRUPT_10_END
227B: 50 04    MOV   A,4           (0031) 	mov		a,4
227D: 47 08 01 TST   [8],1         (0032) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
2280: B0 05    JNZ   0x2286        (0033) 	jnz		Dispatch_INTERRUPT_10_END
2282: 18       POP   A             (0034) 	pop		a
2283: 7E       RETI                (0035) 	reti
                                   (0036) ; Stop Code Compressor from breaking table alignment
                                   (0037) ; The next instruction does not get executed.
2284: 71 00    OR    F,0           (0038) 	Suspend_CodeCompressor
                                   (0039) Dispatch_INTERRUPT_10_END:
2286: E0 01    JACC  0x2288        (0040) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0041) Dispatch_INTERRUPT_10_TBL:
2288: 18       POP   A             (0042) 	pop		a
2289: 7D 09 03 LJMP  0x0903        (0043) 	ljmp	_TX_REPEATER_14_ISR
228C: 18       POP   A             (0044) 	pop		a
228D: 7D 0E 47 LJMP  0x0E47        (0045) 	ljmp	_RECEIVE_1_ISR
                                   (0046) ; Resume Code Compressor.
                                   (0047) ; The next instruction does not get executed.
2290: 38 00    ADD   SP,0          (0048) 	Resume_CodeCompressor
                                   (0049) 
                                   (0050) Dispatch_INTERRUPT_11:
2292: 08       PUSH  A             (0051) 	push	a
2293: 50 00    MOV   A,0           (0052) 	mov		a,0
2295: 47 08 02 TST   [8],2         (0053) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
2298: B0 0C    JNZ   0x22A5        (0054) 	jnz		Dispatch_INTERRUPT_11_END
229A: 50 04    MOV   A,4           (0055) 	mov		a,4
229C: 47 08 01 TST   [8],1         (0056) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
229F: B0 05    JNZ   0x22A5        (0057) 	jnz		Dispatch_INTERRUPT_11_END
22A1: 18       POP   A             (0058) 	pop		a
22A2: 7E       RETI                (0059) 	reti
                                   (0060) ; Stop Code Compressor from breaking table alignment
                                   (0061) ; The next instruction does not get executed.
22A3: 71 00    OR    F,0           (0062) 	Suspend_CodeCompressor
                                   (0063) Dispatch_INTERRUPT_11_END:
22A5: E0 01    JACC  0x22A7        (0064) 	jacc	Dispatch_INTERRUPT_11_TBL
                                   (0065) Dispatch_INTERRUPT_11_TBL:
22A7: 18       POP   A             (0066) 	pop		a
22A8: 7D 08 2A LJMP  0x082A        (0067) 	ljmp	_TX_REPEATER_23_ISR
22AB: 18       POP   A             (0068) 	pop		a
22AC: 7D 0C EE LJMP  0x0CEE        (0069) 	ljmp	_RECEIVE_2_ISR
                                   (0070) ; Resume Code Compressor.
                                   (0071) ; The next instruction does not get executed.
22AF: 38 00    ADD   SP,0          (0072) 	Resume_CodeCompressor
                                   (0073) 
                                   (0074) Dispatch_INTERRUPT_14:
22B1: 08       PUSH  A             (0075) 	push	a
22B2: 50 00    MOV   A,0           (0076) 	mov		a,0
22B4: 47 08 02 TST   [8],2         (0077) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
22B7: B0 0C    JNZ   0x22C4        (0078) 	jnz		Dispatch_INTERRUPT_14_END
22B9: 50 04    MOV   A,4           (0079) 	mov		a,4
22BB: 47 08 01 TST   [8],1         (0080) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
22BE: B0 05    JNZ   0x22C4        (0081) 	jnz		Dispatch_INTERRUPT_14_END
22C0: 18       POP   A             (0082) 	pop		a
22C1: 7E       RETI                (0083) 	reti
                                   (0084) ; Stop Code Compressor from breaking table alignment
                                   (0085) ; The next instruction does not get executed.
22C2: 71 00    OR    F,0           (0086) 	Suspend_CodeCompressor
                                   (0087) Dispatch_INTERRUPT_14_END:
22C4: E0 01    JACC  0x22C6        (0088) 	jacc	Dispatch_INTERRUPT_14_TBL
                                   (0089) Dispatch_INTERRUPT_14_TBL:
22C6: 18       POP   A             (0090) 	pop		a
22C7: 7D 0F A0 LJMP  0x0FA0        (0091) 	ljmp	_COMP_SERIAL_TX_ISR
22CA: 18       POP   A             (0092) 	pop		a
22CB: 7D 0B 95 LJMP  0x0B95        (0093) 	ljmp	_RECEIVE_3_ISR
                                   (0094) ; Resume Code Compressor.
                                   (0095) ; The next instruction does not get executed.
22CE: 38 00    ADD   SP,0          (0096) 	Resume_CodeCompressor
                                   (0097) 
                                   (0098) Dispatch_INTERRUPT_15:
22D0: 08       PUSH  A             (0099) 	push	a
22D1: 50 00    MOV   A,0           (0100) 	mov		a,0
22D3: 47 08 02 TST   [8],2         (0101) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
22D6: B0 0C    JNZ   0x22E3        (0102) 	jnz		Dispatch_INTERRUPT_15_END
22D8: 50 04    MOV   A,4           (0103) 	mov		a,4
22DA: 47 08 01 TST   [8],1         (0104) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
22DD: B0 05    JNZ   0x22E3        (0105) 	jnz		Dispatch_INTERRUPT_15_END
22DF: 18       POP   A             (0106) 	pop		a
22E0: 7E       RETI                (0107) 	reti
                                   (0108) ; Stop Code Compressor from breaking table alignment
                                   (0109) ; The next instruction does not get executed.
22E1: 71 00    OR    F,0           (0110) 	Suspend_CodeCompressor
                                   (0111) Dispatch_INTERRUPT_15_END:
22E3: E0 01    JACC  0x22E5        (0112) 	jacc	Dispatch_INTERRUPT_15_TBL
                                   (0113) Dispatch_INTERRUPT_15_TBL:
22E5: 18       POP   A             (0114) 	pop		a
22E6: 7D 0F A1 LJMP  0x0FA1        (0115) 	ljmp	_COMP_SERIAL_RX_ISR
22E9: 18       POP   A             (0116) 	pop		a
22EA: 7D 0A 3C LJMP  0x0A3C        (0117) 	ljmp	_RECEIVE_4_ISR
                                   (0118) ; Resume Code Compressor.
                                   (0119) ; The next instruction does not get executed.
22ED: 38 00    ADD   SP,0          (0120) 	Resume_CodeCompressor
                                   (0121) 
                                   (0122) Dispatch_INTERRUPT_9:
22EF: 08       PUSH  A             (0123) 	push	a
22F0: 50 00    MOV   A,0           (0124) 	mov		a,0
22F2: 47 08 02 TST   [8],2         (0125) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
22F5: B0 0C    JNZ   0x2302        (0126) 	jnz		Dispatch_INTERRUPT_9_END
22F7: 50 04    MOV   A,4           (0127) 	mov		a,4
22F9: 47 08 01 TST   [8],1         (0128) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
22FC: B0 05    JNZ   0x2302        (0129) 	jnz		Dispatch_INTERRUPT_9_END
22FE: 18       POP   A             (0130) 	pop		a
22FF: 7E       RETI                (0131) 	reti
                                   (0132) ; Stop Code Compressor from breaking table alignment
                                   (0133) ; The next instruction does not get executed.
2300: 71 00    OR    F,0           (0134) 	Suspend_CodeCompressor
                                   (0135) Dispatch_INTERRUPT_9_END:
2302: E0 01    JACC  0x2304        (0136) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0137) Dispatch_INTERRUPT_9_TBL:
2304: 18       POP   A             (0138) 	pop		a
2305: 7D 22 47 LJMP  _TX_TIMEOUT_ISR(0139) 	ljmp	_TX_TIMEOUT_ISR
2308: 18       POP   A             (0140) 	pop		a
2309: 7D 22 5D LJMP  _RX_TIMEOUT_ISR(0141) 	ljmp	_RX_TIMEOUT_ISR
                                   (0142) ; Resume Code Compressor.
                                   (0143) ; The next instruction does not get executed.
                                   (0144) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
