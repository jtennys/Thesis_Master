 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 116
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 7-10-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the parent module of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; #include <stdlib.h>                   // Required for converting character arrays to and from floats and ints.
 0000           ; 
 0000           ; //#include <string.h>
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC and RX modes.
 0000           ; #define               PC_MODE                                         (1)
 0000           ; #define               RX_MODE                                         (2)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               COMMAND_TYPE_SPACE                      (200)   // The number where reserved command types start.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates parent is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the parent.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the parent is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               PARENT_ID                                       (0)             // The parent node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; #define               SERVO_START                                     (255)   // The start byte of a servo.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; // These defines are used for the initial probing stage.
 0000           ; #define               INIT_WAIT_TIME                          (50)    // Initial wait time between module probes.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the parent.
 0000           ; #define               MAX_MODULES                                     (250)
 0000           ; 
 0000           ; // Receives a mode identifier and toggles to that mode.
 0000           ; void configToggle(int mode);
 0000           ; // Pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; // Assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; // Attempts to read a valid transmission and store it.
 0000           ; int validTransmission(void);
 0000           ; // Reads a PC command and translates it to the correct packet type.
 0000           ; void decodeTransmission(void);
 0000           ; // Sends out a hello message packet.
 0000           ; void sayHello(void);
 0000           ; // Servo instruction function that sends read or write commands.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // Servo instruction function that sends long two-byte write commands.
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; // Immediately performs a non-blocking read char operation, and returns 0 upon failure.
 0000           ; char iReadChar(void);
 0000           ; // Performs a blocking read char operation.
 0000           ; char readChar(void);
 0000           ; // Checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // Unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the child module controllers.
 0000           ; void initializeChildren(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; // Listen for a child and record the port value.
 0000           ; void childListen(void);
 0000           ; 
 0000           ; int TIMEOUT;                          // This flag is incremented if there is a timeout.
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; char CHILD;                                   // The child port value stored from initialization.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 117
 0000           ;       NUM_MODULES = 0;        // Initialize the number of modules.
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 118
 0009           ;       STATE = 0;                      // Initialize the current hardware state.
 0009 62D000            mov REG[0xd0],>_STATE
 000C 550100            mov [_STATE+1],0
 000F 550000            mov [_STATE],0
 0012                   .dbline 121
 0012           ;       
 0012           ;       // Activate GPIO ISR.
 0012           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 0012 43E020            or REG[0xe0],32
 0015                   .dbline 124
 0015           ;       
 0015           ;       // Turn on global interrupts for the transmission timeout timer.
 0015           ;       M8C_EnableGInt;
 0015 7101                      or  F, 01h
 0017           
 0017 8021              xjmp L3
 0019           L2:
 0019                   .dbline 127
 0019           ;       
 0019           ;       while(1)
 0019           ;       {
 0019                   .dbline 129
 0019           ;               // If there are no modules, find some. Otherwise, look for computer commands.
 0019           ;               if(!NUM_MODULES)
 0019 62D000            mov REG[0xd0],>_NUM_MODULES
 001C 3C0000            cmp [_NUM_MODULES],0
 001F B00B              jnz L5
 0021 3C0100            cmp [_NUM_MODULES+1],0
 0024 B006              jnz L5
 0026           X1:
 0026                   .dbline 130
 0026           ;               {
 0026                   .dbline 131
 0026           ;                       initializeChildren();
 0026 7C0D08            xcall _initializeChildren
 0029                   .dbline 132
 0029           ;               }
 0029 800F              xjmp L6
 002B           L5:
 002B                   .dbline 133
 002B           ;               else if(COMP_SERIAL_bCmdCheck())
 002B 10                push X
 002C 7C0000            xcall _COMP_SERIAL_bCmdCheck
 002F 62D000            mov REG[0xd0],>__r0
 0032 20                pop X
 0033 3900              cmp A,0
 0035 A003              jz L7
 0037                   .dbline 134
 0037           ;               {
 0037                   .dbline 135
 0037           ;                       decodeTransmission();
 0037 938A              xcall _decodeTransmission
 0039                   .dbline 136
 0039           ;               }
 0039           L7:
 0039           L6:
 0039                   .dbline 137
 0039           ;       }
 0039           L3:
 0039                   .dbline 126
 0039 8FDF              xjmp L2
 003B           X0:
 003B                   .dbline -2
 003B           L1:
 003B                   .dbline 0 ; func end
 003B 8FFF              jmp .
 003D                   .dbend
 003D                   .dbfunc e pingModule _pingModule fI
 003D           ;      module_id -> X-5
 003D           _pingModule::
 003D                   .dbline -1
 003D 10                push X
 003E 4F                mov X,SP
 003F                   .dbline 141
 003F           ; }
 003F           ; 
 003F           ; int pingModule(int module_id)
 003F           ; {
 003F                   .dbline 143
 003F           ;       // Toggle into PC mode.
 003F           ;       configToggle(PC_MODE);
 003F 5000              mov A,0
 0041 08                push A
 0042 5001              mov A,1
 0044 08                push A
 0045 7C0C0E            xcall _configToggle
 0048 38FE              add SP,-2
 004A                   .dbline 146
 004A           ;       
 004A           ;       // Transmit a ping to everyone.
 004A           ;       TX_REPEATER_014_PutChar(START_TRANSMIT);        // Start byte one
 004A 10                push X
 004B 50FC              mov A,-4
 004D 7C0000            xcall _TX_REPEATER_014_PutChar
 0050 20                pop X
 0051                   .dbline 147
 0051           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 0051 10                push X
 0052 50FC              mov A,-4
 0054 7C0000            xcall _TX_REPEATER_23_PutChar
 0057 20                pop X
 0058                   .dbline 148
 0058           ;       TX_REPEATER_014_PutChar(START_TRANSMIT);        // Start byte two
 0058 10                push X
 0059 50FC              mov A,-4
 005B 7C0000            xcall _TX_REPEATER_014_PutChar
 005E 20                pop X
 005F                   .dbline 149
 005F           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 005F 10                push X
 0060 50FC              mov A,-4
 0062 7C0000            xcall _TX_REPEATER_23_PutChar
 0065 20                pop X
 0066                   .dbline 150
 0066           ;       TX_REPEATER_014_PutChar(PARENT_ID);                     // My ID
 0066 10                push X
 0067 5000              mov A,0
 0069 7C0000            xcall _TX_REPEATER_014_PutChar
 006C 20                pop X
 006D                   .dbline 151
 006D           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 006D 10                push X
 006E 5000              mov A,0
 0070 7C0000            xcall _TX_REPEATER_23_PutChar
 0073 20                pop X
 0074                   .dbline 152
 0074           ;       TX_REPEATER_014_PutChar(module_id);                     // Destination ID
 0074 62D000            mov REG[0xd0],>__r0
 0077 52FC              mov A,[X-4]
 0079 10                push X
 007A 7C0000            xcall _TX_REPEATER_014_PutChar
 007D 20                pop X
 007E                   .dbline 153
 007E           ;       TX_REPEATER_23_PutChar(module_id);                      // Destination ID
 007E 62D000            mov REG[0xd0],>__r0
 0081 52FC              mov A,[X-4]
 0083 10                push X
 0084 7C0000            xcall _TX_REPEATER_23_PutChar
 0087 20                pop X
 0088                   .dbline 154
 0088           ;       TX_REPEATER_014_PutChar(PING);                          // This is a ping response
 0088 10                push X
 0089 50CB              mov A,-53
 008B 7C0000            xcall _TX_REPEATER_014_PutChar
 008E 20                pop X
 008F                   .dbline 155
 008F           ;       TX_REPEATER_23_PutChar(PING);                           // This is a ping response
 008F 10                push X
 0090 50CB              mov A,-53
 0092 7C0000            xcall _TX_REPEATER_23_PutChar
 0095 20                pop X
 0096                   .dbline 156
 0096           ;       TX_REPEATER_014_PutChar(END_TRANSMIT);          // This is the end of this transmission
 0096 10                push X
 0097 50FD              mov A,-3
 0099 7C0000            xcall _TX_REPEATER_014_PutChar
 009C 20                pop X
 009D                   .dbline 157
 009D           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 009D 10                push X
 009E 50FD              mov A,-3
 00A0 7C0000            xcall _TX_REPEATER_23_PutChar
 00A3 20                pop X
 00A4                   .dbline 158
 00A4           ;       TX_REPEATER_014_PutChar(END_TRANSMIT);          // This is the end of this transmission
 00A4 10                push X
 00A5 50FD              mov A,-3
 00A7 7C0000            xcall _TX_REPEATER_014_PutChar
 00AA 20                pop X
 00AB                   .dbline 159
 00AB           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 00AB 10                push X
 00AC 50FD              mov A,-3
 00AE 7C0000            xcall _TX_REPEATER_23_PutChar
 00B1 20                pop X
 00B2           L10:
 00B2                   .dbline 162
 00B2           ;       
 00B2           ;       // Wait for the transmission to finish.
 00B2           ;       while(!(TX_REPEATER_014_bReadTxStatus() & TX_REPEATER_014_TX_COMPLETE));
 00B2           L11:
 00B2                   .dbline 162
 00B2 10                push X
 00B3 7C0000            xcall _TX_REPEATER_014_bReadTxStatus
 00B6 62D000            mov REG[0xd0],>__r0
 00B9 20                pop X
 00BA 5300              mov [__r0],A
 00BC 470020            tst [__r0],32
 00BF AFF2              jz L10
 00C1           L13:
 00C1                   .dbline 163
 00C1           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 00C1           L14:
 00C1                   .dbline 163
 00C1 10                push X
 00C2 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 00C5 62D000            mov REG[0xd0],>__r0
 00C8 20                pop X
 00C9 5300              mov [__r0],A
 00CB 470020            tst [__r0],32
 00CE AFF2              jz L13
 00D0                   .dbline 166
 00D0           ;       
 00D0           ;       // Make completely sure we're done.
 00D0           ;       xmitWait();
 00D0 7C1011            xcall _xmitWait
 00D3                   .dbline 169
 00D3           ;       
 00D3           ;       // Switch to listening mode.
 00D3           ;       configToggle(RX_MODE);
 00D3 5000              mov A,0
 00D5 08                push A
 00D6 5002              mov A,2
 00D8 08                push A
 00D9 7C0C0E            xcall _configToggle
 00DC 38FE              add SP,-2
 00DE 8041              xjmp L17
 00E0           L16:
 00E0                   .dbline 173
 00E0           ;       
 00E0           ;       // Listen for the response.
 00E0           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 00E0           ;       {
 00E0                   .dbline 174
 00E0           ;               if(validTransmission())
 00E0 9219              xcall _validTransmission
 00E2 62D000            mov REG[0xd0],>__r0
 00E5 3C0000            cmp [__r0],0
 00E8 B006              jnz X2
 00EA 3C0000            cmp [__r1],0
 00ED A032              jz L19
 00EF           X2:
 00EF                   .dbline 175
 00EF           ;               {
 00EF                   .dbline 177
 00EF           ;                       // If the response is what we are looking for.
 00EF           ;                       if(COMMAND_TYPE == PING)
 00EF 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00F2 3C00CB            cmp [_COMMAND_TYPE],-53
 00F5 B02A              jnz L21
 00F7                   .dbline 178
 00F7           ;                       {
 00F7                   .dbline 180
 00F7           ;                               // If this is for me, check who it was from.
 00F7           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 00F7 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00FA 3C0000            cmp [_COMMAND_DESTINATION],0
 00FD B022              jnz L23
 00FF                   .dbline 181
 00FF           ;                               {
 00FF                   .dbline 183
 00FF           ;                                       // If it's from the right module, return 1.
 00FF           ;                                       if(COMMAND_SOURCE == module_id)
 00FF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0102 5100              mov A,[_COMMAND_SOURCE]
 0104 62D000            mov REG[0xd0],>__r0
 0107 5300              mov [__r1],A
 0109 5000              mov A,0
 010B 3BFB              cmp A,[X-5]
 010D B012              jnz L25
 010F 5100              mov A,[__r1]
 0111 3BFC              cmp A,[X-4]
 0113 B00C              jnz L25
 0115           X3:
 0115                   .dbline 184
 0115           ;                                       {
 0115                   .dbline 185
 0115           ;                                               return 1;
 0115 62D000            mov REG[0xd0],>__r0
 0118 550001            mov [__r1],1
 011B 550000            mov [__r0],0
 011E 8027              xjmp L9
 0120           L25:
 0120                   .dbline 187
 0120           ;                                       }
 0120           ;                               }
 0120           L23:
 0120                   .dbline 188
 0120           ;                       }
 0120           L21:
 0120                   .dbline 189
 0120           ;               }
 0120           L19:
 0120                   .dbline 190
 0120           ;       }
 0120           L17:
 0120                   .dbline 172
 0120 62D000            mov REG[0xd0],>_TIMEOUT
 0123 5101              mov A,[_TIMEOUT+1]
 0125 1105              sub A,5
 0127 5100              mov A,[_TIMEOUT]
 0129 3180              xor A,-128
 012B 1980              sbb A,(0 ^ 0x80)
 012D CFB2              jc L16
 012F           X4:
 012F                   .dbline 192
 012F           ; 
 012F           ;       RX_TIMEOUT_Stop();
 012F 10                push X
 0130 7C0000            xcall _RX_TIMEOUT_Stop
 0133 20                pop X
 0134                   .dbline 193
 0134           ;       TIMEOUT = 0;
 0134 62D000            mov REG[0xd0],>_TIMEOUT
 0137 550100            mov [_TIMEOUT+1],0
 013A 550000            mov [_TIMEOUT],0
 013D                   .dbline 195
 013D           ;       
 013D           ;       return 0;
 013D 62D000            mov REG[0xd0],>__r0
 0140 550000            mov [__r1],0
 0143 550000            mov [__r0],0
 0146                   .dbline -2
 0146           L9:
 0146 20                pop X
 0147                   .dbline 0 ; func end
 0147 7F                ret
 0148                   .dbsym l module_id -5 I
 0148                   .dbend
 0148                   .dbfunc e assignID _assignID fI
 0148           ;    assigned_ID -> X-5
 0148           _assignID::
 0148                   .dbline -1
 0148 10                push X
 0149 4F                mov X,SP
 014A                   .dbline 199
 014A           ; }
 014A           ; 
 014A           ; int assignID(int assigned_ID)
 014A           ; {     
 014A                   .dbline 201
 014A           ;       // Switch to PC mode.
 014A           ;       configToggle(PC_MODE);
 014A 5000              mov A,0
 014C 08                push A
 014D 5001              mov A,1
 014F 08                push A
 0150 7C0C0E            xcall _configToggle
 0153 38FE              add SP,-2
 0155                   .dbline 204
 0155           ; 
 0155           ;       // Transmit an ID assignment.
 0155           ;       TX_REPEATER_014_PutChar(START_TRANSMIT);        // Start byte one
 0155 10                push X
 0156 50FC              mov A,-4
 0158 7C0000            xcall _TX_REPEATER_014_PutChar
 015B 20                pop X
 015C                   .dbline 205
 015C           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 015C 10                push X
 015D 50FC              mov A,-4
 015F 7C0000            xcall _TX_REPEATER_23_PutChar
 0162 20                pop X
 0163                   .dbline 206
 0163           ;       TX_REPEATER_014_PutChar(START_TRANSMIT);        // Start byte two
 0163 10                push X
 0164 50FC              mov A,-4
 0166 7C0000            xcall _TX_REPEATER_014_PutChar
 0169 20                pop X
 016A                   .dbline 207
 016A           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 016A 10                push X
 016B 50FC              mov A,-4
 016D 7C0000            xcall _TX_REPEATER_23_PutChar
 0170 20                pop X
 0171                   .dbline 208
 0171           ;       TX_REPEATER_014_PutChar(PARENT_ID);                     // My ID
 0171 10                push X
 0172 5000              mov A,0
 0174 7C0000            xcall _TX_REPEATER_014_PutChar
 0177 20                pop X
 0178                   .dbline 209
 0178           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 0178 10                push X
 0179 5000              mov A,0
 017B 7C0000            xcall _TX_REPEATER_23_PutChar
 017E 20                pop X
 017F                   .dbline 210
 017F           ;       TX_REPEATER_014_PutChar(BLANK_MODULE_ID);       // Destination ID
 017F 10                push X
 0180 50FB              mov A,-5
 0182 7C0000            xcall _TX_REPEATER_014_PutChar
 0185 20                pop X
 0186                   .dbline 211
 0186           ;       TX_REPEATER_23_PutChar(BLANK_MODULE_ID);        // Destination ID
 0186 10                push X
 0187 50FB              mov A,-5
 0189 7C0000            xcall _TX_REPEATER_23_PutChar
 018C 20                pop X
 018D                   .dbline 212
 018D           ;       TX_REPEATER_014_PutChar(ID_ASSIGNMENT);         // This is an ID assignment
 018D 10                push X
 018E 50C9              mov A,-55
 0190 7C0000            xcall _TX_REPEATER_014_PutChar
 0193 20                pop X
 0194                   .dbline 213
 0194           ;       TX_REPEATER_23_PutChar(ID_ASSIGNMENT);          // This is an ID assignment
 0194 10                push X
 0195 50C9              mov A,-55
 0197 7C0000            xcall _TX_REPEATER_23_PutChar
 019A 20                pop X
 019B                   .dbline 214
 019B           ;       TX_REPEATER_014_PutChar(assigned_ID);           // This is the new ID
 019B 62D000            mov REG[0xd0],>__r0
 019E 52FC              mov A,[X-4]
 01A0 10                push X
 01A1 7C0000            xcall _TX_REPEATER_014_PutChar
 01A4 20                pop X
 01A5                   .dbline 215
 01A5           ;       TX_REPEATER_23_PutChar(assigned_ID);            // This is the new ID
 01A5 62D000            mov REG[0xd0],>__r0
 01A8 52FC              mov A,[X-4]
 01AA 10                push X
 01AB 7C0000            xcall _TX_REPEATER_23_PutChar
 01AE 20                pop X
 01AF                   .dbline 216
 01AF           ;       TX_REPEATER_014_PutChar(END_TRANSMIT);          // This is the end of this transmission
 01AF 10                push X
 01B0 50FD              mov A,-3
 01B2 7C0000            xcall _TX_REPEATER_014_PutChar
 01B5 20                pop X
 01B6                   .dbline 217
 01B6           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01B6 10                push X
 01B7 50FD              mov A,-3
 01B9 7C0000            xcall _TX_REPEATER_23_PutChar
 01BC 20                pop X
 01BD                   .dbline 218
 01BD           ;       TX_REPEATER_014_PutChar(END_TRANSMIT);          // This is the end of this transmission
 01BD 10                push X
 01BE 50FD              mov A,-3
 01C0 7C0000            xcall _TX_REPEATER_014_PutChar
 01C3 20                pop X
 01C4                   .dbline 219
 01C4           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01C4 10                push X
 01C5 50FD              mov A,-3
 01C7 7C0000            xcall _TX_REPEATER_23_PutChar
 01CA 20                pop X
 01CB           L28:
 01CB                   .dbline 222
 01CB           ;       
 01CB           ;       // Wait for the transmission to finish.
 01CB           ;       while(!(TX_REPEATER_014_bReadTxStatus() & TX_REPEATER_014_TX_COMPLETE));
 01CB           L29:
 01CB                   .dbline 222
 01CB 10                push X
 01CC 7C0000            xcall _TX_REPEATER_014_bReadTxStatus
 01CF 62D000            mov REG[0xd0],>__r0
 01D2 20                pop X
 01D3 5300              mov [__r0],A
 01D5 470020            tst [__r0],32
 01D8 AFF2              jz L28
 01DA           L31:
 01DA                   .dbline 223
 01DA           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 01DA           L32:
 01DA                   .dbline 223
 01DA 10                push X
 01DB 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 01DE 62D000            mov REG[0xd0],>__r0
 01E1 20                pop X
 01E2 5300              mov [__r0],A
 01E4 470020            tst [__r0],32
 01E7 AFF2              jz L31
 01E9                   .dbline 226
 01E9           ;       
 01E9           ;       // Make completely sure we're done.
 01E9           ;       xmitWait();
 01E9 7C1011            xcall _xmitWait
 01EC                   .dbline 229
 01EC           ;       
 01EC           ;       // Switch to listening mode.
 01EC           ;       configToggle(RX_MODE);
 01EC 5000              mov A,0
 01EE 08                push A
 01EF 5002              mov A,2
 01F1 08                push A
 01F2 7C0C0E            xcall _configToggle
 01F5 38FE              add SP,-2
 01F7 8041              xjmp L35
 01F9           L34:
 01F9                   .dbline 233
 01F9           ;       
 01F9           ;       // Listen for the response.
 01F9           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 01F9           ;       {
 01F9                   .dbline 234
 01F9           ;               if(validTransmission())
 01F9 9100              xcall _validTransmission
 01FB 62D000            mov REG[0xd0],>__r0
 01FE 3C0000            cmp [__r0],0
 0201 B006              jnz X5
 0203 3C0000            cmp [__r1],0
 0206 A032              jz L37
 0208           X5:
 0208                   .dbline 235
 0208           ;               {
 0208                   .dbline 237
 0208           ;                       // If this is the response we are looking for.
 0208           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)
 0208 62D000            mov REG[0xd0],>_COMMAND_TYPE
 020B 3C00CA            cmp [_COMMAND_TYPE],-54
 020E B02A              jnz L39
 0210                   .dbline 238
 0210           ;                       {
 0210                   .dbline 240
 0210           ;                               // If this is for me, check who it was from.
 0210           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 0210 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0213 3C0000            cmp [_COMMAND_DESTINATION],0
 0216 B022              jnz L41
 0218                   .dbline 241
 0218           ;                               {
 0218                   .dbline 243
 0218           ;                                       // If it is from the right module, return 1.
 0218           ;                                       if(COMMAND_SOURCE == assigned_ID)
 0218 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 021B 5100              mov A,[_COMMAND_SOURCE]
 021D 62D000            mov REG[0xd0],>__r0
 0220 5300              mov [__r1],A
 0222 5000              mov A,0
 0224 3BFB              cmp A,[X-5]
 0226 B012              jnz L43
 0228 5100              mov A,[__r1]
 022A 3BFC              cmp A,[X-4]
 022C B00C              jnz L43
 022E           X6:
 022E                   .dbline 244
 022E           ;                                       {
 022E                   .dbline 245
 022E           ;                                               return 1;
 022E 62D000            mov REG[0xd0],>__r0
 0231 550001            mov [__r1],1
 0234 550000            mov [__r0],0
 0237 8027              xjmp L27
 0239           L43:
 0239                   .dbline 247
 0239           ;                                       }
 0239           ;                               }
 0239           L41:
 0239                   .dbline 248
 0239           ;                       }
 0239           L39:
 0239                   .dbline 249
 0239           ;               }
 0239           L37:
 0239                   .dbline 250
 0239           ;       }
 0239           L35:
 0239                   .dbline 232
 0239 62D000            mov REG[0xd0],>_TIMEOUT
 023C 5101              mov A,[_TIMEOUT+1]
 023E 1105              sub A,5
 0240 5100              mov A,[_TIMEOUT]
 0242 3180              xor A,-128
 0244 1980              sbb A,(0 ^ 0x80)
 0246 CFB2              jc L34
 0248           X7:
 0248                   .dbline 252
 0248           ;       
 0248           ;       RX_TIMEOUT_Stop();
 0248 10                push X
 0249 7C0000            xcall _RX_TIMEOUT_Stop
 024C 20                pop X
 024D                   .dbline 253
 024D           ;       TIMEOUT = 0;
 024D 62D000            mov REG[0xd0],>_TIMEOUT
 0250 550100            mov [_TIMEOUT+1],0
 0253 550000            mov [_TIMEOUT],0
 0256                   .dbline 255
 0256           ;       
 0256           ;       return 0;
 0256 62D000            mov REG[0xd0],>__r0
 0259 550000            mov [__r1],0
 025C 550000            mov [__r0],0
 025F                   .dbline -2
 025F           L27:
 025F 20                pop X
 0260                   .dbline 0 ; func end
 0260 7F                ret
 0261                   .dbsym l assigned_ID -5 I
 0261                   .dbend
 0261                   .dbfunc e sayHello _sayHello fV
 0261           _sayHello::
 0261                   .dbline -1
 0261                   .dbline 260
 0261           ; }
 0261           ; 
 0261           ; // This function transmits a hello message.
 0261           ; void sayHello(void)
 0261           ; {
 0261                   .dbline 262
 0261           ;       // Toggle into PC mode.
 0261           ;       configToggle(PC_MODE);
 0261 5000              mov A,0
 0263 08                push A
 0264 5001              mov A,1
 0266 08                push A
 0267 7C0C0E            xcall _configToggle
 026A 38FE              add SP,-2
 026C                   .dbline 265
 026C           ;       
 026C           ;       // Transmit an ID assignment.
 026C           ;       TX_REPEATER_014_PutChar(START_TRANSMIT);        // Start byte one
 026C 10                push X
 026D 50FC              mov A,-4
 026F 7C0000            xcall _TX_REPEATER_014_PutChar
 0272 20                pop X
 0273                   .dbline 266
 0273           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 0273 10                push X
 0274 50FC              mov A,-4
 0276 7C0000            xcall _TX_REPEATER_23_PutChar
 0279 20                pop X
 027A                   .dbline 267
 027A           ;       TX_REPEATER_014_PutChar(START_TRANSMIT);        // Start byte two
 027A 10                push X
 027B 50FC              mov A,-4
 027D 7C0000            xcall _TX_REPEATER_014_PutChar
 0280 20                pop X
 0281                   .dbline 268
 0281           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 0281 10                push X
 0282 50FC              mov A,-4
 0284 7C0000            xcall _TX_REPEATER_23_PutChar
 0287 20                pop X
 0288                   .dbline 269
 0288           ;       TX_REPEATER_014_PutChar(PARENT_ID);                     // My ID
 0288 10                push X
 0289 5000              mov A,0
 028B 7C0000            xcall _TX_REPEATER_014_PutChar
 028E 20                pop X
 028F                   .dbline 270
 028F           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 028F 10                push X
 0290 5000              mov A,0
 0292 7C0000            xcall _TX_REPEATER_23_PutChar
 0295 20                pop X
 0296                   .dbline 271
 0296           ;       TX_REPEATER_014_PutChar(BLANK_MODULE_ID);       // Destination ID
 0296 10                push X
 0297 50FB              mov A,-5
 0299 7C0000            xcall _TX_REPEATER_014_PutChar
 029C 20                pop X
 029D                   .dbline 272
 029D           ;       TX_REPEATER_23_PutChar(BLANK_MODULE_ID);        // Destination ID
 029D 10                push X
 029E 50FB              mov A,-5
 02A0 7C0000            xcall _TX_REPEATER_23_PutChar
 02A3 20                pop X
 02A4                   .dbline 273
 02A4           ;       TX_REPEATER_014_PutChar(HELLO_BYTE);            // This is a hello message
 02A4 10                push X
 02A5 50C8              mov A,-56
 02A7 7C0000            xcall _TX_REPEATER_014_PutChar
 02AA 20                pop X
 02AB                   .dbline 274
 02AB           ;       TX_REPEATER_23_PutChar(HELLO_BYTE);                     // This is a hello message
 02AB 10                push X
 02AC 50C8              mov A,-56
 02AE 7C0000            xcall _TX_REPEATER_23_PutChar
 02B1 20                pop X
 02B2                   .dbline 275
 02B2           ;       TX_REPEATER_014_PutChar(END_TRANSMIT);          // This is the end of this transmission
 02B2 10                push X
 02B3 50FD              mov A,-3
 02B5 7C0000            xcall _TX_REPEATER_014_PutChar
 02B8 20                pop X
 02B9                   .dbline 276
 02B9           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 02B9 10                push X
 02BA 50FD              mov A,-3
 02BC 7C0000            xcall _TX_REPEATER_23_PutChar
 02BF 20                pop X
 02C0                   .dbline 277
 02C0           ;       TX_REPEATER_014_PutChar(END_TRANSMIT);          // This is the end of this transmission
 02C0 10                push X
 02C1 50FD              mov A,-3
 02C3 7C0000            xcall _TX_REPEATER_014_PutChar
 02C6 20                pop X
 02C7                   .dbline 278
 02C7           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 02C7 10                push X
 02C8 50FD              mov A,-3
 02CA 7C0000            xcall _TX_REPEATER_23_PutChar
 02CD 20                pop X
 02CE           L46:
 02CE                   .dbline 281
 02CE           ;       
 02CE           ;       // Wait for the transmission to finish.
 02CE           ;       while(!(TX_REPEATER_014_bReadTxStatus() & TX_REPEATER_014_TX_COMPLETE));
 02CE           L47:
 02CE                   .dbline 281
 02CE 10                push X
 02CF 7C0000            xcall _TX_REPEATER_014_bReadTxStatus
 02D2 62D000            mov REG[0xd0],>__r0
 02D5 20                pop X
 02D6 5300              mov [__r0],A
 02D8 470020            tst [__r0],32
 02DB AFF2              jz L46
 02DD           L49:
 02DD                   .dbline 282
 02DD           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 02DD           L50:
 02DD                   .dbline 282
 02DD 10                push X
 02DE 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 02E1 62D000            mov REG[0xd0],>__r0
 02E4 20                pop X
 02E5 5300              mov [__r0],A
 02E7 470020            tst [__r0],32
 02EA AFF2              jz L49
 02EC                   .dbline 285
 02EC           ;       
 02EC           ;       // Make completely sure we're done.
 02EC           ;       xmitWait();
 02EC 7C1011            xcall _xmitWait
 02EF                   .dbline 288
 02EF           ;       
 02EF           ;       // Switch back to listening mode.
 02EF           ;       configToggle(RX_MODE);
 02EF 5000              mov A,0
 02F1 08                push A
 02F2 5002              mov A,2
 02F4 08                push A
 02F5 7C0C0E            xcall _configToggle
 02F8 38FE              add SP,-2
 02FA                   .dbline -2
 02FA           L45:
 02FA                   .dbline 0 ; func end
 02FA 7F                ret
 02FB                   .dbend
 02FB                   .dbfunc e validTransmission _validTransmission fI
 02FB           ;              i -> X+1
 02FB           ;       tempByte -> X+0
 02FB           _validTransmission::
 02FB                   .dbline -1
 02FB 10                push X
 02FC 4F                mov X,SP
 02FD 3803              add SP,3
 02FF                   .dbline 293
 02FF           ; }
 02FF           ; 
 02FF           ; // This function returns whether or not a valid transmission has been received.
 02FF           ; int validTransmission(void)
 02FF           ; {
 02FF                   .dbline 294
 02FF           ;       int i = 0;                      // Index for looping.
 02FF 560200            mov [X+2],0
 0302 560100            mov [X+1],0
 0305                   .dbline 295
 0305           ;       char tempByte = 0;      // Temporary byte storage.
 0305 560000            mov [X+0],0
 0308 809E              xjmp L54
 030A           L53:
 030A                   .dbline 300
 030A           ;       
 030A           ;       // These loops and conditionals are arranged in a way that allows this read
 030A           ;       // operation to be completely non-blocking.
 030A           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 030A           ;       {
 030A                   .dbline 302
 030A           ;               // Wait until we read a start transmit byte.
 030A           ;               if(iReadChar() == START_TRANSMIT)
 030A 7C0F75            xcall _iReadChar
 030D 62D000            mov REG[0xd0],>__r0
 0310 39FC              cmp A,-4
 0312 B094              jnz L56
 0314                   .dbline 303
 0314           ;               {
 0314 8083              xjmp L59
 0316           L58:
 0316                   .dbline 306
 0316           ;                       // While we haven't timed out, look for something other than a start byte.
 0316           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0316           ;                       {
 0316                   .dbline 308
 0316           ;                               // If we find a nonzero byte...
 0316           ;                               if(tempByte = iReadChar())
 0316 7C0F75            xcall _iReadChar
 0319 5400              mov [X+0],A
 031B 3900              cmp A,0
 031D A07A              jz L61
 031F                   .dbline 309
 031F           ;                               {
 031F                   .dbline 311
 031F           ;                                       // If the byte we found isn't a start byte...
 031F           ;                                       if(tempByte != START_TRANSMIT)
 031F 3D00FC            cmp [X+0],-4
 0322 A075              jz L63
 0324                   .dbline 312
 0324           ;                                       {
 0324                   .dbline 314
 0324           ;                                               // This byte is probably the command source.
 0324           ;                                               COMMAND_SOURCE = tempByte;
 0324 5200              mov A,[X+0]
 0326 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0329 5300              mov [_COMMAND_SOURCE],A
 032B 805D              xjmp L66
 032D           L65:
 032D                   .dbline 318
 032D           ;                                               
 032D           ;                                               // Look for the rest of the command before we time out.
 032D           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 032D           ;                                               {
 032D                   .dbline 320
 032D           ;                                                       // If we read another nonzero byte...
 032D           ;                                                       if(tempByte = iReadChar())
 032D 7C0F75            xcall _iReadChar
 0330 62D000            mov REG[0xd0],>__r0
 0333 5400              mov [X+0],A
 0335 3900              cmp A,0
 0337 A051              jz L68
 0339                   .dbline 321
 0339           ;                                                       {
 0339                   .dbline 323
 0339           ;                                                               // If that byte is in the command type indicator space...
 0339           ;                                                               if(tempByte >= COMMAND_TYPE_SPACE)
 0339 3D00C8            cmp [X+0],-56
 033C C04C              jc L70
 033E           X8:
 033E                   .dbline 324
 033E           ;                                                               {
 033E                   .dbline 326
 033E           ;                                                                       // Store the command type.
 033E           ;                                                                       COMMAND_TYPE = tempByte;
 033E 5200              mov A,[X+0]
 0340 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0343 5300              mov [_COMMAND_TYPE],A
 0345 8034              xjmp L73
 0347           L72:
 0347                   .dbline 330
 0347           ;                                                                       
 0347           ;                                                                       // Continue reading if we have not timed out yet.
 0347           ;                                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0347           ;                                                                       {
 0347                   .dbline 332
 0347           ;                                                                               // If we read a nonzero byte...
 0347           ;                                                                               if(tempByte = iReadChar())
 0347 7C0F75            xcall _iReadChar
 034A 62D000            mov REG[0xd0],>__r0
 034D 5400              mov [X+0],A
 034F 3900              cmp A,0
 0351 A028              jz L75
 0353                   .dbline 333
 0353           ;                                                                               {
 0353                   .dbline 335
 0353           ;                                                                                       // Store the parameter if it is not the end indicator.
 0353           ;                                                                                       if(tempByte != END_TRANSMIT)
 0353 3D00FD            cmp [X+0],-3
 0356 A018              jz L77
 0358                   .dbline 336
 0358           ;                                                                                       {
 0358                   .dbline 337
 0358           ;                                                                                               PARAM[i] = tempByte;
 0358 5202              mov A,[X+2]
 035A 0100              add A,<_PARAM
 035C 5300              mov [__r1],A
 035E 5201              mov A,[X+1]
 0360 0900              adc A,>_PARAM
 0362 60D5              mov REG[0xd5],A
 0364 5200              mov A,[X+0]
 0366 3F00              mvi [__r1],A
 0368                   .dbline 338
 0368           ;                                                                                               i++;
 0368 7702              inc [X+2]
 036A 0F0100            adc [X+1],0
 036D                   .dbline 339
 036D           ;                                                                                       }
 036D 800C              xjmp L78
 036F           L77:
 036F                   .dbline 341
 036F           ;                                                                                       else
 036F           ;                                                                                       {
 036F                   .dbline 342
 036F           ;                                                                                               return 1;
 036F 62D000            mov REG[0xd0],>__r0
 0372 550001            mov [__r1],1
 0375 550000            mov [__r0],0
 0378 8046              xjmp L52
 037A           L78:
 037A                   .dbline 344
 037A           ;                                                                                       }
 037A           ;                                                                               }
 037A           L75:
 037A                   .dbline 345
 037A           ;                                                                       }
 037A           L73:
 037A                   .dbline 329
 037A 62D000            mov REG[0xd0],>_TIMEOUT
 037D 5101              mov A,[_TIMEOUT+1]
 037F 1105              sub A,5
 0381 5100              mov A,[_TIMEOUT]
 0383 3180              xor A,-128
 0385 1980              sbb A,(0 ^ 0x80)
 0387 CFBF              jc L72
 0389           X9:
 0389                   .dbline 346
 0389           ;                                                               }
 0389           L70:
 0389                   .dbline 347
 0389           ;                                                       }
 0389           L68:
 0389                   .dbline 348
 0389           ;                                               }
 0389           L66:
 0389                   .dbline 317
 0389 62D000            mov REG[0xd0],>_TIMEOUT
 038C 5101              mov A,[_TIMEOUT+1]
 038E 1105              sub A,5
 0390 5100              mov A,[_TIMEOUT]
 0392 3180              xor A,-128
 0394 1980              sbb A,(0 ^ 0x80)
 0396 CF96              jc L65
 0398           X10:
 0398                   .dbline 349
 0398           ;                                       }
 0398           L63:
 0398                   .dbline 350
 0398           ;                               }
 0398           L61:
 0398                   .dbline 351
 0398           ;                       }
 0398           L59:
 0398                   .dbline 305
 0398 62D000            mov REG[0xd0],>_TIMEOUT
 039B 5101              mov A,[_TIMEOUT+1]
 039D 1105              sub A,5
 039F 5100              mov A,[_TIMEOUT]
 03A1 3180              xor A,-128
 03A3 1980              sbb A,(0 ^ 0x80)
 03A5 CF70              jc L58
 03A7           X11:
 03A7                   .dbline 352
 03A7           ;               }
 03A7           L56:
 03A7                   .dbline 353
 03A7           ;       }
 03A7           L54:
 03A7                   .dbline 299
 03A7 62D000            mov REG[0xd0],>_TIMEOUT
 03AA 5101              mov A,[_TIMEOUT+1]
 03AC 1105              sub A,5
 03AE 5100              mov A,[_TIMEOUT]
 03B0 3180              xor A,-128
 03B2 1980              sbb A,(0 ^ 0x80)
 03B4 CF55              jc L53
 03B6           X12:
 03B6                   .dbline 355
 03B6           ;       
 03B6           ;       return 0;
 03B6 62D000            mov REG[0xd0],>__r0
 03B9 550000            mov [__r1],0
 03BC 550000            mov [__r0],0
 03BF                   .dbline -2
 03BF           L52:
 03BF 38FD              add SP,-3
 03C1 20                pop X
 03C2                   .dbline 0 ; func end
 03C2 7F                ret
 03C3                   .dbsym l i 1 I
 03C3                   .dbsym l tempByte 0 c
 03C3                   .dbend
 03C3                   .dbfunc e decodeTransmission _decodeTransmission fV
 03C3           ;          speed -> X+10
 03C3           ;          angle -> X+8
 03C3           ;          total -> X+6
 03C3           ;             ID -> X+5
 03C3           ;   runningTotal -> X+3
 03C3           ;       tempByte -> X+2
 03C3           ;          param -> X+0
 03C3           _decodeTransmission::
 03C3                   .dbline -1
 03C3 10                push X
 03C4 4F                mov X,SP
 03C5 380C              add SP,12
 03C7                   .dbline 360
 03C7           ; }
 03C7           ; 
 03C7           ; // This function decodes the transmission and takes the correct action.
 03C7           ; void decodeTransmission(void)
 03C7           ; {
 03C7                   .dbline 362
 03C7           ;       char* param;                    // Stores the most recent parameter from the buffer.
 03C7           ;       char ID = 0;                    // Stores the target module ID.
 03C7 560500            mov [X+5],0
 03CA                   .dbline 363
 03CA           ;       char tempByte = 0;              // Temporary byte storage.
 03CA 560200            mov [X+2],0
 03CD                   .dbline 366
 03CD           ;       char angle[2];                  // Store the two angle bytes for the servo.
 03CD           ;       char speed[2];                  // Store the two speed bytes for the servo.
 03CD           ;       int total = 0;                  // Used to store the converted total of angle or speed bytes.
 03CD 560700            mov [X+7],0
 03D0 560600            mov [X+6],0
 03D3                   .dbline 367
 03D3           ;       int runningTotal = 0;   // Used as part of the dynamic checksum calculation.
 03D3 560400            mov [X+4],0
 03D6 560300            mov [X+3],0
 03D9                   .dbline 370
 03D9           ;       
 03D9           ;       // Read a parameter from the buffer.
 03D9           ;       if(param = COMP_SERIAL_szGetParam())
 03D9 10                push X
 03DA 7C0000            xcall _COMP_SERIAL_szGetParam
 03DD 62D000            mov REG[0xd0],>__r0
 03E0 5300              mov [__r0],A
 03E2 5A00              mov [__r1],X
 03E4 20                pop X
 03E5 5100              mov A,[__r1]
 03E7 5401              mov [X+1],A
 03E9 5100              mov A,[__r0]
 03EB 5400              mov [X+0],A
 03ED 3C0000            cmp [__r0],0
 03F0 B006              jnz X13
 03F2 3C0000            cmp [__r1],0
 03F5 A604              jz L80
 03F7           X13:
 03F7                   .dbline 371
 03F7           ;       {
 03F7                   .dbline 372
 03F7           ;               if((param[0] == 'x') || (param[0] == 'X'))
 03F7 62D000            mov REG[0xd0],>__r0
 03FA 5201              mov A,[X+1]
 03FC 5300              mov [__r1],A
 03FE 5200              mov A,[X+0]
 0400 60D4              mov REG[0xd4],A
 0402 3E00              mvi A,[__r1]
 0404 5300              mov [__r1],A
 0406 550000            mov [__r0],0
 0409 3C0000            cmp [__r0],0
 040C B005              jnz X14
 040E 3978              cmp A,120
 0410 A00E              jz L84
 0412           X14:
 0412 62D000            mov REG[0xd0],>__r0
 0415 3C0000            cmp [__r0],0
 0418 B011              jnz L82
 041A 3C0058            cmp [__r1],88
 041D B00C              jnz L82
 041F           X15:
 041F           L84:
 041F                   .dbline 373
 041F           ;               {
 041F                   .dbline 375
 041F           ;                       // Reset the robot.
 041F           ;                       NUM_MODULES = 0;
 041F 62D000            mov REG[0xd0],>_NUM_MODULES
 0422 550100            mov [_NUM_MODULES+1],0
 0425 550000            mov [_NUM_MODULES],0
 0428                   .dbline 376
 0428           ;               }
 0428 85D1              xjmp L83
 042A           L82:
 042A                   .dbline 377
 042A           ;               else if((param[0] == 'n') || (param[0] == 'N'))
 042A 62D000            mov REG[0xd0],>__r0
 042D 5201              mov A,[X+1]
 042F 5300              mov [__r1],A
 0431 5200              mov A,[X+0]
 0433 60D4              mov REG[0xd4],A
 0435 3E00              mvi A,[__r1]
 0437 5300              mov [__r1],A
 0439 550000            mov [__r0],0
 043C 3C0000            cmp [__r0],0
 043F B005              jnz X16
 0441 396E              cmp A,110
 0443 A00E              jz L87
 0445           X16:
 0445 62D000            mov REG[0xd0],>__r0
 0448 3C0000            cmp [__r0],0
 044B B035              jnz L85
 044D 3C004E            cmp [__r1],78
 0450 B030              jnz L85
 0452           X17:
 0452           L87:
 0452                   .dbline 378
 0452           ;               {
 0452                   .dbline 379
 0452           ;                       itoa(param,NUM_MODULES,10);             // Convert the NUM_MODULES int to a char array.
 0452 5000              mov A,0
 0454 08                push A
 0455 500A              mov A,10
 0457 08                push A
 0458 62D000            mov REG[0xd0],>_NUM_MODULES
 045B 5100              mov A,[_NUM_MODULES]
 045D 08                push A
 045E 5101              mov A,[_NUM_MODULES+1]
 0460 08                push A
 0461 5200              mov A,[X+0]
 0463 08                push A
 0464 5201              mov A,[X+1]
 0466 08                push A
 0467 7C0000            xcall _itoa
 046A 38FA              add SP,-6
 046C                   .dbline 380
 046C           ;                       COMP_SERIAL_PutString(param);   // Send that array out to the PC.
 046C 10                push X
 046D 5200              mov A,[X+0]
 046F 08                push A
 0470 5201              mov A,[X+1]
 0472 5C                mov X,A
 0473 18                pop A
 0474 7C0000            xcall _COMP_SERIAL_PutString
 0477 20                pop X
 0478                   .dbline 381
 0478           ;                       COMP_SERIAL_PutChar('\n');              // End the transmission with the PC.
 0478 10                push X
 0479 500A              mov A,10
 047B 7C0000            xcall _COMP_SERIAL_PutChar
 047E 20                pop X
 047F                   .dbline 382
 047F           ;               }
 047F 857A              xjmp L86
 0481           L85:
 0481                   .dbline 383
 0481           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 0481 62D000            mov REG[0xd0],>__r0
 0484 5201              mov A,[X+1]
 0486 5300              mov [__r1],A
 0488 5200              mov A,[X+0]
 048A 60D4              mov REG[0xd4],A
 048C 3E00              mvi A,[__r1]
 048E 5300              mov [__r1],A
 0490 550000            mov [__r0],0
 0493 3C0000            cmp [__r0],0
 0496 B005              jnz X18
 0498 3977              cmp A,119
 049A A00E              jz L90
 049C           X18:
 049C 62D000            mov REG[0xd0],>__r0
 049F 3C0000            cmp [__r0],0
 04A2 B214              jnz L88
 04A4 3C0057            cmp [__r1],87
 04A7 B20F              jnz L88
 04A9           X19:
 04A9           L90:
 04A9                   .dbline 384
 04A9           ;               {
 04A9                   .dbline 385
 04A9           ;                       if(param = COMP_SERIAL_szGetParam())
 04A9 10                push X
 04AA 7C0000            xcall _COMP_SERIAL_szGetParam
 04AD 62D000            mov REG[0xd0],>__r0
 04B0 5300              mov [__r0],A
 04B2 5A00              mov [__r1],X
 04B4 20                pop X
 04B5 5100              mov A,[__r1]
 04B7 5401              mov [X+1],A
 04B9 5100              mov A,[__r0]
 04BB 5400              mov [X+0],A
 04BD 3C0000            cmp [__r0],0
 04C0 B006              jnz X20
 04C2 3C0000            cmp [__r1],0
 04C5 A534              jz L89
 04C7           X20:
 04C7                   .dbline 386
 04C7           ;                       {
 04C7                   .dbline 388
 04C7           ;                               // Convert the ID parameter to a char byte.
 04C7           ;                               ID = atoi(param);
 04C7 5200              mov A,[X+0]
 04C9 08                push A
 04CA 5201              mov A,[X+1]
 04CC 08                push A
 04CD 7C0000            xcall _atoi
 04D0 38FE              add SP,-2
 04D2 62D000            mov REG[0xd0],>__r0
 04D5 5100              mov A,[__r1]
 04D7 5405              mov [X+5],A
 04D9                   .dbline 390
 04D9           ;                               
 04D9           ;                               if(param = COMP_SERIAL_szGetParam())
 04D9 10                push X
 04DA 7C0000            xcall _COMP_SERIAL_szGetParam
 04DD 62D000            mov REG[0xd0],>__r0
 04E0 5300              mov [__r0],A
 04E2 5A00              mov [__r1],X
 04E4 20                pop X
 04E5 5100              mov A,[__r1]
 04E7 5401              mov [X+1],A
 04E9 5100              mov A,[__r0]
 04EB 5400              mov [X+0],A
 04ED 3C0000            cmp [__r0],0
 04F0 B006              jnz X21
 04F2 3C0000            cmp [__r1],0
 04F5 A504              jz L89
 04F7           X21:
 04F7                   .dbline 391
 04F7           ;                               {
 04F7                   .dbline 392
 04F7           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 04F7 62D000            mov REG[0xd0],>__r0
 04FA 5201              mov A,[X+1]
 04FC 5300              mov [__r1],A
 04FE 5200              mov A,[X+0]
 0500 60D4              mov REG[0xd4],A
 0502 3E00              mvi A,[__r1]
 0504 5300              mov [__r1],A
 0506 550000            mov [__r0],0
 0509 3C0000            cmp [__r0],0
 050C B005              jnz X22
 050E 3961              cmp A,97
 0510 A00E              jz L97
 0512           X22:
 0512 62D000            mov REG[0xd0],>__r0
 0515 3C0000            cmp [__r0],0
 0518 B084              jnz L95
 051A 3C0041            cmp [__r1],65
 051D B07F              jnz L95
 051F           X23:
 051F           L97:
 051F                   .dbline 393
 051F           ;                                       {
 051F                   .dbline 394
 051F           ;                                               if(param = COMP_SERIAL_szGetParam())
 051F 10                push X
 0520 7C0000            xcall _COMP_SERIAL_szGetParam
 0523 62D000            mov REG[0xd0],>__r0
 0526 5300              mov [__r0],A
 0528 5A00              mov [__r1],X
 052A 20                pop X
 052B 5100              mov A,[__r1]
 052D 5401              mov [X+1],A
 052F 5100              mov A,[__r0]
 0531 5400              mov [X+0],A
 0533 3C0000            cmp [__r0],0
 0536 B006              jnz X24
 0538 3C0000            cmp [__r1],0
 053B A4BE              jz L89
 053D           X24:
 053D                   .dbline 395
 053D           ;                                               {
 053D                   .dbline 397
 053D           ;                                                       // Get the angle parameter and convert it to an integer.
 053D           ;                                                       total = atoi(param);
 053D 5200              mov A,[X+0]
 053F 08                push A
 0540 5201              mov A,[X+1]
 0542 08                push A
 0543 7C0000            xcall _atoi
 0546 38FE              add SP,-2
 0548 62D000            mov REG[0xd0],>__r0
 054B 5100              mov A,[__r1]
 054D 5407              mov [X+7],A
 054F 5100              mov A,[__r0]
 0551 5406              mov [X+6],A
 0553                   .dbline 400
 0553           ;                                                       
 0553           ;                                                       // Convert the integer into bytes.
 0553           ;                                                       angle[0] = total%256;
 0553 5001              mov A,1
 0555 08                push A
 0556 5000              mov A,0
 0558 08                push A
 0559 5206              mov A,[X+6]
 055B 08                push A
 055C 5207              mov A,[X+7]
 055E 08                push A
 055F 7C0000            xcall __divmod_16X16_16
 0562 38FE              add SP,-2
 0564 18                pop A
 0565 5300              mov [__r1],A
 0567 18                pop A
 0568 5100              mov A,[__r1]
 056A 5408              mov [X+8],A
 056C                   .dbline 401
 056C           ;                                                       angle[1] = total/256;
 056C 5001              mov A,1
 056E 08                push A
 056F 5000              mov A,0
 0571 08                push A
 0572 5206              mov A,[X+6]
 0574 08                push A
 0575 5207              mov A,[X+7]
 0577 08                push A
 0578 7C0000            xcall __divmod_16X16_16
 057B 18                pop A
 057C 5300              mov [__r1],A
 057E 18                pop A
 057F 38FE              add SP,-2
 0581 5100              mov A,[__r1]
 0583 5409              mov [X+9],A
 0585                   .dbline 404
 0585           ;                                                       
 0585           ;                                                       // Send the servo the angle.
 0585           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 0585 5209              mov A,[X+9]
 0587 08                push A
 0588 5208              mov A,[X+8]
 058A 08                push A
 058B 501E              mov A,30
 058D 08                push A
 058E 5003              mov A,3
 0590 08                push A
 0591 5005              mov A,5
 0593 08                push A
 0594 5205              mov A,[X+5]
 0596 08                push A
 0597 9576              xcall _longServoInstruction
 0599 38FA              add SP,-6
 059B                   .dbline 405
 059B           ;                                               }
 059B                   .dbline 406
 059B           ;                                       }
 059B 845E              xjmp L89
 059D           L95:
 059D                   .dbline 407
 059D           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 059D 62D000            mov REG[0xd0],>__r0
 05A0 5201              mov A,[X+1]
 05A2 5300              mov [__r1],A
 05A4 5200              mov A,[X+0]
 05A6 60D4              mov REG[0xd4],A
 05A8 3E00              mvi A,[__r1]
 05AA 5300              mov [__r1],A
 05AC 550000            mov [__r0],0
 05AF 3C0000            cmp [__r0],0
 05B2 B005              jnz X25
 05B4 3970              cmp A,112
 05B6 A00E              jz L104
 05B8           X25:
 05B8 62D000            mov REG[0xd0],>__r0
 05BB 3C0000            cmp [__r0],0
 05BE B045              jnz L102
 05C0 3C0050            cmp [__r1],80
 05C3 B040              jnz L102
 05C5           X26:
 05C5           L104:
 05C5                   .dbline 408
 05C5           ;                                       {
 05C5                   .dbline 409
 05C5           ;                                               if(param = COMP_SERIAL_szGetParam())
 05C5 10                push X
 05C6 7C0000            xcall _COMP_SERIAL_szGetParam
 05C9 62D000            mov REG[0xd0],>__r0
 05CC 5300              mov [__r0],A
 05CE 5A00              mov [__r1],X
 05D0 20                pop X
 05D1 5100              mov A,[__r1]
 05D3 5401              mov [X+1],A
 05D5 5100              mov A,[__r0]
 05D7 5400              mov [X+0],A
 05D9 3C0000            cmp [__r0],0
 05DC B006              jnz X27
 05DE 3C0000            cmp [__r1],0
 05E1 A418              jz L89
 05E3           X27:
 05E3                   .dbline 410
 05E3           ;                                               {
 05E3                   .dbline 412
 05E3           ;                                                       // Send the servo the desired power value.
 05E3           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 05E3 5200              mov A,[X+0]
 05E5 08                push A
 05E6 5201              mov A,[X+1]
 05E8 08                push A
 05E9 7C0000            xcall _atoi
 05EC 62D000            mov REG[0xd0],>__r0
 05EF 5100              mov A,[__r1]
 05F1 08                push A
 05F2 5018              mov A,24
 05F4 08                push A
 05F5 5003              mov A,3
 05F7 08                push A
 05F8 5004              mov A,4
 05FA 08                push A
 05FB 5205              mov A,[X+5]
 05FD 08                push A
 05FE 9425              xcall _servoInstruction
 0600 38F9              add SP,-7
 0602                   .dbline 413
 0602           ;                                               }
 0602                   .dbline 414
 0602           ;                                       }
 0602 83F7              xjmp L89
 0604           L102:
 0604                   .dbline 415
 0604           ;                                       else if((param[0] == 's') || (param[0] == 'S'))
 0604 62D000            mov REG[0xd0],>__r0
 0607 5201              mov A,[X+1]
 0609 5300              mov [__r1],A
 060B 5200              mov A,[X+0]
 060D 60D4              mov REG[0xd4],A
 060F 3E00              mvi A,[__r1]
 0611 5300              mov [__r1],A
 0613 550000            mov [__r0],0
 0616 3C0000            cmp [__r0],0
 0619 B005              jnz X28
 061B 3973              cmp A,115
 061D A00E              jz L109
 061F           X28:
 061F 62D000            mov REG[0xd0],>__r0
 0622 3C0000            cmp [__r0],0
 0625 B3D4              jnz L89
 0627 3C0053            cmp [__r1],83
 062A B3CF              jnz L89
 062C           X29:
 062C           L109:
 062C                   .dbline 416
 062C           ;                                       {
 062C                   .dbline 417
 062C           ;                                               if(param = COMP_SERIAL_szGetParam())
 062C 10                push X
 062D 7C0000            xcall _COMP_SERIAL_szGetParam
 0630 62D000            mov REG[0xd0],>__r0
 0633 5300              mov [__r0],A
 0635 5A00              mov [__r1],X
 0637 20                pop X
 0638 5100              mov A,[__r1]
 063A 5401              mov [X+1],A
 063C 5100              mov A,[__r0]
 063E 5400              mov [X+0],A
 0640 3C0000            cmp [__r0],0
 0643 B006              jnz X30
 0645 3C0000            cmp [__r1],0
 0648 A3B1              jz L89
 064A           X30:
 064A                   .dbline 418
 064A           ;                                               {
 064A                   .dbline 420
 064A           ;                                                       // Get the speed parameter and convert it to an integer.
 064A           ;                                                       total = atoi(param);
 064A 5200              mov A,[X+0]
 064C 08                push A
 064D 5201              mov A,[X+1]
 064F 08                push A
 0650 7C0000            xcall _atoi
 0653 38FE              add SP,-2
 0655 62D000            mov REG[0xd0],>__r0
 0658 5100              mov A,[__r1]
 065A 5407              mov [X+7],A
 065C 5100              mov A,[__r0]
 065E 5406              mov [X+6],A
 0660                   .dbline 423
 0660           ;                                                       
 0660           ;                                                       // If no total, do nothing because 0 is no speed control (undesired).
 0660           ;                                                       if(total)
 0660 3D0600            cmp [X+6],0
 0663 B006              jnz X31
 0665 3D0700            cmp [X+7],0
 0668 A391              jz L89
 066A           X31:
 066A                   .dbline 424
 066A           ;                                                       {
 066A                   .dbline 426
 066A           ;                                                               // Convert the integer into bytes.
 066A           ;                                                               speed[0] = total%256;
 066A 62D000            mov REG[0xd0],>__r0
 066D 5001              mov A,1
 066F 08                push A
 0670 5000              mov A,0
 0672 08                push A
 0673 5206              mov A,[X+6]
 0675 08                push A
 0676 5207              mov A,[X+7]
 0678 08                push A
 0679 7C0000            xcall __divmod_16X16_16
 067C 38FE              add SP,-2
 067E 18                pop A
 067F 5300              mov [__r1],A
 0681 18                pop A
 0682 5100              mov A,[__r1]
 0684 540A              mov [X+10],A
 0686                   .dbline 427
 0686           ;                                                               speed[1] = total/256;
 0686 5001              mov A,1
 0688 08                push A
 0689 5000              mov A,0
 068B 08                push A
 068C 5206              mov A,[X+6]
 068E 08                push A
 068F 5207              mov A,[X+7]
 0691 08                push A
 0692 7C0000            xcall __divmod_16X16_16
 0695 18                pop A
 0696 5300              mov [__r1],A
 0698 18                pop A
 0699 38FE              add SP,-2
 069B 5100              mov A,[__r1]
 069D 540B              mov [X+11],A
 069F                   .dbline 430
 069F           ;                                                               
 069F           ;                                                               // Write the speed value to the servo.
 069F           ;                                                               longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
 069F 520B              mov A,[X+11]
 06A1 08                push A
 06A2 520A              mov A,[X+10]
 06A4 08                push A
 06A5 5020              mov A,32
 06A7 08                push A
 06A8 5003              mov A,3
 06AA 08                push A
 06AB 5005              mov A,5
 06AD 08                push A
 06AE 5205              mov A,[X+5]
 06B0 08                push A
 06B1 945C              xcall _longServoInstruction
 06B3 38FA              add SP,-6
 06B5                   .dbline 431
 06B5           ;                                                       }
 06B5                   .dbline 432
 06B5           ;                                               }
 06B5                   .dbline 433
 06B5           ;                                       }
 06B5                   .dbline 434
 06B5           ;                               }
 06B5                   .dbline 435
 06B5           ;                       }
 06B5                   .dbline 436
 06B5           ;               }
 06B5 8344              xjmp L89
 06B7           L88:
 06B7                   .dbline 437
 06B7           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 06B7 62D000            mov REG[0xd0],>__r0
 06BA 5201              mov A,[X+1]
 06BC 5300              mov [__r1],A
 06BE 5200              mov A,[X+0]
 06C0 60D4              mov REG[0xd4],A
 06C2 3E00              mvi A,[__r1]
 06C4 5300              mov [__r1],A
 06C6 550000            mov [__r0],0
 06C9 3C0000            cmp [__r0],0
 06CC B005              jnz X32
 06CE 3972              cmp A,114
 06D0 A00E              jz L118
 06D2           X32:
 06D2 62D000            mov REG[0xd0],>__r0
 06D5 3C0000            cmp [__r0],0
 06D8 B321              jnz L116
 06DA 3C0052            cmp [__r1],82
 06DD B31C              jnz L116
 06DF           X33:
 06DF           L118:
 06DF                   .dbline 438
 06DF           ;               {                       
 06DF                   .dbline 439
 06DF           ;                       if(param = COMP_SERIAL_szGetParam())
 06DF 10                push X
 06E0 7C0000            xcall _COMP_SERIAL_szGetParam
 06E3 62D000            mov REG[0xd0],>__r0
 06E6 5300              mov [__r0],A
 06E8 5A00              mov [__r1],X
 06EA 20                pop X
 06EB 5100              mov A,[__r1]
 06ED 5401              mov [X+1],A
 06EF 5100              mov A,[__r0]
 06F1 5400              mov [X+0],A
 06F3 3C0000            cmp [__r0],0
 06F6 B006              jnz X34
 06F8 3C0000            cmp [__r1],0
 06FB A2FE              jz L119
 06FD           X34:
 06FD                   .dbline 440
 06FD           ;                       {
 06FD                   .dbline 442
 06FD           ;                               // Extract the target ID param and convert it to an integer.
 06FD           ;                               ID = atoi(param);
 06FD 5200              mov A,[X+0]
 06FF 08                push A
 0700 5201              mov A,[X+1]
 0702 08                push A
 0703 7C0000            xcall _atoi
 0706 38FE              add SP,-2
 0708 62D000            mov REG[0xd0],>__r0
 070B 5100              mov A,[__r1]
 070D 5405              mov [X+5],A
 070F                   .dbline 444
 070F           ;                               
 070F           ;                               if(param = COMP_SERIAL_szGetParam())
 070F 10                push X
 0710 7C0000            xcall _COMP_SERIAL_szGetParam
 0713 62D000            mov REG[0xd0],>__r0
 0716 5300              mov [__r0],A
 0718 5A00              mov [__r1],X
 071A 20                pop X
 071B 5100              mov A,[__r1]
 071D 5401              mov [X+1],A
 071F 5100              mov A,[__r0]
 0721 5400              mov [X+0],A
 0723 3C0000            cmp [__r0],0
 0726 B006              jnz X35
 0728 3C0000            cmp [__r1],0
 072B A2CE              jz L121
 072D           X35:
 072D                   .dbline 445
 072D           ;                               {
 072D                   .dbline 446
 072D           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 072D 62D000            mov REG[0xd0],>__r0
 0730 5201              mov A,[X+1]
 0732 5300              mov [__r1],A
 0734 5200              mov A,[X+0]
 0736 60D4              mov REG[0xd4],A
 0738 3E00              mvi A,[__r1]
 073A 5300              mov [__r1],A
 073C 550000            mov [__r0],0
 073F 3C0000            cmp [__r0],0
 0742 B005              jnz X36
 0744 3961              cmp A,97
 0746 A00E              jz L125
 0748           X36:
 0748 62D000            mov REG[0xd0],>__r0
 074B 3C0000            cmp [__r0],0
 074E B0C5              jnz L123
 0750 3C0041            cmp [__r1],65
 0753 B0C0              jnz L123
 0755           X37:
 0755           L125:
 0755                   .dbline 447
 0755           ;                                       {
 0755                   .dbline 449
 0755           ;                                               // Initialize the angle bytes to 0.
 0755           ;                                               angle[0] = 0;
 0755 560800            mov [X+8],0
 0758                   .dbline 450
 0758           ;                                               angle[1] = 0;
 0758 560900            mov [X+9],0
 075B                   .dbline 453
 075B           ;                                               
 075B           ;                                               // Send a request to the servo for its angle.
 075B           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 075B 5002              mov A,2
 075D 08                push A
 075E 5024              mov A,36
 0760 08                push A
 0761 5002              mov A,2
 0763 08                push A
 0764 5004              mov A,4
 0766 08                push A
 0767 5205              mov A,[X+5]
 0769 08                push A
 076A 92B9              xcall _servoInstruction
 076C                   .dbline 456
 076C           ;                                               
 076C           ;                                               // Switch to read the response.
 076C           ;                                               configToggle(RX_MODE);
 076C 5000              mov A,0
 076E 08                push A
 076F 5002              mov A,2
 0771 08                push A
 0772 949A              xcall _configToggle
 0774 38F9              add SP,-7
 0776 808C              xjmp L128
 0778           L127:
 0778                   .dbline 460
 0778           ;                                                       
 0778           ;                                               // Loop until we read a response or time out.
 0778           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0778           ;                                               {
 0778                   .dbline 462
 0778           ;                                                       // If the response is from the right ID...
 0778           ;                                                       if(iReadChar() == ID)
 0778 97FB              xcall _iReadChar
 077A 62D000            mov REG[0xd0],>__r0
 077D 3B05              cmp A,[X+5]
 077F B083              jnz L130
 0781                   .dbline 463
 0781           ;                                                       {
 0781 8072              xjmp L133
 0783           L132:
 0783                   .dbline 465
 0783           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0783           ;                                                               {
 0783                   .dbline 467
 0783           ;                                                                       // The length of the response remainder should be 4.
 0783           ;                                                                       if(iReadChar() == 4)
 0783 97F0              xcall _iReadChar
 0785 62D000            mov REG[0xd0],>__r0
 0788 3904              cmp A,4
 078A B069              jnz L135
 078C                   .dbline 468
 078C           ;                                                                       {
 078C                   .dbline 470
 078C           ;                                                                               // The error value should be 0 if successful.
 078C           ;                                                                               if(readChar() == 0)
 078C 7C0FC3            xcall _readChar
 078F 62D000            mov REG[0xd0],>__r0
 0792 3900              cmp A,0
 0794 B056              jnz L137
 0796                   .dbline 471
 0796           ;                                                                               {
 0796                   .dbline 473
 0796           ;                                                                                       // Grab the bytes from the buffer.
 0796           ;                                                                                       angle[0] = readChar();
 0796 7C0FC3            xcall _readChar
 0799 62D000            mov REG[0xd0],>__r0
 079C 5408              mov [X+8],A
 079E                   .dbline 474
 079E           ;                                                                                       angle[1] = readChar();
 079E 7C0FC3            xcall _readChar
 07A1 62D000            mov REG[0xd0],>__r0
 07A4 5409              mov [X+9],A
 07A6                   .dbline 477
 07A6           ;                                                                                       
 07A6           ;                                                                                       // Switch to PC mode to forward the response.
 07A6           ;                                                                                       configToggle(PC_MODE);
 07A6 5000              mov A,0
 07A8 08                push A
 07A9 5001              mov A,1
 07AB 08                push A
 07AC 9460              xcall _configToggle
 07AE                   .dbline 480
 07AE           ;                                                                                       
 07AE           ;                                                                                       // Convert the bytes to an integer.
 07AE           ;                                                                                       total = ((angle[1])*256) + angle[0];
 07AE 5208              mov A,[X+8]
 07B0 5407              mov [X+7],A
 07B2 5209              mov A,[X+9]
 07B4 5406              mov [X+6],A
 07B6                   .dbline 483
 07B6           ;                                                                                       
 07B6           ;                                                                                       // Convert the integer to a character array.
 07B6           ;                                                                                       itoa(param,total,10);
 07B6 5000              mov A,0
 07B8 08                push A
 07B9 500A              mov A,10
 07BB 08                push A
 07BC 5206              mov A,[X+6]
 07BE 08                push A
 07BF 5207              mov A,[X+7]
 07C1 08                push A
 07C2 5200              mov A,[X+0]
 07C4 08                push A
 07C5 5201              mov A,[X+1]
 07C7 08                push A
 07C8 7C0000            xcall _itoa
 07CB 38F8              add SP,-8
 07CD                   .dbline 486
 07CD           ;                                                                                       
 07CD           ;                                                                                       // Write the response to the computer.
 07CD           ;                                                                                       COMP_SERIAL_PutString(param);
 07CD 10                push X
 07CE 5200              mov A,[X+0]
 07D0 08                push A
 07D1 5201              mov A,[X+1]
 07D3 5C                mov X,A
 07D4 18                pop A
 07D5 7C0000            xcall _COMP_SERIAL_PutString
 07D8 20                pop X
 07D9                   .dbline 487
 07D9           ;                                                                                       COMP_SERIAL_PutChar('\n');
 07D9 10                push X
 07DA 500A              mov A,10
 07DC 7C0000            xcall _COMP_SERIAL_PutChar
 07DF 20                pop X
 07E0                   .dbline 490
 07E0           ; 
 07E0           ;                                                                                       // Force a timeout to exit all loops.
 07E0           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 07E0 62D000            mov REG[0xd0],>_TIMEOUT
 07E3 550105            mov [_TIMEOUT+1],5
 07E6 550000            mov [_TIMEOUT],0
 07E9                   .dbline 491
 07E9           ;                                                                               }
 07E9 800A              xjmp L138
 07EB           L137:
 07EB                   .dbline 493
 07EB           ;                                                                               else
 07EB           ;                                                                               {
 07EB                   .dbline 495
 07EB           ;                                                                                       // Force a timeout to exit all loops.
 07EB           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 07EB 62D000            mov REG[0xd0],>_TIMEOUT
 07EE 550105            mov [_TIMEOUT+1],5
 07F1 550000            mov [_TIMEOUT],0
 07F4                   .dbline 496
 07F4           ;                                                                               }
 07F4           L138:
 07F4                   .dbline 497
 07F4           ;                                                                       }
 07F4           L135:
 07F4                   .dbline 498
 07F4           ;                                                               }
 07F4           L133:
 07F4                   .dbline 464
 07F4 62D000            mov REG[0xd0],>_TIMEOUT
 07F7 5101              mov A,[_TIMEOUT+1]
 07F9 1105              sub A,5
 07FB 5100              mov A,[_TIMEOUT]
 07FD 3180              xor A,-128
 07FF 1980              sbb A,(0 ^ 0x80)
 0801 CF81              jc L132
 0803           X38:
 0803                   .dbline 499
 0803           ;                                                       }
 0803           L130:
 0803                   .dbline 500
 0803           ;                                               }
 0803           L128:
 0803                   .dbline 459
 0803 62D000            mov REG[0xd0],>_TIMEOUT
 0806 5101              mov A,[_TIMEOUT+1]
 0808 1105              sub A,5
 080A 5100              mov A,[_TIMEOUT]
 080C 3180              xor A,-128
 080E 1980              sbb A,(0 ^ 0x80)
 0810 CF67              jc L127
 0812           X39:
 0812                   .dbline 501
 0812           ;                                       }
 0812 81E7              xjmp L124
 0814           L123:
 0814                   .dbline 502
 0814           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 0814 62D000            mov REG[0xd0],>__r0
 0817 5201              mov A,[X+1]
 0819 5300              mov [__r1],A
 081B 5200              mov A,[X+0]
 081D 60D4              mov REG[0xd4],A
 081F 3E00              mvi A,[__r1]
 0821 5300              mov [__r1],A
 0823 550000            mov [__r0],0
 0826 3C0000            cmp [__r0],0
 0829 B005              jnz X40
 082B 3970              cmp A,112
 082D A00E              jz L143
 082F           X40:
 082F 62D000            mov REG[0xd0],>__r0
 0832 3C0000            cmp [__r0],0
 0835 B0E6              jnz L141
 0837 3C0050            cmp [__r1],80
 083A B0E1              jnz L141
 083C           X41:
 083C           L143:
 083C                   .dbline 503
 083C           ;                                       {
 083C                   .dbline 505
 083C           ;                                               // Send a request to the servo for its power status.
 083C           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 083C 5001              mov A,1
 083E 08                push A
 083F 5018              mov A,24
 0841 08                push A
 0842 5002              mov A,2
 0844 08                push A
 0845 5004              mov A,4
 0847 08                push A
 0848 5205              mov A,[X+5]
 084A 08                push A
 084B 91D8              xcall _servoInstruction
 084D                   .dbline 508
 084D           ;                                               
 084D           ;                                               // Switch to read the response.
 084D           ;                                               configToggle(RX_MODE);
 084D 5000              mov A,0
 084F 08                push A
 0850 5002              mov A,2
 0852 08                push A
 0853 93B9              xcall _configToggle
 0855 38F9              add SP,-7
 0857 80B3              xjmp L145
 0859           L144:
 0859                   .dbline 512
 0859           ;                                               
 0859           ;                                               // Loop until we read a response or time out.
 0859           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0859           ;                                               {
 0859                   .dbline 513
 0859           ;                                                       if(iReadChar() == ID)
 0859 971A              xcall _iReadChar
 085B 62D000            mov REG[0xd0],>__r0
 085E 3B05              cmp A,[X+5]
 0860 B0AA              jnz L147
 0862                   .dbline 514
 0862           ;                                                       {
 0862                   .dbline 515
 0862           ;                                                               runningTotal = ID;
 0862 5205              mov A,[X+5]
 0864 5404              mov [X+4],A
 0866 560300            mov [X+3],0
 0869 8092              xjmp L150
 086B           L149:
 086B                   .dbline 518
 086B           ;                                                               // Loop until we read a response or time out.
 086B           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 086B           ;                                                               {
 086B                   .dbline 520
 086B           ;                                                                       // Check the length of the packet.
 086B           ;                                                                       if(iReadChar() == 3)
 086B 9708              xcall _iReadChar
 086D 62D000            mov REG[0xd0],>__r0
 0870 3903              cmp A,3
 0872 B089              jnz L152
 0874                   .dbline 521
 0874           ;                                                                       {
 0874                   .dbline 523
 0874           ;                                                                               // Tack the value onto our running total.
 0874           ;                                                                               runningTotal += 3;
 0874 070403            add [X+4],3
 0877 0F0300            adc [X+3],0
 087A 8072              xjmp L155
 087C           L154:
 087C                   .dbline 527
 087C           ;                                                                               
 087C           ;                                                                               // Loop until we read a response or time out.
 087C           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 087C           ;                                                                               {
 087C                   .dbline 529
 087C           ;                                                                                       // Check for the checksum or 1.
 087C           ;                                                                                       if(tempByte = iReadChar())
 087C 96F7              xcall _iReadChar
 087E 62D000            mov REG[0xd0],>__r0
 0881 5402              mov [X+2],A
 0883 3900              cmp A,0
 0885 A067              jz L157
 0887                   .dbline 530
 0887           ;                                                                                       {
 0887                   .dbline 532
 0887           ;                                                                                               // Switch to PC mode to forward the result.
 0887           ;                                                                                               configToggle(PC_MODE);
 0887 5000              mov A,0
 0889 08                push A
 088A 5001              mov A,1
 088C 08                push A
 088D 937F              xcall _configToggle
 088F 38FE              add SP,-2
 0891                   .dbline 534
 0891           ;                                                                                               
 0891           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 0891 62D000            mov REG[0xd0],>__r0
 0894 5202              mov A,[X+2]
 0896 5300              mov [__r1],A
 0898 550000            mov [__r0],0
 089B 50FF              mov A,-1
 089D 1200              sub A,[__r1]
 089F 5300              mov [__r1],A
 08A1 5000              mov A,0
 08A3 1A00              sbb A,[__r0]
 08A5 5300              mov [__r0],A
 08A7 5001              mov A,1
 08A9 08                push A
 08AA 5000              mov A,0
 08AC 08                push A
 08AD 5203              mov A,[X+3]
 08AF 08                push A
 08B0 5204              mov A,[X+4]
 08B2 08                push A
 08B3 7C0000            xcall __divmod_16X16_16
 08B6 38FE              add SP,-2
 08B8 18                pop A
 08B9 5300              mov [__r3],A
 08BB 18                pop A
 08BC 3A00              cmp A,[__r0]
 08BE B017              jnz L159
 08C0 5100              mov A,[__r3]
 08C2 3A00              cmp A,[__r1]
 08C4 B011              jnz L159
 08C6           X42:
 08C6                   .dbline 535
 08C6           ;                                                                                               {
 08C6                   .dbline 537
 08C6           ;                                                                                                       // Send a 0 if we hit the checksum.
 08C6           ;                                                                                                       COMP_SERIAL_PutChar('0');
 08C6 10                push X
 08C7 5030              mov A,48
 08C9 7C0000            xcall _COMP_SERIAL_PutChar
 08CC 20                pop X
 08CD                   .dbline 538
 08CD           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 08CD 10                push X
 08CE 500A              mov A,10
 08D0 7C0000            xcall _COMP_SERIAL_PutChar
 08D3 20                pop X
 08D4                   .dbline 539
 08D4           ;                                                                                               }
 08D4 800F              xjmp L160
 08D6           L159:
 08D6                   .dbline 541
 08D6           ;                                                                                               else
 08D6           ;                                                                                               {
 08D6                   .dbline 543
 08D6           ;                                                                                                       // Send a 1 if we hit it first.
 08D6           ;                                                                                                       COMP_SERIAL_PutChar('1');
 08D6 10                push X
 08D7 5031              mov A,49
 08D9 7C0000            xcall _COMP_SERIAL_PutChar
 08DC 20                pop X
 08DD                   .dbline 544
 08DD           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 08DD 10                push X
 08DE 500A              mov A,10
 08E0 7C0000            xcall _COMP_SERIAL_PutChar
 08E3 20                pop X
 08E4                   .dbline 545
 08E4           ;                                                                                               }
 08E4           L160:
 08E4                   .dbline 547
 08E4           ;               
 08E4           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 08E4 62D000            mov REG[0xd0],>_TIMEOUT
 08E7 550105            mov [_TIMEOUT+1],5
 08EA 550000            mov [_TIMEOUT],0
 08ED                   .dbline 548
 08ED           ;                                                                                       }
 08ED           L157:
 08ED                   .dbline 549
 08ED           ;                                                                               }
 08ED           L155:
 08ED                   .dbline 526
 08ED 62D000            mov REG[0xd0],>_TIMEOUT
 08F0 5101              mov A,[_TIMEOUT+1]
 08F2 1105              sub A,5
 08F4 5100              mov A,[_TIMEOUT]
 08F6 3180              xor A,-128
 08F8 1980              sbb A,(0 ^ 0x80)
 08FA CF81              jc L154
 08FC           X43:
 08FC                   .dbline 550
 08FC           ;                                                                       }
 08FC           L152:
 08FC                   .dbline 551
 08FC           ;                                                               }
 08FC           L150:
 08FC                   .dbline 517
 08FC 62D000            mov REG[0xd0],>_TIMEOUT
 08FF 5101              mov A,[_TIMEOUT+1]
 0901 1105              sub A,5
 0903 5100              mov A,[_TIMEOUT]
 0905 3180              xor A,-128
 0907 1980              sbb A,(0 ^ 0x80)
 0909 CF61              jc L149
 090B           X44:
 090B                   .dbline 552
 090B           ;                                                       }
 090B           L147:
 090B                   .dbline 553
 090B           ;                                               }
 090B           L145:
 090B                   .dbline 511
 090B 62D000            mov REG[0xd0],>_TIMEOUT
 090E 5101              mov A,[_TIMEOUT+1]
 0910 1105              sub A,5
 0912 5100              mov A,[_TIMEOUT]
 0914 3180              xor A,-128
 0916 1980              sbb A,(0 ^ 0x80)
 0918 CF40              jc L144
 091A           X45:
 091A                   .dbline 554
 091A           ;                                       }
 091A 80DF              xjmp L142
 091C           L141:
 091C                   .dbline 555
 091C           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 091C 62D000            mov REG[0xd0],>__r0
 091F 5201              mov A,[X+1]
 0921 5300              mov [__r1],A
 0923 5200              mov A,[X+0]
 0925 60D4              mov REG[0xd4],A
 0927 3E00              mvi A,[__r1]
 0929 5300              mov [__r1],A
 092B 550000            mov [__r0],0
 092E 3C0000            cmp [__r0],0
 0931 B005              jnz X46
 0933 3974              cmp A,116
 0935 A00E              jz L163
 0937           X46:
 0937 62D000            mov REG[0xd0],>__r0
 093A 3C0000            cmp [__r0],0
 093D B042              jnz L161
 093F 3C0054            cmp [__r1],84
 0942 B03D              jnz L161
 0944           X47:
 0944           L163:
 0944                   .dbline 556
 0944           ;                                       {
 0944                   .dbline 558
 0944           ;                                               // Ping the module to get a status packet and return the data.
 0944           ;                                               if(pingModule(ID))
 0944 62D000            mov REG[0xd0],>__r0
 0947 5205              mov A,[X+5]
 0949 5300              mov [__r1],A
 094B 5000              mov A,0
 094D 08                push A
 094E 5100              mov A,[__r1]
 0950 08                push A
 0951 7C003D            xcall _pingModule
 0954 38FE              add SP,-2
 0956 62D000            mov REG[0xd0],>__r0
 0959 3C0000            cmp [__r0],0
 095C B006              jnz X48
 095E 3C0000            cmp [__r1],0
 0961 A098              jz L162
 0963           X48:
 0963                   .dbline 559
 0963           ;                                               {
 0963                   .dbline 560
 0963           ;                                                       configToggle(PC_MODE);
 0963 5000              mov A,0
 0965 08                push A
 0966 5001              mov A,1
 0968 08                push A
 0969 92A3              xcall _configToggle
 096B 38FE              add SP,-2
 096D                   .dbline 562
 096D           ;                                                                                               
 096D           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 096D 10                push X
 096E 62D000            mov REG[0xd0],>_PARAM
 0971 5100              mov A,[_PARAM]
 0973 7C0000            xcall _COMP_SERIAL_PutChar
 0976 20                pop X
 0977                   .dbline 563
 0977           ;                                                       COMP_SERIAL_PutChar('\n');
 0977 10                push X
 0978 500A              mov A,10
 097A 7C0000            xcall _COMP_SERIAL_PutChar
 097D 20                pop X
 097E                   .dbline 564
 097E           ;                                               }
 097E                   .dbline 565
 097E           ;                                       }
 097E 807B              xjmp L162
 0980           L161:
 0980                   .dbline 566
 0980           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0980 62D000            mov REG[0xd0],>__r0
 0983 5201              mov A,[X+1]
 0985 5300              mov [__r1],A
 0987 5200              mov A,[X+0]
 0989 60D4              mov REG[0xd4],A
 098B 3E00              mvi A,[__r1]
 098D 5300              mov [__r1],A
 098F 550000            mov [__r0],0
 0992 3C0000            cmp [__r0],0
 0995 B005              jnz X49
 0997 3963              cmp A,99
 0999 A00E              jz L168
 099B           X49:
 099B 62D000            mov REG[0xd0],>__r0
 099E 3C0000            cmp [__r0],0
 09A1 B058              jnz L166
 09A3 3C0043            cmp [__r1],67
 09A6 B053              jnz L166
 09A8           X50:
 09A8           L168:
 09A8                   .dbline 567
 09A8           ;                                       {
 09A8                   .dbline 570
 09A8           ;                                               // If this isn't for the parent, ing the module to get a
 09A8           ;                                               // status packet and return the data.
 09A8           ;                                               if(ID == 0)
 09A8 3D0500            cmp [X+5],0
 09AB B014              jnz L169
 09AD                   .dbline 571
 09AD           ;                                               {
 09AD                   .dbline 572
 09AD           ;                                                       COMP_SERIAL_PutChar(CHILD);
 09AD 10                push X
 09AE 62D000            mov REG[0xd0],>_CHILD
 09B1 5100              mov A,[_CHILD]
 09B3 7C0000            xcall _COMP_SERIAL_PutChar
 09B6 20                pop X
 09B7                   .dbline 573
 09B7           ;                                                       COMP_SERIAL_PutChar('\n');
 09B7 10                push X
 09B8 500A              mov A,10
 09BA 7C0000            xcall _COMP_SERIAL_PutChar
 09BD 20                pop X
 09BE                   .dbline 574
 09BE           ;                                               }
 09BE 803B              xjmp L170
 09C0           L169:
 09C0                   .dbline 575
 09C0           ;                                               else if(pingModule(ID))
 09C0 62D000            mov REG[0xd0],>__r0
 09C3 5205              mov A,[X+5]
 09C5 5300              mov [__r1],A
 09C7 5000              mov A,0
 09C9 08                push A
 09CA 5100              mov A,[__r1]
 09CC 08                push A
 09CD 7C003D            xcall _pingModule
 09D0 38FE              add SP,-2
 09D2 62D000            mov REG[0xd0],>__r0
 09D5 3C0000            cmp [__r0],0
 09D8 B006              jnz X51
 09DA 3C0000            cmp [__r1],0
 09DD A01C              jz L171
 09DF           X51:
 09DF                   .dbline 576
 09DF           ;                                               {       
 09DF                   .dbline 577
 09DF           ;                                                       configToggle(PC_MODE);
 09DF 5000              mov A,0
 09E1 08                push A
 09E2 5001              mov A,1
 09E4 08                push A
 09E5 9227              xcall _configToggle
 09E7 38FE              add SP,-2
 09E9                   .dbline 579
 09E9           ;                                                       
 09E9           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 09E9 10                push X
 09EA 62D000            mov REG[0xd0],>_PARAM
 09ED 5101              mov A,[_PARAM+1]
 09EF 7C0000            xcall _COMP_SERIAL_PutChar
 09F2 20                pop X
 09F3                   .dbline 580
 09F3           ;                                                       COMP_SERIAL_PutChar('\n');
 09F3 10                push X
 09F4 500A              mov A,10
 09F6 7C0000            xcall _COMP_SERIAL_PutChar
 09F9 20                pop X
 09FA                   .dbline 581
 09FA           ;                                               }
 09FA           L171:
 09FA           L170:
 09FA                   .dbline 582
 09FA           ;                                       }
 09FA           L166:
 09FA           L162:
 09FA           L142:
 09FA           L124:
 09FA                   .dbline 583
 09FA           ;                               }
 09FA           L121:
 09FA                   .dbline 584
 09FA           ;                       }
 09FA           L119:
 09FA                   .dbline 585
 09FA           ;               }
 09FA           L116:
 09FA           L89:
 09FA           L86:
 09FA           L83:
 09FA                   .dbline 586
 09FA           ;       }
 09FA           L80:
 09FA                   .dbline 589
 09FA           ;       
 09FA           ;       // Reset the timeout and switch to PC mode.
 09FA           ;       if(STATE != PC_MODE)
 09FA 62D000            mov REG[0xd0],>_STATE
 09FD 3C0000            cmp [_STATE],0
 0A00 B006              jnz X52
 0A02 3C0101            cmp [_STATE+1],1
 0A05 A00D              jz L174
 0A07           X52:
 0A07                   .dbline 590
 0A07           ;       {
 0A07                   .dbline 591
 0A07           ;               configToggle(PC_MODE);
 0A07 5000              mov A,0
 0A09 08                push A
 0A0A 5001              mov A,1
 0A0C 08                push A
 0A0D 91FF              xcall _configToggle
 0A0F 38FE              add SP,-2
 0A11                   .dbline 592
 0A11           ;       }
 0A11 800F              xjmp L175
 0A13           L174:
 0A13                   .dbline 594
 0A13           ;       else
 0A13           ;       {
 0A13                   .dbline 595
 0A13           ;               TIMEOUT = 0;
 0A13 62D000            mov REG[0xd0],>_TIMEOUT
 0A16 550100            mov [_TIMEOUT+1],0
 0A19 550000            mov [_TIMEOUT],0
 0A1C                   .dbline 596
 0A1C           ;               COMP_SERIAL_CmdReset();
 0A1C 10                push X
 0A1D 7C0000            xcall _COMP_SERIAL_CmdReset
 0A20 20                pop X
 0A21                   .dbline 597
 0A21           ;       }
 0A21           L175:
 0A21                   .dbline -2
 0A21           L79:
 0A21 38F4              add SP,-12
 0A23 20                pop X
 0A24                   .dbline 0 ; func end
 0A24 7F                ret
 0A25                   .dbsym l speed 10 A[2:2]c
 0A25                   .dbsym l angle 8 A[2:2]c
 0A25                   .dbsym l total 6 I
 0A25                   .dbsym l ID 5 c
 0A25                   .dbsym l runningTotal 3 I
 0A25                   .dbsym l tempByte 2 c
 0A25                   .dbsym l param 0 pc
 0A25                   .dbend
 0A25                   .dbfunc e servoInstruction _servoInstruction fV
 0A25           ;          total -> X+1
 0A25           ;       checksum -> X+0
 0A25           ;          value -> X-8
 0A25           ;        address -> X-7
 0A25           ;    instruction -> X-6
 0A25           ;         length -> X-5
 0A25           ;             id -> X-4
 0A25           _servoInstruction::
 0A25                   .dbline -1
 0A25 10                push X
 0A26 4F                mov X,SP
 0A27 3803              add SP,3
 0A29                   .dbline 603
 0A29           ; }
 0A29           ; 
 0A29           ; // This function receives a destination, command length, instruction type, address, and value.
 0A29           ; // With these parameters, the function sends a packet to the communication bus.
 0A29           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0A29           ; {
 0A29                   .dbline 608
 0A29           ;       char checksum;  // The checksum byte value.
 0A29           ;       int total;              // The total for use in calculating the checksum.
 0A29           ;       
 0A29           ;       // Get the total of all bytes.
 0A29           ;       total = id + length + instruction + address + value;
 0A29 62D000            mov REG[0xd0],>__r0
 0A2C 52FB              mov A,[X-5]
 0A2E 5300              mov [__r1],A
 0A30 550000            mov [__r0],0
 0A33 52FC              mov A,[X-4]
 0A35 0200              add A,[__r1]
 0A37 5300              mov [__r1],A
 0A39 5000              mov A,0
 0A3B 0A00              adc A,[__r0]
 0A3D 5300              mov [__r0],A
 0A3F 52FA              mov A,[X-6]
 0A41 0400              add [__r1],A
 0A43 0E0000            adc [__r0],0
 0A46 52F9              mov A,[X-7]
 0A48 0400              add [__r1],A
 0A4A 0E0000            adc [__r0],0
 0A4D 52F8              mov A,[X-8]
 0A4F 5300              mov [__r3],A
 0A51 550000            mov [__r2],0
 0A54 5100              mov A,[__r1]
 0A56 0200              add A,[__r3]
 0A58 5402              mov [X+2],A
 0A5A 5100              mov A,[__r0]
 0A5C 0A00              adc A,[__r2]
 0A5E 5401              mov [X+1],A
 0A60                   .dbline 611
 0A60           ;       
 0A60           ;       // Calculate the checksum value for our servo communication.
 0A60           ;       checksum = 255-(total%256);
 0A60 5001              mov A,1
 0A62 08                push A
 0A63 5000              mov A,0
 0A65 08                push A
 0A66 5201              mov A,[X+1]
 0A68 08                push A
 0A69 5202              mov A,[X+2]
 0A6B 08                push A
 0A6C 7C0000            xcall __divmod_16X16_16
 0A6F 38FE              add SP,-2
 0A71 18                pop A
 0A72 5300              mov [__r1],A
 0A74 18                pop A
 0A75 50FF              mov A,-1
 0A77 1200              sub A,[__r1]
 0A79 5400              mov [X+0],A
 0A7B                   .dbline 614
 0A7B           ;       
 0A7B           ;       // Talk to the servo.
 0A7B           ;       TX_REPEATER_014_PutChar(SERVO_START);   // Start byte one
 0A7B 10                push X
 0A7C 50FF              mov A,-1
 0A7E 7C0000            xcall _TX_REPEATER_014_PutChar
 0A81 20                pop X
 0A82                   .dbline 615
 0A82           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte one
 0A82 10                push X
 0A83 50FF              mov A,-1
 0A85 7C0000            xcall _TX_REPEATER_23_PutChar
 0A88 20                pop X
 0A89                   .dbline 616
 0A89           ;       TX_REPEATER_014_PutChar(SERVO_START);   // Start byte two
 0A89 10                push X
 0A8A 50FF              mov A,-1
 0A8C 7C0000            xcall _TX_REPEATER_014_PutChar
 0A8F 20                pop X
 0A90                   .dbline 617
 0A90           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte two
 0A90 10                push X
 0A91 50FF              mov A,-1
 0A93 7C0000            xcall _TX_REPEATER_23_PutChar
 0A96 20                pop X
 0A97                   .dbline 618
 0A97           ;       TX_REPEATER_014_PutChar(id);                    // The servo ID
 0A97 10                push X
 0A98 52FC              mov A,[X-4]
 0A9A 7C0000            xcall _TX_REPEATER_014_PutChar
 0A9D 20                pop X
 0A9E                   .dbline 619
 0A9E           ;       TX_REPEATER_23_PutChar(id);                             // The servo ID
 0A9E 10                push X
 0A9F 52FC              mov A,[X-4]
 0AA1 7C0000            xcall _TX_REPEATER_23_PutChar
 0AA4 20                pop X
 0AA5                   .dbline 620
 0AA5           ;       TX_REPEATER_014_PutChar(length);                // Remaining packet length
 0AA5 10                push X
 0AA6 52FB              mov A,[X-5]
 0AA8 7C0000            xcall _TX_REPEATER_014_PutChar
 0AAB 20                pop X
 0AAC                   .dbline 621
 0AAC           ;       TX_REPEATER_23_PutChar(length);                 // Remaining packet length
 0AAC 10                push X
 0AAD 52FB              mov A,[X-5]
 0AAF 7C0000            xcall _TX_REPEATER_23_PutChar
 0AB2 20                pop X
 0AB3                   .dbline 622
 0AB3           ;       TX_REPEATER_014_PutChar(instruction);   // Servo instruction
 0AB3 10                push X
 0AB4 52FA              mov A,[X-6]
 0AB6 7C0000            xcall _TX_REPEATER_014_PutChar
 0AB9 20                pop X
 0ABA                   .dbline 623
 0ABA           ;       TX_REPEATER_23_PutChar(instruction);    // Servo instruction
 0ABA 10                push X
 0ABB 52FA              mov A,[X-6]
 0ABD 7C0000            xcall _TX_REPEATER_23_PutChar
 0AC0 20                pop X
 0AC1                   .dbline 624
 0AC1           ;       TX_REPEATER_014_PutChar(address);               // Target memory address on the servo EEPROM
 0AC1 10                push X
 0AC2 52F9              mov A,[X-7]
 0AC4 7C0000            xcall _TX_REPEATER_014_PutChar
 0AC7 20                pop X
 0AC8                   .dbline 625
 0AC8           ;       TX_REPEATER_23_PutChar(address);                // Target memory address on the servo EEPROM
 0AC8 10                push X
 0AC9 52F9              mov A,[X-7]
 0ACB 7C0000            xcall _TX_REPEATER_23_PutChar
 0ACE 20                pop X
 0ACF                   .dbline 626
 0ACF           ;       TX_REPEATER_014_PutChar(value);                 // The write value or number of bytes to read
 0ACF 10                push X
 0AD0 52F8              mov A,[X-8]
 0AD2 7C0000            xcall _TX_REPEATER_014_PutChar
 0AD5 20                pop X
 0AD6                   .dbline 627
 0AD6           ;       TX_REPEATER_23_PutChar(value);                  // The write value or number of bytes to read
 0AD6 10                push X
 0AD7 52F8              mov A,[X-8]
 0AD9 7C0000            xcall _TX_REPEATER_23_PutChar
 0ADC 20                pop X
 0ADD                   .dbline 628
 0ADD           ;       TX_REPEATER_014_PutChar(checksum);              // This is the end of this transmission
 0ADD 10                push X
 0ADE 5200              mov A,[X+0]
 0AE0 7C0000            xcall _TX_REPEATER_014_PutChar
 0AE3 20                pop X
 0AE4                   .dbline 629
 0AE4           ;       TX_REPEATER_23_PutChar(checksum);               // This is the end of this transmission
 0AE4 10                push X
 0AE5 5200              mov A,[X+0]
 0AE7 7C0000            xcall _TX_REPEATER_23_PutChar
 0AEA 20                pop X
 0AEB           L177:
 0AEB                   .dbline 632
 0AEB           ;       
 0AEB           ;       // Wait for the transmission to finish.
 0AEB           ;       while(!(TX_REPEATER_014_bReadTxStatus() & TX_REPEATER_014_TX_COMPLETE));
 0AEB           L178:
 0AEB                   .dbline 632
 0AEB 10                push X
 0AEC 7C0000            xcall _TX_REPEATER_014_bReadTxStatus
 0AEF 62D000            mov REG[0xd0],>__r0
 0AF2 20                pop X
 0AF3 5300              mov [__r0],A
 0AF5 470020            tst [__r0],32
 0AF8 AFF2              jz L177
 0AFA           L180:
 0AFA                   .dbline 633
 0AFA           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 0AFA           L181:
 0AFA                   .dbline 633
 0AFA 10                push X
 0AFB 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 0AFE 62D000            mov REG[0xd0],>__r0
 0B01 20                pop X
 0B02 5300              mov [__r0],A
 0B04 470020            tst [__r0],32
 0B07 AFF2              jz L180
 0B09                   .dbline 636
 0B09           ;       
 0B09           ;       // Make completely sure we're done.
 0B09           ;       xmitWait();
 0B09 9506              xcall _xmitWait
 0B0B                   .dbline -2
 0B0B           L176:
 0B0B 38FD              add SP,-3
 0B0D 20                pop X
 0B0E                   .dbline 0 ; func end
 0B0E 7F                ret
 0B0F                   .dbsym l total 1 I
 0B0F                   .dbsym l checksum 0 c
 0B0F                   .dbsym l value -8 c
 0B0F                   .dbsym l address -7 c
 0B0F                   .dbsym l instruction -6 c
 0B0F                   .dbsym l length -5 c
 0B0F                   .dbsym l id -4 c
 0B0F                   .dbend
 0B0F                   .dbfunc e longServoInstruction _longServoInstruction fV
 0B0F           ;          total -> X+1
 0B0F           ;       checksum -> X+0
 0B0F           ;         value2 -> X-9
 0B0F           ;         value1 -> X-8
 0B0F           ;        address -> X-7
 0B0F           ;    instruction -> X-6
 0B0F           ;         length -> X-5
 0B0F           ;             id -> X-4
 0B0F           _longServoInstruction::
 0B0F                   .dbline -1
 0B0F 10                push X
 0B10 4F                mov X,SP
 0B11 3803              add SP,3
 0B13                   .dbline 641
 0B13           ; }
 0B13           ; 
 0B13           ; // This function receives a destination, command length, instruction type, address, and two values.
 0B13           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0B13           ; {
 0B13                   .dbline 646
 0B13           ;       char checksum;  // The checksum byte value.
 0B13           ;       int total;              // The total for use in calculating the checksum.
 0B13           ;       
 0B13           ;       // Get the total of all bytes.
 0B13           ;       total = id + length + instruction + address + value1 + value2;
 0B13 62D000            mov REG[0xd0],>__r0
 0B16 52FB              mov A,[X-5]
 0B18 5300              mov [__r1],A
 0B1A 550000            mov [__r0],0
 0B1D 52FC              mov A,[X-4]
 0B1F 0200              add A,[__r1]
 0B21 5300              mov [__r1],A
 0B23 5000              mov A,0
 0B25 0A00              adc A,[__r0]
 0B27 5300              mov [__r0],A
 0B29 52FA              mov A,[X-6]
 0B2B 0400              add [__r1],A
 0B2D 0E0000            adc [__r0],0
 0B30 52F9              mov A,[X-7]
 0B32 0400              add [__r1],A
 0B34 0E0000            adc [__r0],0
 0B37 52F8              mov A,[X-8]
 0B39 0400              add [__r1],A
 0B3B 0E0000            adc [__r0],0
 0B3E 52F7              mov A,[X-9]
 0B40 5300              mov [__r3],A
 0B42 550000            mov [__r2],0
 0B45 5100              mov A,[__r1]
 0B47 0200              add A,[__r3]
 0B49 5402              mov [X+2],A
 0B4B 5100              mov A,[__r0]
 0B4D 0A00              adc A,[__r2]
 0B4F 5401              mov [X+1],A
 0B51                   .dbline 649
 0B51           ;       
 0B51           ;       // Calculate the checksum value for our servo communication.
 0B51           ;       checksum = 255-(total%256);
 0B51 5001              mov A,1
 0B53 08                push A
 0B54 5000              mov A,0
 0B56 08                push A
 0B57 5201              mov A,[X+1]
 0B59 08                push A
 0B5A 5202              mov A,[X+2]
 0B5C 08                push A
 0B5D 7C0000            xcall __divmod_16X16_16
 0B60 38FE              add SP,-2
 0B62 18                pop A
 0B63 5300              mov [__r1],A
 0B65 18                pop A
 0B66 50FF              mov A,-1
 0B68 1200              sub A,[__r1]
 0B6A 5400              mov [X+0],A
 0B6C                   .dbline 652
 0B6C           ;       
 0B6C           ;       // Talk to the servo.
 0B6C           ;       TX_REPEATER_014_PutChar(SERVO_START);   // Start byte one
 0B6C 10                push X
 0B6D 50FF              mov A,-1
 0B6F 7C0000            xcall _TX_REPEATER_014_PutChar
 0B72 20                pop X
 0B73                   .dbline 653
 0B73           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte one
 0B73 10                push X
 0B74 50FF              mov A,-1
 0B76 7C0000            xcall _TX_REPEATER_23_PutChar
 0B79 20                pop X
 0B7A                   .dbline 654
 0B7A           ;       TX_REPEATER_014_PutChar(SERVO_START);   // Start byte two
 0B7A 10                push X
 0B7B 50FF              mov A,-1
 0B7D 7C0000            xcall _TX_REPEATER_014_PutChar
 0B80 20                pop X
 0B81                   .dbline 655
 0B81           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte two
 0B81 10                push X
 0B82 50FF              mov A,-1
 0B84 7C0000            xcall _TX_REPEATER_23_PutChar
 0B87 20                pop X
 0B88                   .dbline 656
 0B88           ;       TX_REPEATER_014_PutChar(id);                    // The servo ID
 0B88 10                push X
 0B89 52FC              mov A,[X-4]
 0B8B 7C0000            xcall _TX_REPEATER_014_PutChar
 0B8E 20                pop X
 0B8F                   .dbline 657
 0B8F           ;       TX_REPEATER_23_PutChar(id);                             // The servo ID
 0B8F 10                push X
 0B90 52FC              mov A,[X-4]
 0B92 7C0000            xcall _TX_REPEATER_23_PutChar
 0B95 20                pop X
 0B96                   .dbline 658
 0B96           ;       TX_REPEATER_014_PutChar(length);                // Remaining packet length
 0B96 10                push X
 0B97 52FB              mov A,[X-5]
 0B99 7C0000            xcall _TX_REPEATER_014_PutChar
 0B9C 20                pop X
 0B9D                   .dbline 659
 0B9D           ;       TX_REPEATER_23_PutChar(length);                 // Remaining packet length
 0B9D 10                push X
 0B9E 52FB              mov A,[X-5]
 0BA0 7C0000            xcall _TX_REPEATER_23_PutChar
 0BA3 20                pop X
 0BA4                   .dbline 660
 0BA4           ;       TX_REPEATER_014_PutChar(instruction);   // Servo instruction
 0BA4 10                push X
 0BA5 52FA              mov A,[X-6]
 0BA7 7C0000            xcall _TX_REPEATER_014_PutChar
 0BAA 20                pop X
 0BAB                   .dbline 661
 0BAB           ;       TX_REPEATER_23_PutChar(instruction);    // Servo instruction
 0BAB 10                push X
 0BAC 52FA              mov A,[X-6]
 0BAE 7C0000            xcall _TX_REPEATER_23_PutChar
 0BB1 20                pop X
 0BB2                   .dbline 662
 0BB2           ;       TX_REPEATER_014_PutChar(address);               // Target memory address on the servo EEPROM
 0BB2 10                push X
 0BB3 52F9              mov A,[X-7]
 0BB5 7C0000            xcall _TX_REPEATER_014_PutChar
 0BB8 20                pop X
 0BB9                   .dbline 663
 0BB9           ;       TX_REPEATER_23_PutChar(address);                // Target memory address on the servo EEPROM
 0BB9 10                push X
 0BBA 52F9              mov A,[X-7]
 0BBC 7C0000            xcall _TX_REPEATER_23_PutChar
 0BBF 20                pop X
 0BC0                   .dbline 664
 0BC0           ;       TX_REPEATER_014_PutChar(value1);                // The first write value
 0BC0 10                push X
 0BC1 52F8              mov A,[X-8]
 0BC3 7C0000            xcall _TX_REPEATER_014_PutChar
 0BC6 20                pop X
 0BC7                   .dbline 665
 0BC7           ;       TX_REPEATER_23_PutChar(value1);                 // The first write value
 0BC7 10                push X
 0BC8 52F8              mov A,[X-8]
 0BCA 7C0000            xcall _TX_REPEATER_23_PutChar
 0BCD 20                pop X
 0BCE                   .dbline 666
 0BCE           ;       TX_REPEATER_014_PutChar(value2);                // The second write value
 0BCE 10                push X
 0BCF 52F7              mov A,[X-9]
 0BD1 7C0000            xcall _TX_REPEATER_014_PutChar
 0BD4 20                pop X
 0BD5                   .dbline 667
 0BD5           ;       TX_REPEATER_23_PutChar(value2);                 // The second write value
 0BD5 10                push X
 0BD6 52F7              mov A,[X-9]
 0BD8 7C0000            xcall _TX_REPEATER_23_PutChar
 0BDB 20                pop X
 0BDC                   .dbline 668
 0BDC           ;       TX_REPEATER_014_PutChar(checksum);              // This is the end of this transmission
 0BDC 10                push X
 0BDD 5200              mov A,[X+0]
 0BDF 7C0000            xcall _TX_REPEATER_014_PutChar
 0BE2 20                pop X
 0BE3                   .dbline 669
 0BE3           ;       TX_REPEATER_23_PutChar(checksum);               // This is the end of this transmission
 0BE3 10                push X
 0BE4 5200              mov A,[X+0]
 0BE6 7C0000            xcall _TX_REPEATER_23_PutChar
 0BE9 20                pop X
 0BEA           L184:
 0BEA                   .dbline 672
 0BEA           ;       
 0BEA           ;       // Wait for the transmission to finish.
 0BEA           ;       while(!(TX_REPEATER_014_bReadTxStatus() & TX_REPEATER_014_TX_COMPLETE));
 0BEA           L185:
 0BEA                   .dbline 672
 0BEA 10                push X
 0BEB 7C0000            xcall _TX_REPEATER_014_bReadTxStatus
 0BEE 62D000            mov REG[0xd0],>__r0
 0BF1 20                pop X
 0BF2 5300              mov [__r0],A
 0BF4 470020            tst [__r0],32
 0BF7 AFF2              jz L184
 0BF9           L187:
 0BF9                   .dbline 673
 0BF9           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 0BF9           L188:
 0BF9                   .dbline 673
 0BF9 10                push X
 0BFA 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 0BFD 62D000            mov REG[0xd0],>__r0
 0C00 20                pop X
 0C01 5300              mov [__r0],A
 0C03 470020            tst [__r0],32
 0C06 AFF2              jz L187
 0C08                   .dbline 676
 0C08           ;       
 0C08           ;       // Make completely sure we're done.
 0C08           ;       xmitWait();
 0C08 9407              xcall _xmitWait
 0C0A                   .dbline -2
 0C0A           L183:
 0C0A 38FD              add SP,-3
 0C0C 20                pop X
 0C0D                   .dbline 0 ; func end
 0C0D 7F                ret
 0C0E                   .dbsym l total 1 I
 0C0E                   .dbsym l checksum 0 c
 0C0E                   .dbsym l value2 -9 c
 0C0E                   .dbsym l value1 -8 c
 0C0E                   .dbsym l address -7 c
 0C0E                   .dbsym l instruction -6 c
 0C0E                   .dbsym l length -5 c
 0C0E                   .dbsym l id -4 c
 0C0E                   .dbend
 0C0E                   .dbfunc e configToggle _configToggle fV
 0C0E           ;           mode -> X-5
 0C0E           _configToggle::
 0C0E                   .dbline -1
 0C0E 10                push X
 0C0F 4F                mov X,SP
 0C10                   .dbline 682
 0C10           ; }
 0C10           ; 
 0C10           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0C10           ; // half duplex UART serial communication line.
 0C10           ; void configToggle(int mode)
 0C10           ; {
 0C10                   .dbline 684
 0C10           ;       // Disconnect from the global bus and leave the pin high.
 0C10           ;       PRT0DR |= 0b11111111;
 0C10 4300FF            or REG[0],-1
 0C13                   .dbline 685
 0C13           ;       PRT0GS &= 0b00000000;
 0C13 620200            mov REG[0x2],0
 0C16                   .dbline 689
 0C16           ; 
 0C16           ;       // Unload the configuration of the current state.
 0C16           ;       // If there is no state, blindly wipe all configurations.
 0C16           ;       if(STATE)
 0C16 62D000            mov REG[0xd0],>_STATE
 0C19 3C0000            cmp [_STATE],0
 0C1C B006              jnz X53
 0C1E 3C0100            cmp [_STATE+1],0
 0C21 A010              jz L191
 0C23           X53:
 0C23                   .dbline 690
 0C23           ;       {
 0C23                   .dbline 691
 0C23           ;               unloadConfig(STATE);
 0C23 62D000            mov REG[0xd0],>_STATE
 0C26 5100              mov A,[_STATE]
 0C28 08                push A
 0C29 5101              mov A,[_STATE+1]
 0C2B 08                push A
 0C2C 90BA              xcall _unloadConfig
 0C2E 38FE              add SP,-2
 0C30                   .dbline 692
 0C30           ;       }
 0C30 8003              xjmp L192
 0C32           L191:
 0C32                   .dbline 694
 0C32           ;       else
 0C32           ;       {
 0C32                   .dbline 695
 0C32           ;               unloadAllConfigs();
 0C32 90AD              xcall _unloadAllConfigs
 0C34                   .dbline 696
 0C34           ;       }
 0C34           L192:
 0C34                   .dbline 698
 0C34           ;       
 0C34           ;       if(mode == PC_MODE)
 0C34 3DFB00            cmp [X-5],0
 0C37 B061              jnz L193
 0C39 3DFC01            cmp [X-4],1
 0C3C B05C              jnz L193
 0C3E           X54:
 0C3E                   .dbline 699
 0C3E           ;       {
 0C3E                   .dbline 700
 0C3E           ;               LoadConfig_pc_listener();
 0C3E 7C0000            xcall _LoadConfig_pc_listener
 0C41                   .dbline 702
 0C41           ; 
 0C41           ;               COMP_SERIAL_CmdReset();                                                         // Initialize the buffer.
 0C41 10                push X
 0C42 7C0000            xcall _COMP_SERIAL_CmdReset
 0C45 20                pop X
 0C46                   .dbline 703
 0C46           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT);         // Enable RX interrupts  
 0C46 10                push X
 0C47 5001              mov A,1
 0C49 7C0000            xcall _COMP_SERIAL_IntCntl
 0C4C 20                pop X
 0C4D                   .dbline 704
 0C4D           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                            // Starts the UART.
 0C4D 10                push X
 0C4E 5000              mov A,0
 0C50 7C0000            xcall _COMP_SERIAL_Start
 0C53 20                pop X
 0C54                   .dbline 706
 0C54           ;               
 0C54           ;               TX_REPEATER_014_Start(TX_REPEATER_014_PARITY_NONE);     // Start the 014 TX repeater.
 0C54 10                push X
 0C55 5000              mov A,0
 0C57 7C0000            xcall _TX_REPEATER_014_Start
 0C5A 20                pop X
 0C5B                   .dbline 707
 0C5B           ;               TX_REPEATER_23_Start(TX_REPEATER_23_PARITY_NONE);       // Start the 23 TX repeater.
 0C5B 10                push X
 0C5C 5000              mov A,0
 0C5E 7C0000            xcall _TX_REPEATER_23_Start
 0C61 20                pop X
 0C62                   .dbline 709
 0C62           ;               
 0C62           ;               TIMEOUT = 0;                    // Clear the timeout flag.
 0C62 62D000            mov REG[0xd0],>_TIMEOUT
 0C65 550100            mov [_TIMEOUT+1],0
 0C68 550000            mov [_TIMEOUT],0
 0C6B                   .dbline 710
 0C6B           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0C6B 10                push X
 0C6C 7C0000            xcall _TX_TIMEOUT_EnableInt
 0C6F                   .dbline 711
 0C6F           ;               TX_TIMEOUT_Start();             // Start the timer.
 0C6F 7C0000            xcall _TX_TIMEOUT_Start
 0C72 20                pop X
 0C73           L195:
 0C73                   .dbline 714
 0C73           ;               
 0C73           ;               // Do nothing while we allow everyone to load the right configuration.
 0C73           ;               while(!TIMEOUT){ }
 0C73                   .dbline 714
 0C73           L196:
 0C73                   .dbline 714
 0C73 62D000            mov REG[0xd0],>_TIMEOUT
 0C76 3C0000            cmp [_TIMEOUT],0
 0C79 B006              jnz X55
 0C7B 3C0100            cmp [_TIMEOUT+1],0
 0C7E AFF4              jz L195
 0C80           X55:
 0C80                   .dbline 717
 0C80           ;               
 0C80           ;               // Stop the timer and reset the timeout flag.
 0C80           ;               TX_TIMEOUT_Stop();
 0C80 10                push X
 0C81 7C0000            xcall _TX_TIMEOUT_Stop
 0C84 20                pop X
 0C85                   .dbline 718
 0C85           ;               TIMEOUT = 0;
 0C85 62D000            mov REG[0xd0],>_TIMEOUT
 0C88 550100            mov [_TIMEOUT+1],0
 0C8B 550000            mov [_TIMEOUT],0
 0C8E                   .dbline 721
 0C8E           ;               
 0C8E           ;               // Store the state.
 0C8E           ;               STATE = PC_MODE;
 0C8E 62D000            mov REG[0xd0],>_STATE
 0C91 550101            mov [_STATE+1],1
 0C94 550000            mov [_STATE],0
 0C97                   .dbline 722
 0C97           ;       }
 0C97 8044              xjmp L194
 0C99           L193:
 0C99                   .dbline 723
 0C99           ;       else if(mode == RX_MODE)
 0C99 3DFB00            cmp [X-5],0
 0C9C B03F              jnz L198
 0C9E 3DFC02            cmp [X-4],2
 0CA1 B03A              jnz L198
 0CA3           X56:
 0CA3                   .dbline 724
 0CA3           ;       {
 0CA3                   .dbline 725
 0CA3           ;               LoadConfig_receiver_config();
 0CA3 7C0000            xcall _LoadConfig_receiver_config
 0CA6                   .dbline 729
 0CA6           ;               
 0CA6           ;               // Start the receivers.
 0CA6           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0CA6           ;               {
 0CA6                   .dbline 731
 0CA6           ;               // Start listening for a response through child port 1.
 0CA6           ;               RECEIVE_1_Start(RECEIVE_1_PARITY_NONE);
 0CA6 10                push X
 0CA7 5000              mov A,0
 0CA9 7C0000            xcall _RECEIVE_1_Start
 0CAC 20                pop X
 0CAD                   .dbline 732
 0CAD           ;               }
 0CAD                   .dbline 734
 0CAD           ;               
 0CAD           ;               {
 0CAD                   .dbline 736
 0CAD           ;               // Start listening for a response through child port 2.
 0CAD           ;               RECEIVE_2_Start(RECEIVE_2_PARITY_NONE);
 0CAD 10                push X
 0CAE 5000              mov A,0
 0CB0 7C0000            xcall _RECEIVE_2_Start
 0CB3 20                pop X
 0CB4                   .dbline 737
 0CB4           ;               }
 0CB4                   .dbline 739
 0CB4           ;               
 0CB4           ;               {
 0CB4                   .dbline 741
 0CB4           ;               // Start listening for a response through child port 3.
 0CB4           ;               RECEIVE_3_Start(RECEIVE_3_PARITY_NONE);
 0CB4 10                push X
 0CB5 5000              mov A,0
 0CB7 7C0000            xcall _RECEIVE_3_Start
 0CBA 20                pop X
 0CBB                   .dbline 742
 0CBB           ;               }
 0CBB                   .dbline 744
 0CBB           ;               
 0CBB           ;               {
 0CBB                   .dbline 746
 0CBB           ;               // Start listening for a response through child port 4.
 0CBB           ;               RECEIVE_4_Start(RECEIVE_4_PARITY_NONE);
 0CBB 10                push X
 0CBC 5000              mov A,0
 0CBE 7C0000            xcall _RECEIVE_4_Start
 0CC1 20                pop X
 0CC2                   .dbline 747
 0CC2           ;               }
 0CC2                   .dbline 750
 0CC2           ;               
 0CC2           ;               // Start response timeout timer and enable its interrupt routine.
 0CC2           ;               TIMEOUT = 0;
 0CC2 62D000            mov REG[0xd0],>_TIMEOUT
 0CC5 550100            mov [_TIMEOUT+1],0
 0CC8 550000            mov [_TIMEOUT],0
 0CCB                   .dbline 751
 0CCB           ;               RX_TIMEOUT_EnableInt();
 0CCB 10                push X
 0CCC 7C0000            xcall _RX_TIMEOUT_EnableInt
 0CCF                   .dbline 752
 0CCF           ;               RX_TIMEOUT_Start();
 0CCF 7C0000            xcall _RX_TIMEOUT_Start
 0CD2 20                pop X
 0CD3                   .dbline 755
 0CD3           ;               
 0CD3           ;               // Store the state.
 0CD3           ;               STATE = RX_MODE;
 0CD3 62D000            mov REG[0xd0],>_STATE
 0CD6 550102            mov [_STATE+1],2
 0CD9 550000            mov [_STATE],0
 0CDC                   .dbline 756
 0CDC           ;       }
 0CDC           L198:
 0CDC           L194:
 0CDC                   .dbline 759
 0CDC           ;       
 0CDC           ;       // Reconnect to the global bus.
 0CDC           ;       PRT0GS |= 0b11111111;
 0CDC 4302FF            or REG[0x2],-1
 0CDF                   .dbline -2
 0CDF           L190:
 0CDF 20                pop X
 0CE0                   .dbline 0 ; func end
 0CE0 7F                ret
 0CE1                   .dbsym l mode -5 I
 0CE1                   .dbend
 0CE1                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0CE1           _unloadAllConfigs::
 0CE1                   .dbline -1
 0CE1                   .dbline 765
 0CE1           ; }
 0CE1           ; 
 0CE1           ; // This function blindly unloads all user configurations. This will be called once,
 0CE1           ; // when the system initially has no known state.
 0CE1           ; void unloadAllConfigs(void)
 0CE1           ; {
 0CE1                   .dbline 766
 0CE1           ;       UnloadConfig_pc_listener();
 0CE1 7C0000            xcall _UnloadConfig_pc_listener
 0CE4                   .dbline 767
 0CE4           ;       UnloadConfig_receiver_config();
 0CE4 7C0000            xcall _UnloadConfig_receiver_config
 0CE7                   .dbline -2
 0CE7           L200:
 0CE7                   .dbline 0 ; func end
 0CE7 7F                ret
 0CE8                   .dbend
 0CE8                   .dbfunc e unloadConfig _unloadConfig fV
 0CE8           ;     config_num -> X-5
 0CE8           _unloadConfig::
 0CE8                   .dbline -1
 0CE8 10                push X
 0CE9 4F                mov X,SP
 0CEA                   .dbline 773
 0CEA           ; }
 0CEA           ; 
 0CEA           ; // This function unloads the configuration corresponding to the config number passed to it.
 0CEA           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0CEA           ; void unloadConfig(int config_num)
 0CEA           ; {
 0CEA                   .dbline 774
 0CEA           ;       if(config_num == PC_MODE)
 0CEA 3DFB00            cmp [X-5],0
 0CED B00B              jnz L202
 0CEF 3DFC01            cmp [X-4],1
 0CF2 B006              jnz L202
 0CF4           X57:
 0CF4                   .dbline 775
 0CF4           ;       {
 0CF4                   .dbline 776
 0CF4           ;               UnloadConfig_pc_listener();
 0CF4 7C0000            xcall _UnloadConfig_pc_listener
 0CF7                   .dbline 777
 0CF7           ;       }
 0CF7 800E              xjmp L203
 0CF9           L202:
 0CF9                   .dbline 778
 0CF9           ;       else if(config_num == RX_MODE)
 0CF9 3DFB00            cmp [X-5],0
 0CFC B009              jnz L204
 0CFE 3DFC02            cmp [X-4],2
 0D01 B004              jnz L204
 0D03           X58:
 0D03                   .dbline 779
 0D03           ;       {
 0D03                   .dbline 780
 0D03           ;               UnloadConfig_receiver_config();
 0D03 7C0000            xcall _UnloadConfig_receiver_config
 0D06                   .dbline 781
 0D06           ;       }
 0D06           L204:
 0D06           L203:
 0D06                   .dbline -2
 0D06           L201:
 0D06 20                pop X
 0D07                   .dbline 0 ; func end
 0D07 7F                ret
 0D08                   .dbsym l config_num -5 I
 0D08                   .dbend
 0D08                   .dbfunc e initializeChildren _initializeChildren fV
 0D08           ;   num_timeouts -> X+4
 0D08           ;     ping_tries -> X+2
 0D08           ;              i -> X+0
 0D08           _initializeChildren::
 0D08                   .dbline -1
 0D08 10                push X
 0D09 4F                mov X,SP
 0D0A 3806              add SP,6
 0D0C                   .dbline 785
 0D0C           ; }
 0D0C           ; 
 0D0C           ; void initializeChildren(void)
 0D0C           ; {
 0D0C                   .dbline 786
 0D0C           ;       int num_timeouts = 0;   // The number of consecutive timeouts.
 0D0C 560500            mov [X+5],0
 0D0F 560400            mov [X+4],0
 0D12                   .dbline 787
 0D12           ;       int ping_tries = 5;             // The number of times to try a ping on an unregistered module.
 0D12 560305            mov [X+3],5
 0D15 560200            mov [X+2],0
 0D18                   .dbline 788
 0D18           ;       int i = 0;                              // An iterator for looping.
 0D18 560100            mov [X+1],0
 0D1B 560000            mov [X+0],0
 0D1E                   .dbline 791
 0D1E           ;       
 0D1E           ;       // Set num modules to zero.
 0D1E           ;       NUM_MODULES = 0;
 0D1E 62D000            mov REG[0xd0],>_NUM_MODULES
 0D21 550100            mov [_NUM_MODULES+1],0
 0D24 550000            mov [_NUM_MODULES],0
 0D27                   .dbline 794
 0D27           ;       
 0D27           ;       // Set the child value to zero.
 0D27           ;       CHILD = 0;      
 0D27 62D000            mov REG[0xd0],>_CHILD
 0D2A 550000            mov [_CHILD],0
 0D2D 8006              xjmp L208
 0D2F           L207:
 0D2F                   .dbline 797
 0D2F           ;       
 0D2F           ;       while(CHILD == 0)
 0D2F           ;       {
 0D2F                   .dbline 799
 0D2F           ;               // Send out a probing message.
 0D2F           ;               sayHello();
 0D2F 7C0261            xcall _sayHello
 0D32                   .dbline 802
 0D32           ;               
 0D32           ;               // Listen for a response.
 0D32           ;               childListen();
 0D32 9179              xcall _childListen
 0D34                   .dbline 803
 0D34           ;       }
 0D34           L208:
 0D34                   .dbline 796
 0D34 62D000            mov REG[0xd0],>_CHILD
 0D37 3C0000            cmp [_CHILD],0
 0D3A AFF4              jz L207
 0D3C                   .dbline 806
 0D3C           ;       
 0D3C           ;       // Send out a probing message.
 0D3C           ;       sayHello();
 0D3C 7C0261            xcall _sayHello
 0D3F 80EA              xjmp L211
 0D41           L210:
 0D41                   .dbline 811
 0D41           ;       
 0D41           ;       // This loop continuously probes and listens at intervals
 0D41           ;       // set by the RX_TIMEOUT_DURATION variable.
 0D41           ;       while(num_timeouts < MAX_TIMEOUTS)
 0D41           ;       {       
 0D41                   .dbline 812
 0D41           ;               if(validTransmission())
 0D41 7C02FB            xcall _validTransmission
 0D44 62D000            mov REG[0xd0],>__r0
 0D47 3C0000            cmp [__r0],0
 0D4A B006              jnz X59
 0D4C 3C0000            cmp [__r1],0
 0D4F A096              jz L213
 0D51           X59:
 0D51                   .dbline 813
 0D51           ;               {
 0D51                   .dbline 814
 0D51           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0D51 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0D54 3C00C8            cmp [_COMMAND_TYPE],-56
 0D57 B0D2              jnz L214
 0D59                   .dbline 815
 0D59           ;                       {
 0D59                   .dbline 817
 0D59           ;                               // If this is for me, assign them an ID.
 0D59           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 0D59 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0D5C 3C0000            cmp [_COMMAND_DESTINATION],0
 0D5F B0CA              jnz L214
 0D61                   .dbline 818
 0D61           ;                               {
 0D61                   .dbline 819
 0D61           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0D61 62D000            mov REG[0xd0],>_NUM_MODULES
 0D64 7601              inc [_NUM_MODULES+1]
 0D66 0E0000            adc [_NUM_MODULES],0
 0D69                   .dbline 820
 0D69           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0D69 560500            mov [X+5],0
 0D6C 560400            mov [X+4],0
 0D6F                   .dbline 822
 0D6F           ;               
 0D6F           ;                                       if(!assignID(NUM_MODULES))
 0D6F 5100              mov A,[_NUM_MODULES]
 0D71 08                push A
 0D72 5101              mov A,[_NUM_MODULES+1]
 0D74 08                push A
 0D75 7C0148            xcall _assignID
 0D78 38FE              add SP,-2
 0D7A 62D000            mov REG[0xd0],>__r0
 0D7D 3C0000            cmp [__r0],0
 0D80 B0A9              jnz L214
 0D82 3C0000            cmp [__r1],0
 0D85 B0A4              jnz L214
 0D87           X60:
 0D87                   .dbline 823
 0D87           ;                                       {
 0D87                   .dbline 827
 0D87           ;                                               // If the module did not respond that the ID was assigned,
 0D87           ;                                               // make an effort to ping it in case that transmission was lost
 0D87           ;                                               // before ultimately deciding that the module didn't configure.
 0D87           ;                                               for(i = 0; i < ping_tries; i++)
 0D87 560100            mov [X+1],0
 0D8A 560000            mov [X+0],0
 0D8D 802D              xjmp L224
 0D8F           L221:
 0D8F                   .dbline 828
 0D8F           ;                                               {       
 0D8F                   .dbline 829
 0D8F           ;                                                       if(pingModule(NUM_MODULES))
 0D8F 62D000            mov REG[0xd0],>_NUM_MODULES
 0D92 5100              mov A,[_NUM_MODULES]
 0D94 08                push A
 0D95 5101              mov A,[_NUM_MODULES+1]
 0D97 08                push A
 0D98 7C003D            xcall _pingModule
 0D9B 38FE              add SP,-2
 0D9D 62D000            mov REG[0xd0],>__r0
 0DA0 3C0000            cmp [__r0],0
 0DA3 B006              jnz X61
 0DA5 3C0000            cmp [__r1],0
 0DA8 A00D              jz L225
 0DAA           X61:
 0DAA                   .dbline 830
 0DAA           ;                                                       {
 0DAA                   .dbline 831
 0DAA           ;                                                               i = ping_tries+1;
 0DAA 5203              mov A,[X+3]
 0DAC 0101              add A,1
 0DAE 5401              mov [X+1],A
 0DB0 5202              mov A,[X+2]
 0DB2 0900              adc A,0
 0DB4 5400              mov [X+0],A
 0DB6                   .dbline 832
 0DB6           ;                                                       }
 0DB6           L225:
 0DB6                   .dbline 833
 0DB6           ;                                               }
 0DB6           L222:
 0DB6                   .dbline 827
 0DB6 7701              inc [X+1]
 0DB8 0F0000            adc [X+0],0
 0DBB           L224:
 0DBB                   .dbline 827
 0DBB 5201              mov A,[X+1]
 0DBD 1303              sub A,[X+3]
 0DBF 5202              mov A,[X+2]
 0DC1 3180              xor A,-128
 0DC3 62D000            mov REG[0xd0],>__r0
 0DC6 5300              mov [__rX],A
 0DC8 5200              mov A,[X+0]
 0DCA 3180              xor A,-128
 0DCC 1A00              sbb A,[__rX]
 0DCE CFC0              jc L221
 0DD0           X62:
 0DD0                   .dbline 836
 0DD0           ;                                               
 0DD0           ;                                               // If we landed right at ping_tries, we failed.
 0DD0           ;                                               if(i == ping_tries)
 0DD0 5200              mov A,[X+0]
 0DD2 3B02              cmp A,[X+2]
 0DD4 B055              jnz L214
 0DD6 5201              mov A,[X+1]
 0DD8 3B03              cmp A,[X+3]
 0DDA B04F              jnz L214
 0DDC           X63:
 0DDC                   .dbline 837
 0DDC           ;                                               {
 0DDC                   .dbline 838
 0DDC           ;                                                       NUM_MODULES--;
 0DDC 62D000            mov REG[0xd0],>_NUM_MODULES
 0DDF 7A01              dec [_NUM_MODULES+1]
 0DE1 1E0000            sbb [_NUM_MODULES],0
 0DE4                   .dbline 839
 0DE4           ;                                               }
 0DE4                   .dbline 840
 0DE4           ;                                       }
 0DE4                   .dbline 841
 0DE4           ;                               }
 0DE4                   .dbline 842
 0DE4           ;                       }
 0DE4                   .dbline 843
 0DE4           ;               }
 0DE4 8045              xjmp L214
 0DE6           L213:
 0DE6                   .dbline 844
 0DE6           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0DE6 62D000            mov REG[0xd0],>_TIMEOUT
 0DE9 5101              mov A,[_TIMEOUT+1]
 0DEB 1105              sub A,5
 0DED 5100              mov A,[_TIMEOUT]
 0DEF 3180              xor A,-128
 0DF1 1980              sbb A,(0 ^ 0x80)
 0DF3 C036              jc L229
 0DF5           X64:
 0DF5                   .dbline 845
 0DF5           ;               {       
 0DF5                   .dbline 847
 0DF5           ;                       // Only increment the number of timeouts if we have found a module.
 0DF5           ;                       if(NUM_MODULES)
 0DF5 62D000            mov REG[0xd0],>_NUM_MODULES
 0DF8 3C0000            cmp [_NUM_MODULES],0
 0DFB B006              jnz X65
 0DFD 3C0100            cmp [_NUM_MODULES+1],0
 0E00 A008              jz L234
 0E02           X65:
 0E02                   .dbline 848
 0E02           ;                       {
 0E02                   .dbline 849
 0E02           ;                               num_timeouts++;
 0E02 7705              inc [X+5]
 0E04 0F0400            adc [X+4],0
 0E07                   .dbline 850
 0E07           ;                       }
 0E07 8010              xjmp L232
 0E09           L233:
 0E09                   .dbline 855
 0E09           ;                       else
 0E09           ;                       {
 0E09           ;                               // Wait additional time between transmissions if no modules have been found.
 0E09           ;                               // This is done to give the first child a chance to configure if it hasn't.
 0E09           ;                               while(TIMEOUT < INIT_WAIT_TIME) { }
 0E09                   .dbline 855
 0E09           L234:
 0E09                   .dbline 855
 0E09 62D000            mov REG[0xd0],>_TIMEOUT
 0E0C 5101              mov A,[_TIMEOUT+1]
 0E0E 1132              sub A,50
 0E10 5100              mov A,[_TIMEOUT]
 0E12 3180              xor A,-128
 0E14 1980              sbb A,(0 ^ 0x80)
 0E16 CFF2              jc L233
 0E18           X66:
 0E18                   .dbline 856
 0E18           ;                       }
 0E18           L232:
 0E18                   .dbline 859
 0E18           ;                       
 0E18           ;                       // If we are not maxed out on modules, look for more.
 0E18           ;                       if(NUM_MODULES < MAX_MODULES)
 0E18 62D000            mov REG[0xd0],>_NUM_MODULES
 0E1B 5101              mov A,[_NUM_MODULES+1]
 0E1D 11FA              sub A,-6
 0E1F 5100              mov A,[_NUM_MODULES]
 0E21 3180              xor A,-128
 0E23 1980              sbb A,(0 ^ 0x80)
 0E25 D004              jnc L236
 0E27           X67:
 0E27                   .dbline 860
 0E27           ;                       {
 0E27                   .dbline 861
 0E27           ;                               sayHello();
 0E27 7C0261            xcall _sayHello
 0E2A                   .dbline 862
 0E2A           ;                       }
 0E2A           L236:
 0E2A                   .dbline 863
 0E2A           ;               }
 0E2A           L229:
 0E2A           L214:
 0E2A                   .dbline 864
 0E2A           ;       }
 0E2A           L211:
 0E2A                   .dbline 810
 0E2A 5205              mov A,[X+5]
 0E2C 1132              sub A,50
 0E2E 5204              mov A,[X+4]
 0E30 3180              xor A,-128
 0E32 1980              sbb A,(0 ^ 0x80)
 0E34 CF0C              jc L210
 0E36           X68:
 0E36                   .dbline 867
 0E36           ;       
 0E36           ;       // If we didn't find any new modules, check to see if some already exist.
 0E36           ;       if(!NUM_MODULES)
 0E36 62D000            mov REG[0xd0],>_NUM_MODULES
 0E39 3C0000            cmp [_NUM_MODULES],0
 0E3C B062              jnz L238
 0E3E 3C0100            cmp [_NUM_MODULES+1],0
 0E41 B05D              jnz L238
 0E43           X69:
 0E43                   .dbline 868
 0E43           ;       {
 0E43                   .dbline 870
 0E43           ;               // Try to ping the next module up from our current number ping_tries times.
 0E43           ;               for(i = 0; i < ping_tries; i++)
 0E43 560100            mov [X+1],0
 0E46 560000            mov [X+0],0
 0E49 8040              xjmp L243
 0E4B           L240:
 0E4B                   .dbline 871
 0E4B           ;               {       
 0E4B                   .dbline 872
 0E4B           ;                       if(pingModule(NUM_MODULES+1))
 0E4B 62D000            mov REG[0xd0],>_NUM_MODULES
 0E4E 5101              mov A,[_NUM_MODULES+1]
 0E50 0101              add A,1
 0E52 62D000            mov REG[0xd0],>__r0
 0E55 5300              mov [__r1],A
 0E57 62D000            mov REG[0xd0],>_NUM_MODULES
 0E5A 5100              mov A,[_NUM_MODULES]
 0E5C 0900              adc A,0
 0E5E 62D000            mov REG[0xd0],>__r0
 0E61 08                push A
 0E62 5100              mov A,[__r1]
 0E64 08                push A
 0E65 7C003D            xcall _pingModule
 0E68 38FE              add SP,-2
 0E6A 62D000            mov REG[0xd0],>__r0
 0E6D 3C0000            cmp [__r0],0
 0E70 B006              jnz X70
 0E72 3C0000            cmp [__r1],0
 0E75 A00F              jz L244
 0E77           X70:
 0E77                   .dbline 873
 0E77           ;                       {
 0E77                   .dbline 874
 0E77           ;                               NUM_MODULES++;
 0E77 62D000            mov REG[0xd0],>_NUM_MODULES
 0E7A 7601              inc [_NUM_MODULES+1]
 0E7C 0E0000            adc [_NUM_MODULES],0
 0E7F                   .dbline 875
 0E7F           ;                               i = 0;
 0E7F 560100            mov [X+1],0
 0E82 560000            mov [X+0],0
 0E85                   .dbline 876
 0E85           ;                       }
 0E85           L244:
 0E85                   .dbline 877
 0E85           ;               }
 0E85           L241:
 0E85                   .dbline 870
 0E85 7701              inc [X+1]
 0E87 0F0000            adc [X+0],0
 0E8A           L243:
 0E8A                   .dbline 870
 0E8A 5201              mov A,[X+1]
 0E8C 1303              sub A,[X+3]
 0E8E 5202              mov A,[X+2]
 0E90 3180              xor A,-128
 0E92 62D000            mov REG[0xd0],>__r0
 0E95 5300              mov [__rX],A
 0E97 5200              mov A,[X+0]
 0E99 3180              xor A,-128
 0E9B 1A00              sbb A,[__rX]
 0E9D CFAD              jc L240
 0E9F           X71:
 0E9F                   .dbline 878
 0E9F           ;       }
 0E9F           L238:
 0E9F                   .dbline 881
 0E9F           ;       
 0E9F           ;       // Switch back to PC mode.
 0E9F           ;       configToggle(PC_MODE);
 0E9F 5000              mov A,0
 0EA1 08                push A
 0EA2 5001              mov A,1
 0EA4 08                push A
 0EA5 9D67              xcall _configToggle
 0EA7 38FE              add SP,-2
 0EA9                   .dbline -2
 0EA9           L206:
 0EA9 38FA              add SP,-6
 0EAB 20                pop X
 0EAC                   .dbline 0 ; func end
 0EAC 7F                ret
 0EAD                   .dbsym l num_timeouts 4 I
 0EAD                   .dbsym l ping_tries 2 I
 0EAD                   .dbsym l i 0 I
 0EAD                   .dbend
 0EAD                   .dbfunc e childListen _childListen fV
 0EAD           _childListen::
 0EAD                   .dbline -1
 0EAD                   .dbline 886
 0EAD           ; }
 0EAD           ; 
 0EAD           ; // This function listens for children and registers the port that they talk to.
 0EAD           ; void childListen(void)
 0EAD           ; {     
 0EAD 80B7              xjmp L248
 0EAF           L247:
 0EAF                   .dbline 889
 0EAF           ;       // Wait to either hear a child or time out.
 0EAF           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0EAF           ;       {               
 0EAF                   .dbline 892
 0EAF           ;               // Check all of the ports for a start byte. Only one port will produce one.
 0EAF           ;               // Only non-blocking commands are used to avoid getting stuck listening downstream.
 0EAF           ;               if(RECEIVE_1_cReadChar() == START_TRANSMIT)
 0EAF 10                push X
 0EB0 7C0000            xcall _RECEIVE_1_cReadChar
 0EB3 62D000            mov REG[0xd0],>__r0
 0EB6 20                pop X
 0EB7 39FC              cmp A,-4
 0EB9 B023              jnz L250
 0EBB                   .dbline 893
 0EBB           ;               {
 0EBB 8010              xjmp L253
 0EBD           L252:
 0EBD                   .dbline 895
 0EBD           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0EBD           ;                       {
 0EBD                   .dbline 896
 0EBD           ;                               if(RECEIVE_1_cReadChar() == END_TRANSMIT)
 0EBD 10                push X
 0EBE 7C0000            xcall _RECEIVE_1_cReadChar
 0EC1 20                pop X
 0EC2 39FD              cmp A,-3
 0EC4 B007              jnz L255
 0EC6                   .dbline 897
 0EC6           ;                               {
 0EC6                   .dbline 898
 0EC6           ;                                       CHILD = PORT_1;
 0EC6 62D000            mov REG[0xd0],>_CHILD
 0EC9 550031            mov [_CHILD],49
 0ECC                   .dbline 899
 0ECC           ;                               }
 0ECC           L255:
 0ECC                   .dbline 900
 0ECC           ;                       }
 0ECC           L253:
 0ECC                   .dbline 894
 0ECC 62D000            mov REG[0xd0],>_TIMEOUT
 0ECF 5101              mov A,[_TIMEOUT+1]
 0ED1 1105              sub A,5
 0ED3 5100              mov A,[_TIMEOUT]
 0ED5 3180              xor A,-128
 0ED7 1980              sbb A,(0 ^ 0x80)
 0ED9 CFE3              jc L252
 0EDB           X72:
 0EDB                   .dbline 901
 0EDB           ;               }
 0EDB 8089              xjmp L251
 0EDD           L250:
 0EDD                   .dbline 902
 0EDD           ;               else if(RECEIVE_2_cReadChar() == START_TRANSMIT)
 0EDD 10                push X
 0EDE 7C0000            xcall _RECEIVE_2_cReadChar
 0EE1 62D000            mov REG[0xd0],>__r0
 0EE4 20                pop X
 0EE5 39FC              cmp A,-4
 0EE7 B023              jnz L257
 0EE9                   .dbline 903
 0EE9           ;               {
 0EE9 8010              xjmp L260
 0EEB           L259:
 0EEB                   .dbline 905
 0EEB           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0EEB           ;                       {
 0EEB                   .dbline 906
 0EEB           ;                               if(RECEIVE_2_cReadChar() == END_TRANSMIT)
 0EEB 10                push X
 0EEC 7C0000            xcall _RECEIVE_2_cReadChar
 0EEF 20                pop X
 0EF0 39FD              cmp A,-3
 0EF2 B007              jnz L262
 0EF4                   .dbline 907
 0EF4           ;                               {
 0EF4                   .dbline 908
 0EF4           ;                                       CHILD = PORT_2;
 0EF4 62D000            mov REG[0xd0],>_CHILD
 0EF7 550032            mov [_CHILD],50
 0EFA                   .dbline 909
 0EFA           ;                               }
 0EFA           L262:
 0EFA                   .dbline 910
 0EFA           ;                       }
 0EFA           L260:
 0EFA                   .dbline 904
 0EFA 62D000            mov REG[0xd0],>_TIMEOUT
 0EFD 5101              mov A,[_TIMEOUT+1]
 0EFF 1105              sub A,5
 0F01 5100              mov A,[_TIMEOUT]
 0F03 3180              xor A,-128
 0F05 1980              sbb A,(0 ^ 0x80)
 0F07 CFE3              jc L259
 0F09           X73:
 0F09                   .dbline 911
 0F09           ;               }
 0F09 805B              xjmp L258
 0F0B           L257:
 0F0B                   .dbline 912
 0F0B           ;               else if(RECEIVE_3_cReadChar() == START_TRANSMIT)
 0F0B 10                push X
 0F0C 7C0000            xcall _RECEIVE_3_cReadChar
 0F0F 62D000            mov REG[0xd0],>__r0
 0F12 20                pop X
 0F13 39FC              cmp A,-4
 0F15 B023              jnz L264
 0F17                   .dbline 913
 0F17           ;               {
 0F17 8010              xjmp L267
 0F19           L266:
 0F19                   .dbline 915
 0F19           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0F19           ;                       {
 0F19                   .dbline 916
 0F19           ;                               if(RECEIVE_3_cReadChar() == END_TRANSMIT)
 0F19 10                push X
 0F1A 7C0000            xcall _RECEIVE_3_cReadChar
 0F1D 20                pop X
 0F1E 39FD              cmp A,-3
 0F20 B007              jnz L269
 0F22                   .dbline 917
 0F22           ;                               {
 0F22                   .dbline 918
 0F22           ;                                       CHILD = PORT_3;
 0F22 62D000            mov REG[0xd0],>_CHILD
 0F25 550033            mov [_CHILD],51
 0F28                   .dbline 919
 0F28           ;                               }
 0F28           L269:
 0F28                   .dbline 920
 0F28           ;                       }
 0F28           L267:
 0F28                   .dbline 914
 0F28 62D000            mov REG[0xd0],>_TIMEOUT
 0F2B 5101              mov A,[_TIMEOUT+1]
 0F2D 1105              sub A,5
 0F2F 5100              mov A,[_TIMEOUT]
 0F31 3180              xor A,-128
 0F33 1980              sbb A,(0 ^ 0x80)
 0F35 CFE3              jc L266
 0F37           X74:
 0F37                   .dbline 921
 0F37           ;               }
 0F37 802D              xjmp L265
 0F39           L264:
 0F39                   .dbline 922
 0F39           ;               else if(RECEIVE_4_cReadChar() == START_TRANSMIT)
 0F39 10                push X
 0F3A 7C0000            xcall _RECEIVE_4_cReadChar
 0F3D 62D000            mov REG[0xd0],>__r0
 0F40 20                pop X
 0F41 39FC              cmp A,-4
 0F43 B021              jnz L271
 0F45                   .dbline 923
 0F45           ;               {
 0F45 8010              xjmp L274
 0F47           L273:
 0F47                   .dbline 925
 0F47           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0F47           ;                       {
 0F47                   .dbline 926
 0F47           ;                               if(RECEIVE_4_cReadChar() == END_TRANSMIT)
 0F47 10                push X
 0F48 7C0000            xcall _RECEIVE_4_cReadChar
 0F4B 20                pop X
 0F4C 39FD              cmp A,-3
 0F4E B007              jnz L276
 0F50                   .dbline 927
 0F50           ;                               {
 0F50                   .dbline 928
 0F50           ;                                       CHILD = PORT_4;
 0F50 62D000            mov REG[0xd0],>_CHILD
 0F53 550034            mov [_CHILD],52
 0F56                   .dbline 929
 0F56           ;                               }
 0F56           L276:
 0F56                   .dbline 930
 0F56           ;                       }
 0F56           L274:
 0F56                   .dbline 924
 0F56 62D000            mov REG[0xd0],>_TIMEOUT
 0F59 5101              mov A,[_TIMEOUT+1]
 0F5B 1105              sub A,5
 0F5D 5100              mov A,[_TIMEOUT]
 0F5F 3180              xor A,-128
 0F61 1980              sbb A,(0 ^ 0x80)
 0F63 CFE3              jc L273
 0F65           X75:
 0F65                   .dbline 931
 0F65           ;               }
 0F65           L271:
 0F65           L265:
 0F65           L258:
 0F65           L251:
 0F65                   .dbline 932
 0F65           ;       }
 0F65           L248:
 0F65                   .dbline 888
 0F65 62D000            mov REG[0xd0],>_TIMEOUT
 0F68 5101              mov A,[_TIMEOUT+1]
 0F6A 1105              sub A,5
 0F6C 5100              mov A,[_TIMEOUT]
 0F6E 3180              xor A,-128
 0F70 1980              sbb A,(0 ^ 0x80)
 0F72 CF3C              jc L247
 0F74           X76:
 0F74                   .dbline -2
 0F74           L246:
 0F74                   .dbline 0 ; func end
 0F74 7F                ret
 0F75                   .dbend
 0F75                   .dbfunc e iReadChar _iReadChar fc
 0F75           _iReadChar::
 0F75                   .dbline -1
 0F75                   .dbline 937
 0F75           ; }
 0F75           ; 
 0F75           ; // This function converts the PSoC cReadChar calls of all ports into a single return.
 0F75           ; char iReadChar(void)
 0F75           ; {
 0F75                   .dbline 938
 0F75           ;       if(CHILD == PORT_1)
 0F75 62D000            mov REG[0xd0],>_CHILD
 0F78 3C0031            cmp [_CHILD],49
 0F7B B00B              jnz L279
 0F7D                   .dbline 939
 0F7D           ;       {
 0F7D                   .dbline 940
 0F7D           ;               return RECEIVE_1_cReadChar();
 0F7D 10                push X
 0F7E 7C0000            xcall _RECEIVE_1_cReadChar
 0F81 62D000            mov REG[0xd0],>__r0
 0F84 20                pop X
 0F85 803C              xjmp L278
 0F87           L279:
 0F87                   .dbline 942
 0F87           ;       }
 0F87           ;       else if(CHILD == PORT_2)
 0F87 62D000            mov REG[0xd0],>_CHILD
 0F8A 3C0032            cmp [_CHILD],50
 0F8D B00B              jnz L281
 0F8F                   .dbline 943
 0F8F           ;       {
 0F8F                   .dbline 944
 0F8F           ;               return RECEIVE_2_cReadChar();
 0F8F 10                push X
 0F90 7C0000            xcall _RECEIVE_2_cReadChar
 0F93 62D000            mov REG[0xd0],>__r0
 0F96 20                pop X
 0F97 802A              xjmp L278
 0F99           L281:
 0F99                   .dbline 946
 0F99           ;       }
 0F99           ;       else if(CHILD == PORT_3)
 0F99 62D000            mov REG[0xd0],>_CHILD
 0F9C 3C0033            cmp [_CHILD],51
 0F9F B00B              jnz L283
 0FA1                   .dbline 947
 0FA1           ;       {
 0FA1                   .dbline 948
 0FA1           ;               return RECEIVE_3_cReadChar();
 0FA1 10                push X
 0FA2 7C0000            xcall _RECEIVE_3_cReadChar
 0FA5 62D000            mov REG[0xd0],>__r0
 0FA8 20                pop X
 0FA9 8018              xjmp L278
 0FAB           L283:
 0FAB                   .dbline 950
 0FAB           ;       }
 0FAB           ;       else if(CHILD == PORT_4)
 0FAB 62D000            mov REG[0xd0],>_CHILD
 0FAE 3C0034            cmp [_CHILD],52
 0FB1 B00B              jnz L285
 0FB3                   .dbline 951
 0FB3           ;       {
 0FB3                   .dbline 952
 0FB3           ;               return RECEIVE_4_cReadChar();
 0FB3 10                push X
 0FB4 7C0000            xcall _RECEIVE_4_cReadChar
 0FB7 62D000            mov REG[0xd0],>__r0
 0FBA 20                pop X
 0FBB 8006              xjmp L278
 0FBD           L285:
 0FBD                   .dbline 955
 0FBD           ;       }
 0FBD           ;       else
 0FBD           ;       {
 0FBD                   .dbline 956
 0FBD           ;               return 0;
 0FBD 62D000            mov REG[0xd0],>__r0
 0FC0 5000              mov A,0
 0FC2                   .dbline -2
 0FC2           L278:
 0FC2                   .dbline 0 ; func end
 0FC2 7F                ret
 0FC3                   .dbend
 0FC3                   .dbfunc e readChar _readChar fc
 0FC3           _readChar::
 0FC3                   .dbline -1
 0FC3                   .dbline 962
 0FC3           ;       }
 0FC3           ; }
 0FC3           ; 
 0FC3           ; // This function converts the PSoC cGetChar calls of all ports into a single return.
 0FC3           ; char readChar(void)
 0FC3           ; {     
 0FC3                   .dbline 963
 0FC3           ;       if(CHILD == PORT_1)
 0FC3 62D000            mov REG[0xd0],>_CHILD
 0FC6 3C0031            cmp [_CHILD],49
 0FC9 B00B              jnz L288
 0FCB                   .dbline 964
 0FCB           ;       {
 0FCB                   .dbline 965
 0FCB           ;               return RECEIVE_1_cGetChar();
 0FCB 10                push X
 0FCC 7C0000            xcall _RECEIVE_1_cGetChar
 0FCF 62D000            mov REG[0xd0],>__r0
 0FD2 20                pop X
 0FD3 803C              xjmp L287
 0FD5           L288:
 0FD5                   .dbline 967
 0FD5           ;       }
 0FD5           ;       else if(CHILD == PORT_2)
 0FD5 62D000            mov REG[0xd0],>_CHILD
 0FD8 3C0032            cmp [_CHILD],50
 0FDB B00B              jnz L290
 0FDD                   .dbline 968
 0FDD           ;       {
 0FDD                   .dbline 969
 0FDD           ;               return RECEIVE_2_cGetChar();
 0FDD 10                push X
 0FDE 7C0000            xcall _RECEIVE_2_cGetChar
 0FE1 62D000            mov REG[0xd0],>__r0
 0FE4 20                pop X
 0FE5 802A              xjmp L287
 0FE7           L290:
 0FE7                   .dbline 971
 0FE7           ;       }
 0FE7           ;       else if(CHILD == PORT_3)
 0FE7 62D000            mov REG[0xd0],>_CHILD
 0FEA 3C0033            cmp [_CHILD],51
 0FED B00B              jnz L292
 0FEF                   .dbline 972
 0FEF           ;       {
 0FEF                   .dbline 973
 0FEF           ;               return RECEIVE_3_cGetChar();
 0FEF 10                push X
 0FF0 7C0000            xcall _RECEIVE_3_cGetChar
 0FF3 62D000            mov REG[0xd0],>__r0
 0FF6 20                pop X
 0FF7 8018              xjmp L287
 0FF9           L292:
 0FF9                   .dbline 975
 0FF9           ;       }
 0FF9           ;       else if(CHILD == PORT_4)
 0FF9 62D000            mov REG[0xd0],>_CHILD
 0FFC 3C0034            cmp [_CHILD],52
 0FFF B00B              jnz L294
 1001                   .dbline 976
 1001           ;       {
 1001                   .dbline 977
 1001           ;               return RECEIVE_4_cGetChar();
 1001 10                push X
 1002 7C0000            xcall _RECEIVE_4_cGetChar
 1005 62D000            mov REG[0xd0],>__r0
 1008 20                pop X
 1009 8006              xjmp L287
 100B           L294:
 100B                   .dbline 980
 100B           ;       }
 100B           ;       else
 100B           ;       {
 100B                   .dbline 981
 100B           ;               return 0;
 100B 62D000            mov REG[0xd0],>__r0
 100E 5000              mov A,0
 1010                   .dbline -2
 1010           L287:
 1010                   .dbline 0 ; func end
 1010 7F                ret
 1011                   .dbend
 1011                   .dbfunc e xmitWait _xmitWait fV
 1011           ;              i -> X+0
 1011           _xmitWait::
 1011                   .dbline -1
 1011 10                push X
 1012 4F                mov X,SP
 1013 3802              add SP,2
 1015                   .dbline 986
 1015           ;       }
 1015           ; }
 1015           ; 
 1015           ; void xmitWait(void)
 1015           ; {
 1015                   .dbline 989
 1015           ;       int i;
 1015           ;       
 1015           ;       for(i = 0; i < 25; i++)
 1015 560100            mov [X+1],0
 1018 560000            mov [X+0],0
 101B           L297:
 101B                   .dbline 990
 101B           ;       {
 101B                   .dbline 992
 101B           ;               // Sit here and spin for about 50 microseconds.
 101B           ;       }
 101B           L298:
 101B                   .dbline 989
 101B 7701              inc [X+1]
 101D 0F0000            adc [X+0],0
 1020                   .dbline 989
 1020 5201              mov A,[X+1]
 1022 1119              sub A,25
 1024 5200              mov A,[X+0]
 1026 3180              xor A,-128
 1028 1980              sbb A,(0 ^ 0x80)
 102A CFF0              jc L297
 102C           X77:
 102C                   .dbline -2
 102C           L296:
 102C 38FE              add SP,-2
 102E 20                pop X
 102F                   .dbline 0 ; func end
 102F 7F                ret
 1030                   .dbsym l i 0 I
 1030                   .dbend
 1030                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 1030           _TX_TIMEOUT_ISR::
 1030                   .dbline -1
 1030 71C0              or F,-64
 1032 08                push A
 1033 5DD0              mov A,REG[0xd0]
 1035 08                push A
 1036                   .dbline 996
 1036           ; }
 1036           ; 
 1036           ; void TX_TIMEOUT_ISR(void)
 1036           ; {     
 1036                   .dbline 998
 1036           ;       // Increment the number of timeouts.
 1036           ;       TIMEOUT++;
 1036 62D000            mov REG[0xd0],>_TIMEOUT
 1039 7601              inc [_TIMEOUT+1]
 103B 0E0000            adc [_TIMEOUT],0
 103E                   .dbline 1000
 103E           ;       
 103E           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 103E 62DAFD            mov REG[0xda],-3
 1041                   .dbline -2
 1041           L301:
 1041 18                pop A
 1042 60D0              mov REG[208],A
 1044 18                pop A
 1045                   .dbline 0 ; func end
 1045 7E                reti
 1046                   .dbend
 1046                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 1046           _RX_TIMEOUT_ISR::
 1046                   .dbline -1
 1046 71C0              or F,-64
 1048 08                push A
 1049 5DD0              mov A,REG[0xd0]
 104B 08                push A
 104C                   .dbline 1004
 104C           ; }
 104C           ; 
 104C           ; void RX_TIMEOUT_ISR(void)
 104C           ; {     
 104C                   .dbline 1006
 104C           ;       // Increment the number of timeouts.
 104C           ;       TIMEOUT++;
 104C 62D000            mov REG[0xd0],>_TIMEOUT
 104F 7601              inc [_TIMEOUT+1]
 1051 0E0000            adc [_TIMEOUT],0
 1054                   .dbline 1008
 1054           ;       
 1054           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 1054 62DAFD            mov REG[0xda],-3
 1057                   .dbline -2
 1057           L302:
 1057 18                pop A
 1058 60D0              mov REG[208],A
 105A 18                pop A
 105B                   .dbline 0 ; func end
 105B 7E                reti
 105C                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
