 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 103
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>              // part specific constants and macros
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0000           ; #include "psocdynamic.h"
 0000           ; #include <stdlib.h>
 0000           ; #include <string.h>
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0000           ; #define               PC_MODE                                         (2)
 0000           ; #define               RX_MODE                                         (1)
 0000           ; #define               TX_MODE                                         (0)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; // These defines are used for the initial probing stage. This module first waits until it hears
 0000           ; // a byte on the bus. Once this happens, this module waits until there is a BUS_CLEAR_TIME
 0000           ; // period of no communication before attempting to probe for modules and assign ID numbers.
 0000           ; // MAX_TIMEOUTS is the number of failed attempts allowed to find an unconfigured module after
 0000           ; // the first module is found. After all of this, this module goes into a PC listening mode.
 0000           ; #define               BUS_CLEAR_TIME                          (100)   // Min time after a byte to assume bus is clear at boot.
 0000           ; #define               BOOT_TIMEOUT                            (300)   // If nothing is heard by this time, we start the init anyway.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the master
 0000           ; #define               MAX_MODULES                                     (250)
 0000           ; 
 0000           ; #define               SERVO_START                                     (255)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the
 0000           ; // system configuration between receive and transmit modes for half duplex UART.
 0000           ; void configToggle(int mode);
 0000           ; 
 0000           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; 
 0000           ; // This function assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; 
 0000           ; int validTransmission(void);
 0000           ; 
 0000           ; void decodeTransmission(void);
 0000           ; 
 0000           ; void busListen(void);
 0000           ; 
 0000           ; void sayHello(void);
 0000           ; 
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; 
 0000           ; int clearConfig(int module_id);
 0000           ; // This function checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the slave module controllers.
 0000           ; void initializeSlaves(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; 
 0000           ; // This flag is set if there is a timeout.
 0000           ; int TIMEOUT;
 0000           ; 
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 105
 0000           ;       // Initialize the number of modules.
 0000           ;       NUM_MODULES = 0;
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 108
 0009           ;       
 0009           ;       // Activate GPIO ISR.
 0009           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 0009 43E020            or REG[0xe0],32
 000C                   .dbline 111
 000C           ;       
 000C           ;       // Turn on global interrupts for the transmission timeout timer.
 000C           ;       M8C_EnableGInt;
 000C 7101                      or  F, 01h
 000E           
 000E                   .dbline 114
 000E           ;       
 000E           ;       // Block and wait for the bus to be clear.
 000E           ;       busListen();
 000E 7C0C42            xcall _busListen
 0011 8021              xjmp L3
 0013           L2:
 0013                   .dbline 117
 0013           ;       
 0013           ;       while(1)
 0013           ;       {
 0013                   .dbline 118
 0013           ;               if(!NUM_MODULES)
 0013 62D000            mov REG[0xd0],>_NUM_MODULES
 0016 3C0000            cmp [_NUM_MODULES],0
 0019 B00B              jnz L5
 001B 3C0100            cmp [_NUM_MODULES+1],0
 001E B006              jnz L5
 0020           X1:
 0020                   .dbline 119
 0020           ;               {
 0020                   .dbline 120
 0020           ;                       initializeSlaves();
 0020 7C0C9C            xcall _initializeSlaves
 0023                   .dbline 121
 0023           ;               }
 0023 800F              xjmp L6
 0025           L5:
 0025                   .dbline 122
 0025           ;               else if(COMP_SERIAL_bCmdCheck())                // If there's a computer command, read it.
 0025 10                push X
 0026 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0029 62D000            mov REG[0xd0],>__r0
 002C 20                pop X
 002D 3900              cmp A,0
 002F A003              jz L7
 0031                   .dbline 123
 0031           ;               {
 0031                   .dbline 124
 0031           ;                       decodeTransmission();
 0031 942D              xcall _decodeTransmission
 0033                   .dbline 125
 0033           ;               }
 0033           L7:
 0033           L6:
 0033                   .dbline 126
 0033           ;       }
 0033           L3:
 0033                   .dbline 116
 0033 8FDF              xjmp L2
 0035           X0:
 0035                   .dbline -2
 0035           L1:
 0035                   .dbline 0 ; func end
 0035 8FFF              jmp .
 0037                   .dbend
 0037                   .dbfunc e pingModule _pingModule fI
 0037           ;       response -> X+0
 0037           ;      module_id -> X-5
 0037           _pingModule::
 0037                   .dbline -1
 0037 10                push X
 0038 4F                mov X,SP
 0039 3802              add SP,2
 003B                   .dbline 130
 003B           ; }
 003B           ; 
 003B           ; int pingModule(int module_id)
 003B           ; {
 003B                   .dbline 131
 003B           ;       int response = 0;
 003B 560100            mov [X+1],0
 003E 560000            mov [X+0],0
 0041                   .dbline 133
 0041           ;       
 0041           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0041 5000              mov A,0
 0043 08                push A
 0044 08                push A
 0045 7C0B2A            xcall _configToggle
 0048 38FE              add SP,-2
 004A                   .dbline 136
 004A           ;                       
 004A           ;       // Transmit a hello.
 004A           ;       TRANSMIT_PutChar(START_TRANSMIT);
 004A 10                push X
 004B 50FC              mov A,-4
 004D 7C0000            xcall _TRANSMIT_PutChar
 0050 20                pop X
 0051                   .dbline 137
 0051           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0051 10                push X
 0052 50FC              mov A,-4
 0054 7C0000            xcall _TRANSMIT_PutChar
 0057 20                pop X
 0058                   .dbline 138
 0058           ;       TRANSMIT_PutChar(MASTER_ID);
 0058 10                push X
 0059 5000              mov A,0
 005B 7C0000            xcall _TRANSMIT_PutChar
 005E 20                pop X
 005F                   .dbline 139
 005F           ;       TRANSMIT_PutChar(module_id);
 005F 62D000            mov REG[0xd0],>__r0
 0062 52FC              mov A,[X-4]
 0064 10                push X
 0065 7C0000            xcall _TRANSMIT_PutChar
 0068 20                pop X
 0069                   .dbline 140
 0069           ;       TRANSMIT_PutChar(PING);
 0069 10                push X
 006A 50CB              mov A,-53
 006C 7C0000            xcall _TRANSMIT_PutChar
 006F 20                pop X
 0070                   .dbline 141
 0070           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0070 10                push X
 0071 50FD              mov A,-3
 0073 7C0000            xcall _TRANSMIT_PutChar
 0076 20                pop X
 0077                   .dbline 142
 0077           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0077 10                push X
 0078 50FD              mov A,-3
 007A 7C0000            xcall _TRANSMIT_PutChar
 007D 20                pop X
 007E           L10:
 007E                   .dbline 145
 007E           ;       
 007E           ;       // Wait for the transmission to finish.
 007E           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 007E           L11:
 007E                   .dbline 145
 007E 10                push X
 007F 7C0000            xcall _TRANSMIT_bReadTxStatus
 0082 62D000            mov REG[0xd0],>__r0
 0085 20                pop X
 0086 5300              mov [__r0],A
 0088 470020            tst [__r0],32
 008B AFF2              jz L10
 008D                   .dbline 147
 008D           ;       
 008D           ;       xmitWait();
 008D 7C0E19            xcall _xmitWait
 0090                   .dbline 149
 0090           ;       
 0090           ;       configToggle(RX_MODE);  // Listen for the response.
 0090 5000              mov A,0
 0092 08                push A
 0093 5001              mov A,1
 0095 08                push A
 0096 7C0B2A            xcall _configToggle
 0099 38FE              add SP,-2
 009B                   .dbline 151
 009B           ;       
 009B           ;       RX_TIMEOUT_Stop();
 009B 10                push X
 009C 7C0000            xcall _RX_TIMEOUT_Stop
 009F 20                pop X
 00A0                   .dbline 152
 00A0           ;       TIMEOUT = 0;
 00A0 62D000            mov REG[0xd0],>_TIMEOUT
 00A3 550100            mov [_TIMEOUT+1],0
 00A6 550000            mov [_TIMEOUT],0
 00A9                   .dbline 153
 00A9           ;       RX_TIMEOUT_Start();
 00A9 10                push X
 00AA 7C0000            xcall _RX_TIMEOUT_Start
 00AD 20                pop X
 00AE 803C              xjmp L14
 00B0           L13:
 00B0                   .dbline 156
 00B0           ;       
 00B0           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 00B0           ;       {
 00B0                   .dbline 157
 00B0           ;               if(validTransmission())
 00B0 92BA              xcall _validTransmission
 00B2 62D000            mov REG[0xd0],>__r0
 00B5 3C0000            cmp [__r0],0
 00B8 B006              jnz X2
 00BA 3C0000            cmp [__r1],0
 00BD A02D              jz L16
 00BF           X2:
 00BF                   .dbline 158
 00BF           ;               {
 00BF                   .dbline 159
 00BF           ;                       if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00BF 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00C2 3C00CB            cmp [_COMMAND_TYPE],-53
 00C5 B025              jnz L18
 00C7                   .dbline 160
 00C7           ;                       {
 00C7                   .dbline 162
 00C7           ;                               // If this is for me, check who it was from.
 00C7           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 00C7 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00CA 3C0000            cmp [_COMMAND_DESTINATION],0
 00CD B01D              jnz L20
 00CF                   .dbline 163
 00CF           ;                               {
 00CF                   .dbline 164
 00CF           ;                                       if(COMMAND_SOURCE == module_id)
 00CF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00D2 5100              mov A,[_COMMAND_SOURCE]
 00D4 62D000            mov REG[0xd0],>__r0
 00D7 5300              mov [__r1],A
 00D9 5000              mov A,0
 00DB 3BFB              cmp A,[X-5]
 00DD B00D              jnz L22
 00DF 5100              mov A,[__r1]
 00E1 3BFC              cmp A,[X-4]
 00E3 B007              jnz L22
 00E5           X3:
 00E5                   .dbline 165
 00E5           ;                                       {
 00E5                   .dbline 166
 00E5           ;                                               response = 1;
 00E5 560101            mov [X+1],1
 00E8 560000            mov [X+0],0
 00EB                   .dbline 167
 00EB           ;                                       }
 00EB           L22:
 00EB                   .dbline 168
 00EB           ;                               }
 00EB           L20:
 00EB                   .dbline 169
 00EB           ;                       }
 00EB           L18:
 00EB                   .dbline 170
 00EB           ;               }
 00EB           L16:
 00EB                   .dbline 171
 00EB           ;       }
 00EB           L14:
 00EB                   .dbline 155
 00EB 62D000            mov REG[0xd0],>_TIMEOUT
 00EE 5101              mov A,[_TIMEOUT+1]
 00F0 1105              sub A,5
 00F2 5100              mov A,[_TIMEOUT]
 00F4 3180              xor A,-128
 00F6 1980              sbb A,(0 ^ 0x80)
 00F8 D00B              jnc L24
 00FA           X4:
 00FA 3D0000            cmp [X+0],0
 00FD B006              jnz X5
 00FF 3D0100            cmp [X+1],0
 0102 AFAD              jz L13
 0104           X5:
 0104           L24:
 0104                   .dbline 173
 0104           ;       
 0104           ;       RX_TIMEOUT_Stop();
 0104 10                push X
 0105 7C0000            xcall _RX_TIMEOUT_Stop
 0108 20                pop X
 0109                   .dbline 174
 0109           ;       TIMEOUT = 0;
 0109 62D000            mov REG[0xd0],>_TIMEOUT
 010C 550100            mov [_TIMEOUT+1],0
 010F 550000            mov [_TIMEOUT],0
 0112                   .dbline 175
 0112           ;       RX_TIMEOUT_Start();
 0112 10                push X
 0113 7C0000            xcall _RX_TIMEOUT_Start
 0116 20                pop X
 0117                   .dbline 177
 0117           ;       
 0117           ;       return response;
 0117 62D000            mov REG[0xd0],>__r0
 011A 5201              mov A,[X+1]
 011C 5300              mov [__r1],A
 011E 5200              mov A,[X+0]
 0120 5300              mov [__r0],A
 0122                   .dbline -2
 0122           L9:
 0122 38FE              add SP,-2
 0124 20                pop X
 0125                   .dbline 0 ; func end
 0125 7F                ret
 0126                   .dbsym l response 0 I
 0126                   .dbsym l module_id -5 I
 0126                   .dbend
 0126                   .dbfunc e assignID _assignID fI
 0126           ;        success -> X+0
 0126           ;    assigned_ID -> X-5
 0126           _assignID::
 0126                   .dbline -1
 0126 10                push X
 0127 4F                mov X,SP
 0128 3802              add SP,2
 012A                   .dbline 181
 012A           ; }
 012A           ; 
 012A           ; int assignID(int assigned_ID)
 012A           ; {
 012A                   .dbline 182
 012A           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 012A 560100            mov [X+1],0
 012D 560000            mov [X+0],0
 0130                   .dbline 184
 0130           ;       
 0130           ;       configToggle(TX_MODE);  // Switch to TX mode.
 0130 5000              mov A,0
 0132 08                push A
 0133 08                push A
 0134 7C0B2A            xcall _configToggle
 0137 38FE              add SP,-2
 0139                   .dbline 187
 0139           ; 
 0139           ;       // Transmit the assignment.
 0139           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0139 10                push X
 013A 50FC              mov A,-4
 013C 7C0000            xcall _TRANSMIT_PutChar
 013F 20                pop X
 0140                   .dbline 188
 0140           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0140 10                push X
 0141 50FC              mov A,-4
 0143 7C0000            xcall _TRANSMIT_PutChar
 0146 20                pop X
 0147                   .dbline 189
 0147           ;       TRANSMIT_PutChar(MASTER_ID);
 0147 10                push X
 0148 5000              mov A,0
 014A 7C0000            xcall _TRANSMIT_PutChar
 014D 20                pop X
 014E                   .dbline 190
 014E           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 014E 10                push X
 014F 50FB              mov A,-5
 0151 7C0000            xcall _TRANSMIT_PutChar
 0154 20                pop X
 0155                   .dbline 191
 0155           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0155 10                push X
 0156 50C9              mov A,-55
 0158 7C0000            xcall _TRANSMIT_PutChar
 015B 20                pop X
 015C                   .dbline 192
 015C           ;       TRANSMIT_PutChar(assigned_ID);
 015C 62D000            mov REG[0xd0],>__r0
 015F 52FC              mov A,[X-4]
 0161 10                push X
 0162 7C0000            xcall _TRANSMIT_PutChar
 0165 20                pop X
 0166                   .dbline 193
 0166           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0166 10                push X
 0167 50FD              mov A,-3
 0169 7C0000            xcall _TRANSMIT_PutChar
 016C 20                pop X
 016D                   .dbline 194
 016D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 016D 10                push X
 016E 50FD              mov A,-3
 0170 7C0000            xcall _TRANSMIT_PutChar
 0173 20                pop X
 0174           L26:
 0174                   .dbline 197
 0174           ;       
 0174           ;       // Wait for the transmission to finish.
 0174           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0174           L27:
 0174                   .dbline 197
 0174 10                push X
 0175 7C0000            xcall _TRANSMIT_bReadTxStatus
 0178 62D000            mov REG[0xd0],>__r0
 017B 20                pop X
 017C 5300              mov [__r0],A
 017E 470020            tst [__r0],32
 0181 AFF2              jz L26
 0183                   .dbline 199
 0183           ;       
 0183           ;       xmitWait();
 0183 7C0E19            xcall _xmitWait
 0186                   .dbline 201
 0186           ;       
 0186           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 0186 5000              mov A,0
 0188 08                push A
 0189 5001              mov A,1
 018B 08                push A
 018C 7C0B2A            xcall _configToggle
 018F 38FE              add SP,-2
 0191                   .dbline 203
 0191           ;       
 0191           ;       RX_TIMEOUT_Stop();
 0191 10                push X
 0192 7C0000            xcall _RX_TIMEOUT_Stop
 0195 20                pop X
 0196                   .dbline 204
 0196           ;       TIMEOUT = 0;
 0196 62D000            mov REG[0xd0],>_TIMEOUT
 0199 550100            mov [_TIMEOUT+1],0
 019C 550000            mov [_TIMEOUT],0
 019F                   .dbline 205
 019F           ;       RX_TIMEOUT_Start();
 019F 10                push X
 01A0 7C0000            xcall _RX_TIMEOUT_Start
 01A3 20                pop X
 01A4 803C              xjmp L30
 01A6           L29:
 01A6                   .dbline 208
 01A6           ;       
 01A6           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 01A6           ;       {
 01A6                   .dbline 209
 01A6           ;               if(validTransmission())
 01A6 91C4              xcall _validTransmission
 01A8 62D000            mov REG[0xd0],>__r0
 01AB 3C0000            cmp [__r0],0
 01AE B006              jnz X6
 01B0 3C0000            cmp [__r1],0
 01B3 A02D              jz L32
 01B5           X6:
 01B5                   .dbline 210
 01B5           ;               {
 01B5                   .dbline 211
 01B5           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 01B5 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01B8 3C00CA            cmp [_COMMAND_TYPE],-54
 01BB B025              jnz L34
 01BD                   .dbline 212
 01BD           ;                       {
 01BD                   .dbline 214
 01BD           ;                               // If this is for me, check who it was from.
 01BD           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 01BD 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 01C0 3C0000            cmp [_COMMAND_DESTINATION],0
 01C3 B01D              jnz L36
 01C5                   .dbline 215
 01C5           ;                               {
 01C5                   .dbline 216
 01C5           ;                                       if(COMMAND_SOURCE == assigned_ID)
 01C5 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 01C8 5100              mov A,[_COMMAND_SOURCE]
 01CA 62D000            mov REG[0xd0],>__r0
 01CD 5300              mov [__r1],A
 01CF 5000              mov A,0
 01D1 3BFB              cmp A,[X-5]
 01D3 B00D              jnz L38
 01D5 5100              mov A,[__r1]
 01D7 3BFC              cmp A,[X-4]
 01D9 B007              jnz L38
 01DB           X7:
 01DB                   .dbline 217
 01DB           ;                                       {
 01DB                   .dbline 218
 01DB           ;                                               success = 1;
 01DB 560101            mov [X+1],1
 01DE 560000            mov [X+0],0
 01E1                   .dbline 219
 01E1           ;                                       }
 01E1           L38:
 01E1                   .dbline 220
 01E1           ;                               }
 01E1           L36:
 01E1                   .dbline 221
 01E1           ;                       }
 01E1           L34:
 01E1                   .dbline 222
 01E1           ;               }
 01E1           L32:
 01E1                   .dbline 223
 01E1           ;       }
 01E1           L30:
 01E1                   .dbline 207
 01E1 62D000            mov REG[0xd0],>_TIMEOUT
 01E4 5101              mov A,[_TIMEOUT+1]
 01E6 1105              sub A,5
 01E8 5100              mov A,[_TIMEOUT]
 01EA 3180              xor A,-128
 01EC 1980              sbb A,(0 ^ 0x80)
 01EE D00B              jnc L40
 01F0           X8:
 01F0 3D0000            cmp [X+0],0
 01F3 B006              jnz X9
 01F5 3D0100            cmp [X+1],0
 01F8 AFAD              jz L29
 01FA           X9:
 01FA           L40:
 01FA                   .dbline 225
 01FA           ;       
 01FA           ;       RX_TIMEOUT_Stop();
 01FA 10                push X
 01FB 7C0000            xcall _RX_TIMEOUT_Stop
 01FE 20                pop X
 01FF                   .dbline 226
 01FF           ;       TIMEOUT = 0;
 01FF 62D000            mov REG[0xd0],>_TIMEOUT
 0202 550100            mov [_TIMEOUT+1],0
 0205 550000            mov [_TIMEOUT],0
 0208                   .dbline 227
 0208           ;       RX_TIMEOUT_Start();
 0208 10                push X
 0209 7C0000            xcall _RX_TIMEOUT_Start
 020C 20                pop X
 020D                   .dbline 229
 020D           ;       
 020D           ;       return success;
 020D 62D000            mov REG[0xd0],>__r0
 0210 5201              mov A,[X+1]
 0212 5300              mov [__r1],A
 0214 5200              mov A,[X+0]
 0216 5300              mov [__r0],A
 0218                   .dbline -2
 0218           L25:
 0218 38FE              add SP,-2
 021A 20                pop X
 021B                   .dbline 0 ; func end
 021B 7F                ret
 021C                   .dbsym l success 0 I
 021C                   .dbsym l assigned_ID -5 I
 021C                   .dbend
 021C                   .dbfunc e clearConfig _clearConfig fI
 021C           ;       response -> X+0
 021C           ;      module_id -> X-5
 021C           _clearConfig::
 021C                   .dbline -1
 021C 10                push X
 021D 4F                mov X,SP
 021E 3802              add SP,2
 0220                   .dbline 233
 0220           ; }
 0220           ; 
 0220           ; int clearConfig(int module_id)
 0220           ; {
 0220                   .dbline 234
 0220           ;       int response = 0;
 0220 560100            mov [X+1],0
 0223 560000            mov [X+0],0
 0226                   .dbline 236
 0226           ;       
 0226           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0226 5000              mov A,0
 0228 08                push A
 0229 08                push A
 022A 7C0B2A            xcall _configToggle
 022D 38FE              add SP,-2
 022F                   .dbline 239
 022F           ;                       
 022F           ;       // Transmit a hello.
 022F           ;       TRANSMIT_PutChar(START_TRANSMIT);
 022F 10                push X
 0230 50FC              mov A,-4
 0232 7C0000            xcall _TRANSMIT_PutChar
 0235 20                pop X
 0236                   .dbline 240
 0236           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0236 10                push X
 0237 50FC              mov A,-4
 0239 7C0000            xcall _TRANSMIT_PutChar
 023C 20                pop X
 023D                   .dbline 241
 023D           ;       TRANSMIT_PutChar(MASTER_ID);
 023D 10                push X
 023E 5000              mov A,0
 0240 7C0000            xcall _TRANSMIT_PutChar
 0243 20                pop X
 0244                   .dbline 242
 0244           ;       TRANSMIT_PutChar(module_id);
 0244 62D000            mov REG[0xd0],>__r0
 0247 52FC              mov A,[X-4]
 0249 10                push X
 024A 7C0000            xcall _TRANSMIT_PutChar
 024D 20                pop X
 024E                   .dbline 243
 024E           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 024E 10                push X
 024F 50CC              mov A,-52
 0251 7C0000            xcall _TRANSMIT_PutChar
 0254 20                pop X
 0255                   .dbline 244
 0255           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0255 10                push X
 0256 50FD              mov A,-3
 0258 7C0000            xcall _TRANSMIT_PutChar
 025B 20                pop X
 025C                   .dbline 245
 025C           ;       TRANSMIT_PutChar(END_TRANSMIT);
 025C 10                push X
 025D 50FD              mov A,-3
 025F 7C0000            xcall _TRANSMIT_PutChar
 0262 20                pop X
 0263           L42:
 0263                   .dbline 248
 0263           ;       
 0263           ;       // Wait for the transmission to finish.
 0263           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0263           L43:
 0263                   .dbline 248
 0263 10                push X
 0264 7C0000            xcall _TRANSMIT_bReadTxStatus
 0267 62D000            mov REG[0xd0],>__r0
 026A 20                pop X
 026B 5300              mov [__r0],A
 026D 470020            tst [__r0],32
 0270 AFF2              jz L42
 0272                   .dbline 250
 0272           ;       
 0272           ;       xmitWait();
 0272 7C0E19            xcall _xmitWait
 0275                   .dbline 252
 0275           ;       
 0275           ;       configToggle(RX_MODE);  // Listen for the response.
 0275 5000              mov A,0
 0277 08                push A
 0278 5001              mov A,1
 027A 08                push A
 027B 7C0B2A            xcall _configToggle
 027E 38FE              add SP,-2
 0280                   .dbline 254
 0280           ;       
 0280           ;       if(module_id != BROADCAST)
 0280 3DFB00            cmp [X-5],0
 0283 B006              jnz X10
 0285 3DFCFE            cmp [X-4],-2
 0288 A07D              jz L45
 028A           X10:
 028A                   .dbline 255
 028A           ;       {
 028A                   .dbline 256
 028A           ;               RX_TIMEOUT_Stop();
 028A 10                push X
 028B 7C0000            xcall _RX_TIMEOUT_Stop
 028E 20                pop X
 028F                   .dbline 257
 028F           ;               TIMEOUT = 0;
 028F 62D000            mov REG[0xd0],>_TIMEOUT
 0292 550100            mov [_TIMEOUT+1],0
 0295 550000            mov [_TIMEOUT],0
 0298                   .dbline 258
 0298           ;               RX_TIMEOUT_Start();
 0298 10                push X
 0299 7C0000            xcall _RX_TIMEOUT_Start
 029C 20                pop X
 029D 803C              xjmp L48
 029F           L47:
 029F                   .dbline 261
 029F           ;               
 029F           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 029F           ;               {
 029F                   .dbline 262
 029F           ;                       if(validTransmission())
 029F 90CB              xcall _validTransmission
 02A1 62D000            mov REG[0xd0],>__r0
 02A4 3C0000            cmp [__r0],0
 02A7 B006              jnz X11
 02A9 3C0000            cmp [__r1],0
 02AC A02D              jz L50
 02AE           X11:
 02AE                   .dbline 263
 02AE           ;                       {
 02AE                   .dbline 264
 02AE           ;                               if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 02AE 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02B1 3C00CD            cmp [_COMMAND_TYPE],-51
 02B4 B025              jnz L52
 02B6                   .dbline 265
 02B6           ;                               {
 02B6                   .dbline 267
 02B6           ;                                       // If this is for me, check who it was from.
 02B6           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 02B6 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 02B9 3C0000            cmp [_COMMAND_DESTINATION],0
 02BC B01D              jnz L54
 02BE                   .dbline 268
 02BE           ;                                       {
 02BE                   .dbline 269
 02BE           ;                                               if(COMMAND_SOURCE == module_id)
 02BE 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02C1 5100              mov A,[_COMMAND_SOURCE]
 02C3 62D000            mov REG[0xd0],>__r0
 02C6 5300              mov [__r1],A
 02C8 5000              mov A,0
 02CA 3BFB              cmp A,[X-5]
 02CC B00D              jnz L56
 02CE 5100              mov A,[__r1]
 02D0 3BFC              cmp A,[X-4]
 02D2 B007              jnz L56
 02D4           X12:
 02D4                   .dbline 270
 02D4           ;                                               {
 02D4                   .dbline 271
 02D4           ;                                                       response = 1;
 02D4 560101            mov [X+1],1
 02D7 560000            mov [X+0],0
 02DA                   .dbline 272
 02DA           ;                                               }
 02DA           L56:
 02DA                   .dbline 273
 02DA           ;                                       }
 02DA           L54:
 02DA                   .dbline 274
 02DA           ;                               }
 02DA           L52:
 02DA                   .dbline 275
 02DA           ;                       }
 02DA           L50:
 02DA                   .dbline 276
 02DA           ;               }
 02DA           L48:
 02DA                   .dbline 260
 02DA 62D000            mov REG[0xd0],>_TIMEOUT
 02DD 5101              mov A,[_TIMEOUT+1]
 02DF 1105              sub A,5
 02E1 5100              mov A,[_TIMEOUT]
 02E3 3180              xor A,-128
 02E5 1980              sbb A,(0 ^ 0x80)
 02E7 D00B              jnc L58
 02E9           X13:
 02E9 3D0000            cmp [X+0],0
 02EC B006              jnz X14
 02EE 3D0100            cmp [X+1],0
 02F1 AFAD              jz L47
 02F3           X14:
 02F3           L58:
 02F3                   .dbline 278
 02F3           ;               
 02F3           ;               RX_TIMEOUT_Stop();
 02F3 10                push X
 02F4 7C0000            xcall _RX_TIMEOUT_Stop
 02F7 20                pop X
 02F8                   .dbline 279
 02F8           ;               TIMEOUT = 0;
 02F8 62D000            mov REG[0xd0],>_TIMEOUT
 02FB 550100            mov [_TIMEOUT+1],0
 02FE 550000            mov [_TIMEOUT],0
 0301                   .dbline 280
 0301           ;               RX_TIMEOUT_Start();
 0301 10                push X
 0302 7C0000            xcall _RX_TIMEOUT_Start
 0305 20                pop X
 0306                   .dbline 281
 0306           ;       }
 0306           L45:
 0306                   .dbline 283
 0306           ;       
 0306           ;       return response;
 0306 62D000            mov REG[0xd0],>__r0
 0309 5201              mov A,[X+1]
 030B 5300              mov [__r1],A
 030D 5200              mov A,[X+0]
 030F 5300              mov [__r0],A
 0311                   .dbline -2
 0311           L41:
 0311 38FE              add SP,-2
 0313 20                pop X
 0314                   .dbline 0 ; func end
 0314 7F                ret
 0315                   .dbsym l response 0 I
 0315                   .dbsym l module_id -5 I
 0315                   .dbend
 0315                   .dbfunc e sayHello _sayHello fV
 0315           _sayHello::
 0315                   .dbline -1
 0315                   .dbline 288
 0315           ; }
 0315           ; 
 0315           ; // This function transmits a hello message.
 0315           ; void sayHello(void)
 0315           ; {
 0315                   .dbline 289
 0315           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 0315 5000              mov A,0
 0317 08                push A
 0318 08                push A
 0319 7C0B2A            xcall _configToggle
 031C 38FE              add SP,-2
 031E                   .dbline 292
 031E           ;                       
 031E           ;       // Transmit a hello.
 031E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 031E 10                push X
 031F 50FC              mov A,-4
 0321 7C0000            xcall _TRANSMIT_PutChar
 0324 20                pop X
 0325                   .dbline 293
 0325           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0325 10                push X
 0326 50FC              mov A,-4
 0328 7C0000            xcall _TRANSMIT_PutChar
 032B 20                pop X
 032C                   .dbline 294
 032C           ;       TRANSMIT_PutChar(MASTER_ID);
 032C 10                push X
 032D 5000              mov A,0
 032F 7C0000            xcall _TRANSMIT_PutChar
 0332 20                pop X
 0333                   .dbline 295
 0333           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0333 10                push X
 0334 50FB              mov A,-5
 0336 7C0000            xcall _TRANSMIT_PutChar
 0339 20                pop X
 033A                   .dbline 296
 033A           ;       TRANSMIT_PutChar(HELLO_BYTE);
 033A 10                push X
 033B 50C8              mov A,-56
 033D 7C0000            xcall _TRANSMIT_PutChar
 0340 20                pop X
 0341                   .dbline 297
 0341           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0341 10                push X
 0342 50FD              mov A,-3
 0344 7C0000            xcall _TRANSMIT_PutChar
 0347 20                pop X
 0348                   .dbline 298
 0348           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0348 10                push X
 0349 50FD              mov A,-3
 034B 7C0000            xcall _TRANSMIT_PutChar
 034E 20                pop X
 034F           L60:
 034F                   .dbline 301
 034F           ;       
 034F           ;       // Wait for the transmission to finish.
 034F           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 034F           L61:
 034F                   .dbline 301
 034F 10                push X
 0350 7C0000            xcall _TRANSMIT_bReadTxStatus
 0353 62D000            mov REG[0xd0],>__r0
 0356 20                pop X
 0357 5300              mov [__r0],A
 0359 470020            tst [__r0],32
 035C AFF2              jz L60
 035E                   .dbline 303
 035E           ;       
 035E           ;       xmitWait();
 035E 7C0E19            xcall _xmitWait
 0361                   .dbline 305
 0361           ;       
 0361           ;       configToggle(RX_MODE);                          // Listen for the response.
 0361 5000              mov A,0
 0363 08                push A
 0364 5001              mov A,1
 0366 08                push A
 0367 97C1              xcall _configToggle
 0369 38FE              add SP,-2
 036B                   .dbline -2
 036B           L59:
 036B                   .dbline 0 ; func end
 036B 7F                ret
 036C                   .dbend
 036C                   .dbfunc e validTransmission _validTransmission fI
 036C           ; valid_transmit -> X+3
 036C           ;              i -> X+1
 036C           ;       tempByte -> X+0
 036C           _validTransmission::
 036C                   .dbline -1
 036C 10                push X
 036D 4F                mov X,SP
 036E 3805              add SP,5
 0370                   .dbline 310
 0370           ; }
 0370           ; 
 0370           ; // This function returns whether or not a valid transmission has been received.
 0370           ; int validTransmission(void)
 0370           ; {
 0370                   .dbline 311
 0370           ;       int valid_transmit = 0;
 0370 560400            mov [X+4],0
 0373 560300            mov [X+3],0
 0376                   .dbline 312
 0376           ;       int i = 0;
 0376 560200            mov [X+2],0
 0379 560100            mov [X+1],0
 037C                   .dbline 313
 037C           ;       char tempByte = 0;
 037C 560000            mov [X+0],0
 037F 80C2              xjmp L65
 0381           L64:
 0381                   .dbline 316
 0381           ;       
 0381           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0381           ;       {
 0381                   .dbline 317
 0381           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0381 10                push X
 0382 7C0000            xcall _RECEIVE_cReadChar
 0385 62D000            mov REG[0xd0],>__r0
 0388 20                pop X
 0389 39FC              cmp A,-4
 038B B0B6              jnz L67
 038D                   .dbline 318
 038D           ;               {
 038D 80A5              xjmp L70
 038F           L69:
 038F                   .dbline 320
 038F           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 038F           ;                       {
 038F                   .dbline 321
 038F           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 038F 10                push X
 0390 7C0000            xcall _RECEIVE_cReadChar
 0393 62D000            mov REG[0xd0],>__r0
 0396 20                pop X
 0397 39FC              cmp A,-4
 0399 B099              jnz L72
 039B                   .dbline 322
 039B           ;                               {
 039B 8088              xjmp L75
 039D           L74:
 039D                   .dbline 324
 039D           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 039D           ;                                       {
 039D                   .dbline 325
 039D           ;                                               if(tempByte = RECEIVE_cReadChar())
 039D 10                push X
 039E 7C0000            xcall _RECEIVE_cReadChar
 03A1 20                pop X
 03A2 5400              mov [X+0],A
 03A4 3900              cmp A,0
 03A6 A07D              jz L77
 03A8                   .dbline 326
 03A8           ;                                               {
 03A8                   .dbline 327
 03A8           ;                                                       COMMAND_SOURCE = tempByte;
 03A8 5200              mov A,[X+0]
 03AA 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 03AD 5300              mov [_COMMAND_SOURCE],A
 03AF 8065              xjmp L80
 03B1           L79:
 03B1                   .dbline 330
 03B1           ;                                                       
 03B1           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03B1           ;                                                       {
 03B1                   .dbline 331
 03B1           ;                                                               if(tempByte = RECEIVE_cReadChar())
 03B1 10                push X
 03B2 7C0000            xcall _RECEIVE_cReadChar
 03B5 62D000            mov REG[0xd0],>__r0
 03B8 20                pop X
 03B9 5400              mov [X+0],A
 03BB 3900              cmp A,0
 03BD A057              jz L82
 03BF                   .dbline 332
 03BF           ;                                                               {
 03BF                   .dbline 333
 03BF           ;                                                                       if(tempByte >= HELLO_BYTE)
 03BF 3D00C8            cmp [X+0],-56
 03C2 C052              jc L84
 03C4           X15:
 03C4                   .dbline 334
 03C4           ;                                                                       {
 03C4                   .dbline 335
 03C4           ;                                                                               COMMAND_TYPE = tempByte;
 03C4 5200              mov A,[X+0]
 03C6 62D000            mov REG[0xd0],>_COMMAND_TYPE
 03C9 5300              mov [_COMMAND_TYPE],A
 03CB 803A              xjmp L87
 03CD           L86:
 03CD                   .dbline 338
 03CD           ;                                                                               
 03CD           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 03CD           ;                                                                               {
 03CD                   .dbline 339
 03CD           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 03CD 10                push X
 03CE 7C0000            xcall _RECEIVE_cReadChar
 03D1 62D000            mov REG[0xd0],>__r0
 03D4 20                pop X
 03D5 5400              mov [X+0],A
 03D7 3900              cmp A,0
 03D9 A02C              jz L89
 03DB                   .dbline 340
 03DB           ;                                                                                       {
 03DB                   .dbline 341
 03DB           ;                                                                                               if(tempByte != END_TRANSMIT)
 03DB 3D00FD            cmp [X+0],-3
 03DE A018              jz L91
 03E0                   .dbline 342
 03E0           ;                                                                                               {
 03E0                   .dbline 343
 03E0           ;                                                                                                       PARAM[i] = tempByte;
 03E0 5202              mov A,[X+2]
 03E2 0100              add A,<_PARAM
 03E4 5300              mov [__r1],A
 03E6 5201              mov A,[X+1]
 03E8 0900              adc A,>_PARAM
 03EA 60D5              mov REG[0xd5],A
 03EC 5200              mov A,[X+0]
 03EE 3F00              mvi [__r1],A
 03F0                   .dbline 344
 03F0           ;                                                                                                       i++;
 03F0 7702              inc [X+2]
 03F2 0F0100            adc [X+1],0
 03F5                   .dbline 345
 03F5           ;                                                                                               }
 03F5 8010              xjmp L92
 03F7           L91:
 03F7                   .dbline 347
 03F7           ;                                                                                               else
 03F7           ;                                                                                               {
 03F7                   .dbline 348
 03F7           ;                                                                                                       valid_transmit = 1;
 03F7 560401            mov [X+4],1
 03FA 560300            mov [X+3],0
 03FD                   .dbline 349
 03FD           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 03FD 62D000            mov REG[0xd0],>_TIMEOUT
 0400 550105            mov [_TIMEOUT+1],5
 0403 550000            mov [_TIMEOUT],0
 0406                   .dbline 350
 0406           ;                                                                                               }
 0406           L92:
 0406                   .dbline 351
 0406           ;                                                                                       }
 0406           L89:
 0406                   .dbline 352
 0406           ;                                                                               }
 0406           L87:
 0406                   .dbline 337
 0406 62D000            mov REG[0xd0],>_TIMEOUT
 0409 5101              mov A,[_TIMEOUT+1]
 040B 1105              sub A,5
 040D 5100              mov A,[_TIMEOUT]
 040F 3180              xor A,-128
 0411 1980              sbb A,(0 ^ 0x80)
 0413 CFB9              jc L86
 0415           X16:
 0415                   .dbline 353
 0415           ;                                                                       }
 0415           L84:
 0415                   .dbline 354
 0415           ;                                                               }
 0415           L82:
 0415                   .dbline 355
 0415           ;                                                       }
 0415           L80:
 0415                   .dbline 329
 0415 62D000            mov REG[0xd0],>_TIMEOUT
 0418 5101              mov A,[_TIMEOUT+1]
 041A 1105              sub A,5
 041C 5100              mov A,[_TIMEOUT]
 041E 3180              xor A,-128
 0420 1980              sbb A,(0 ^ 0x80)
 0422 CF8E              jc L79
 0424           X17:
 0424                   .dbline 356
 0424           ;                                               }
 0424           L77:
 0424                   .dbline 357
 0424           ;                                       }
 0424           L75:
 0424                   .dbline 323
 0424 62D000            mov REG[0xd0],>_TIMEOUT
 0427 5101              mov A,[_TIMEOUT+1]
 0429 1105              sub A,5
 042B 5100              mov A,[_TIMEOUT]
 042D 3180              xor A,-128
 042F 1980              sbb A,(0 ^ 0x80)
 0431 CF6B              jc L74
 0433           X18:
 0433                   .dbline 358
 0433           ;                               }
 0433           L72:
 0433                   .dbline 359
 0433           ;                       }
 0433           L70:
 0433                   .dbline 319
 0433 62D000            mov REG[0xd0],>_TIMEOUT
 0436 5101              mov A,[_TIMEOUT+1]
 0438 1105              sub A,5
 043A 5100              mov A,[_TIMEOUT]
 043C 3180              xor A,-128
 043E 1980              sbb A,(0 ^ 0x80)
 0440 CF4E              jc L69
 0442           X19:
 0442                   .dbline 360
 0442           ;               }
 0442           L67:
 0442                   .dbline 361
 0442           ;       }
 0442           L65:
 0442                   .dbline 315
 0442 62D000            mov REG[0xd0],>_TIMEOUT
 0445 5101              mov A,[_TIMEOUT+1]
 0447 1105              sub A,5
 0449 5100              mov A,[_TIMEOUT]
 044B 3180              xor A,-128
 044D 1980              sbb A,(0 ^ 0x80)
 044F CF31              jc L64
 0451           X20:
 0451                   .dbline 363
 0451           ;       
 0451           ;       return valid_transmit;
 0451 62D000            mov REG[0xd0],>__r0
 0454 5204              mov A,[X+4]
 0456 5300              mov [__r1],A
 0458 5203              mov A,[X+3]
 045A 5300              mov [__r0],A
 045C                   .dbline -2
 045C           L63:
 045C 38FB              add SP,-5
 045E 20                pop X
 045F                   .dbline 0 ; func end
 045F 7F                ret
 0460                   .dbsym l valid_transmit 3 I
 0460                   .dbsym l i 1 I
 0460                   .dbsym l tempByte 0 c
 0460                   .dbend
 0460                   .dbfunc e decodeTransmission _decodeTransmission fV
 0460           ;          angle -> X+8
 0460           ;          total -> X+6
 0460           ;             ID -> X+5
 0460           ;       tempByte -> X+4
 0460           ;   runningTotal -> X+2
 0460           ;          param -> X+0
 0460           _decodeTransmission::
 0460                   .dbline -1
 0460 10                push X
 0461 4F                mov X,SP
 0462 380A              add SP,10
 0464                   .dbline 368
 0464           ; }
 0464           ; 
 0464           ; // This function decodes the transmission and takes the correct action.
 0464           ; void decodeTransmission(void)
 0464           ; {
 0464                   .dbline 370
 0464           ;       char* param;
 0464           ;       char ID = 0;
 0464 560500            mov [X+5],0
 0467                   .dbline 373
 0467           ;       char tempByte;
 0467           ;       char angle[2];
 0467           ;       int total = 0;
 0467 560700            mov [X+7],0
 046A 560600            mov [X+6],0
 046D                   .dbline 374
 046D           ;       int runningTotal = 0;
 046D 560300            mov [X+3],0
 0470 560200            mov [X+2],0
 0473                   .dbline 376
 0473           ;       
 0473           ;       if(param = COMP_SERIAL_szGetParam())
 0473 10                push X
 0474 7C0000            xcall _COMP_SERIAL_szGetParam
 0477 62D000            mov REG[0xd0],>__r0
 047A 5300              mov [__r0],A
 047C 5A00              mov [__r1],X
 047E 20                pop X
 047F 5100              mov A,[__r1]
 0481 5401              mov [X+1],A
 0483 5100              mov A,[__r0]
 0485 5400              mov [X+0],A
 0487 3C0000            cmp [__r0],0
 048A B006              jnz X21
 048C 3C0000            cmp [__r1],0
 048F A51B              jz L94
 0491           X21:
 0491                   .dbline 377
 0491           ;       {
 0491                   .dbline 378
 0491           ;               if((param[0] == 'n') || (param[0] == 'N'))
 0491 62D000            mov REG[0xd0],>__r0
 0494 5201              mov A,[X+1]
 0496 5300              mov [__r1],A
 0498 5200              mov A,[X+0]
 049A 60D4              mov REG[0xd4],A
 049C 3E00              mvi A,[__r1]
 049E 5300              mov [__r1],A
 04A0 550000            mov [__r0],0
 04A3 3C0000            cmp [__r0],0
 04A6 B005              jnz X22
 04A8 396E              cmp A,110
 04AA A00E              jz L98
 04AC           X22:
 04AC 62D000            mov REG[0xd0],>__r0
 04AF 3C0000            cmp [__r0],0
 04B2 B035              jnz L96
 04B4 3C004E            cmp [__r1],78
 04B7 B030              jnz L96
 04B9           X23:
 04B9           L98:
 04B9                   .dbline 379
 04B9           ;               {
 04B9                   .dbline 380
 04B9           ;                       itoa(param,NUM_MODULES,10);
 04B9 5000              mov A,0
 04BB 08                push A
 04BC 500A              mov A,10
 04BE 08                push A
 04BF 62D000            mov REG[0xd0],>_NUM_MODULES
 04C2 5100              mov A,[_NUM_MODULES]
 04C4 08                push A
 04C5 5101              mov A,[_NUM_MODULES+1]
 04C7 08                push A
 04C8 5200              mov A,[X+0]
 04CA 08                push A
 04CB 5201              mov A,[X+1]
 04CD 08                push A
 04CE 7C0000            xcall _itoa
 04D1 38FA              add SP,-6
 04D3                   .dbline 381
 04D3           ;                       COMP_SERIAL_PutString(param);
 04D3 10                push X
 04D4 5200              mov A,[X+0]
 04D6 08                push A
 04D7 5201              mov A,[X+1]
 04D9 5C                mov X,A
 04DA 18                pop A
 04DB 7C0000            xcall _COMP_SERIAL_PutString
 04DE 20                pop X
 04DF                   .dbline 382
 04DF           ;                       COMP_SERIAL_PutChar('\n');
 04DF 10                push X
 04E0 500A              mov A,10
 04E2 7C0000            xcall _COMP_SERIAL_PutChar
 04E5 20                pop X
 04E6                   .dbline 383
 04E6           ;               }
 04E6 84C4              xjmp L97
 04E8           L96:
 04E8                   .dbline 384
 04E8           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04E8 62D000            mov REG[0xd0],>__r0
 04EB 5201              mov A,[X+1]
 04ED 5300              mov [__r1],A
 04EF 5200              mov A,[X+0]
 04F1 60D4              mov REG[0xd4],A
 04F3 3E00              mvi A,[__r1]
 04F5 5300              mov [__r1],A
 04F7 550000            mov [__r0],0
 04FA 3C0000            cmp [__r0],0
 04FD B005              jnz X24
 04FF 3977              cmp A,119
 0501 A00E              jz L101
 0503           X24:
 0503 62D000            mov REG[0xd0],>__r0
 0506 3C0000            cmp [__r0],0
 0509 B161              jnz L99
 050B 3C0057            cmp [__r1],87
 050E B15C              jnz L99
 0510           X25:
 0510           L101:
 0510                   .dbline 385
 0510           ;               {
 0510                   .dbline 386
 0510           ;                       if(param = COMP_SERIAL_szGetParam())
 0510 10                push X
 0511 7C0000            xcall _COMP_SERIAL_szGetParam
 0514 62D000            mov REG[0xd0],>__r0
 0517 5300              mov [__r0],A
 0519 5A00              mov [__r1],X
 051B 20                pop X
 051C 5100              mov A,[__r1]
 051E 5401              mov [X+1],A
 0520 5100              mov A,[__r0]
 0522 5400              mov [X+0],A
 0524 3C0000            cmp [__r0],0
 0527 B006              jnz X26
 0529 3C0000            cmp [__r1],0
 052C A47E              jz L100
 052E           X26:
 052E                   .dbline 387
 052E           ;                       {
 052E                   .dbline 388
 052E           ;                               ID = atoi(param);
 052E 5200              mov A,[X+0]
 0530 08                push A
 0531 5201              mov A,[X+1]
 0533 08                push A
 0534 7C0000            xcall _atoi
 0537 38FE              add SP,-2
 0539 62D000            mov REG[0xd0],>__r0
 053C 5100              mov A,[__r1]
 053E 5405              mov [X+5],A
 0540                   .dbline 390
 0540           ;                               
 0540           ;                               if(param = COMP_SERIAL_szGetParam())
 0540 10                push X
 0541 7C0000            xcall _COMP_SERIAL_szGetParam
 0544 62D000            mov REG[0xd0],>__r0
 0547 5300              mov [__r0],A
 0549 5A00              mov [__r1],X
 054B 20                pop X
 054C 5100              mov A,[__r1]
 054E 5401              mov [X+1],A
 0550 5100              mov A,[__r0]
 0552 5400              mov [X+0],A
 0554 3C0000            cmp [__r0],0
 0557 B006              jnz X27
 0559 3C0000            cmp [__r1],0
 055C A44E              jz L100
 055E           X27:
 055E                   .dbline 391
 055E           ;                               {
 055E                   .dbline 392
 055E           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 055E 62D000            mov REG[0xd0],>__r0
 0561 5201              mov A,[X+1]
 0563 5300              mov [__r1],A
 0565 5200              mov A,[X+0]
 0567 60D4              mov REG[0xd4],A
 0569 3E00              mvi A,[__r1]
 056B 5300              mov [__r1],A
 056D 550000            mov [__r0],0
 0570 3C0000            cmp [__r0],0
 0573 B005              jnz X28
 0575 3961              cmp A,97
 0577 A00E              jz L108
 0579           X28:
 0579 62D000            mov REG[0xd0],>__r0
 057C 3C0000            cmp [__r0],0
 057F B084              jnz L106
 0581 3C0041            cmp [__r1],65
 0584 B07F              jnz L106
 0586           X29:
 0586           L108:
 0586                   .dbline 393
 0586           ;                                       {
 0586                   .dbline 394
 0586           ;                                               if(param = COMP_SERIAL_szGetParam())
 0586 10                push X
 0587 7C0000            xcall _COMP_SERIAL_szGetParam
 058A 62D000            mov REG[0xd0],>__r0
 058D 5300              mov [__r0],A
 058F 5A00              mov [__r1],X
 0591 20                pop X
 0592 5100              mov A,[__r1]
 0594 5401              mov [X+1],A
 0596 5100              mov A,[__r0]
 0598 5400              mov [X+0],A
 059A 3C0000            cmp [__r0],0
 059D B006              jnz X30
 059F 3C0000            cmp [__r1],0
 05A2 A408              jz L100
 05A4           X30:
 05A4                   .dbline 395
 05A4           ;                                               {
 05A4                   .dbline 396
 05A4           ;                                                       total = atoi(param);
 05A4 5200              mov A,[X+0]
 05A6 08                push A
 05A7 5201              mov A,[X+1]
 05A9 08                push A
 05AA 7C0000            xcall _atoi
 05AD 38FE              add SP,-2
 05AF 62D000            mov REG[0xd0],>__r0
 05B2 5100              mov A,[__r1]
 05B4 5407              mov [X+7],A
 05B6 5100              mov A,[__r0]
 05B8 5406              mov [X+6],A
 05BA                   .dbline 397
 05BA           ;                                                       angle[0] = total%256;
 05BA 5001              mov A,1
 05BC 08                push A
 05BD 5000              mov A,0
 05BF 08                push A
 05C0 5206              mov A,[X+6]
 05C2 08                push A
 05C3 5207              mov A,[X+7]
 05C5 08                push A
 05C6 7C0000            xcall __divmod_16X16_16
 05C9 38FE              add SP,-2
 05CB 18                pop A
 05CC 5300              mov [__r1],A
 05CE 18                pop A
 05CF 5100              mov A,[__r1]
 05D1 5408              mov [X+8],A
 05D3                   .dbline 398
 05D3           ;                                                       angle[1] = total/256;
 05D3 5001              mov A,1
 05D5 08                push A
 05D6 5000              mov A,0
 05D8 08                push A
 05D9 5206              mov A,[X+6]
 05DB 08                push A
 05DC 5207              mov A,[X+7]
 05DE 08                push A
 05DF 7C0000            xcall __divmod_16X16_16
 05E2 18                pop A
 05E3 5300              mov [__r1],A
 05E5 18                pop A
 05E6 38FE              add SP,-2
 05E8 5100              mov A,[__r1]
 05EA 5409              mov [X+9],A
 05EC                   .dbline 399
 05EC           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05EC 5209              mov A,[X+9]
 05EE 08                push A
 05EF 5208              mov A,[X+8]
 05F1 08                push A
 05F2 501E              mov A,30
 05F4 08                push A
 05F5 5003              mov A,3
 05F7 08                push A
 05F8 5005              mov A,5
 05FA 08                push A
 05FB 5205              mov A,[X+5]
 05FD 08                push A
 05FE 9479              xcall _longServoInstruction
 0600 38FA              add SP,-6
 0602                   .dbline 400
 0602           ;                                               }
 0602                   .dbline 401
 0602           ;                                       }
 0602 83A8              xjmp L100
 0604           L106:
 0604                   .dbline 402
 0604           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 0604 62D000            mov REG[0xd0],>__r0
 0607 5201              mov A,[X+1]
 0609 5300              mov [__r1],A
 060B 5200              mov A,[X+0]
 060D 60D4              mov REG[0xd4],A
 060F 3E00              mvi A,[__r1]
 0611 5300              mov [__r1],A
 0613 550000            mov [__r0],0
 0616 3C0000            cmp [__r0],0
 0619 B005              jnz X31
 061B 3970              cmp A,112
 061D A00E              jz L115
 061F           X31:
 061F 62D000            mov REG[0xd0],>__r0
 0622 3C0000            cmp [__r0],0
 0625 B385              jnz L100
 0627 3C0050            cmp [__r1],80
 062A B380              jnz L100
 062C           X32:
 062C           L115:
 062C                   .dbline 403
 062C           ;                                       {
 062C                   .dbline 404
 062C           ;                                               if(param = COMP_SERIAL_szGetParam())
 062C 10                push X
 062D 7C0000            xcall _COMP_SERIAL_szGetParam
 0630 62D000            mov REG[0xd0],>__r0
 0633 5300              mov [__r0],A
 0635 5A00              mov [__r1],X
 0637 20                pop X
 0638 5100              mov A,[__r1]
 063A 5401              mov [X+1],A
 063C 5100              mov A,[__r0]
 063E 5400              mov [X+0],A
 0640 3C0000            cmp [__r0],0
 0643 B006              jnz X33
 0645 3C0000            cmp [__r1],0
 0648 A362              jz L100
 064A           X33:
 064A                   .dbline 405
 064A           ;                                               {
 064A                   .dbline 406
 064A           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 064A 5200              mov A,[X+0]
 064C 08                push A
 064D 5201              mov A,[X+1]
 064F 08                push A
 0650 7C0000            xcall _atoi
 0653 62D000            mov REG[0xd0],>__r0
 0656 5100              mov A,[__r1]
 0658 08                push A
 0659 5018              mov A,24
 065B 08                push A
 065C 5003              mov A,3
 065E 08                push A
 065F 5004              mov A,4
 0661 08                push A
 0662 5205              mov A,[X+5]
 0664 08                push A
 0665 936F              xcall _servoInstruction
 0667 38F9              add SP,-7
 0669                   .dbline 407
 0669           ;                                               }
 0669                   .dbline 408
 0669           ;                                       }
 0669                   .dbline 409
 0669           ;                               }
 0669                   .dbline 410
 0669           ;                       }
 0669                   .dbline 411
 0669           ;               }
 0669 8341              xjmp L100
 066B           L99:
 066B                   .dbline 412
 066B           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 066B 62D000            mov REG[0xd0],>__r0
 066E 5201              mov A,[X+1]
 0670 5300              mov [__r1],A
 0672 5200              mov A,[X+0]
 0674 60D4              mov REG[0xd4],A
 0676 3E00              mvi A,[__r1]
 0678 5300              mov [__r1],A
 067A 550000            mov [__r0],0
 067D 3C0000            cmp [__r0],0
 0680 B005              jnz X34
 0682 3972              cmp A,114
 0684 A00E              jz L120
 0686           X34:
 0686 62D000            mov REG[0xd0],>__r0
 0689 3C0000            cmp [__r0],0
 068C B31E              jnz L118
 068E 3C0052            cmp [__r1],82
 0691 B319              jnz L118
 0693           X35:
 0693           L120:
 0693                   .dbline 413
 0693           ;               {                       
 0693                   .dbline 414
 0693           ;                       if(param = COMP_SERIAL_szGetParam())
 0693 10                push X
 0694 7C0000            xcall _COMP_SERIAL_szGetParam
 0697 62D000            mov REG[0xd0],>__r0
 069A 5300              mov [__r0],A
 069C 5A00              mov [__r1],X
 069E 20                pop X
 069F 5100              mov A,[__r1]
 06A1 5401              mov [X+1],A
 06A3 5100              mov A,[__r0]
 06A5 5400              mov [X+0],A
 06A7 3C0000            cmp [__r0],0
 06AA B006              jnz X36
 06AC 3C0000            cmp [__r1],0
 06AF A2FB              jz L121
 06B1           X36:
 06B1                   .dbline 415
 06B1           ;                       {
 06B1                   .dbline 416
 06B1           ;                               ID = atoi(param);
 06B1 5200              mov A,[X+0]
 06B3 08                push A
 06B4 5201              mov A,[X+1]
 06B6 08                push A
 06B7 7C0000            xcall _atoi
 06BA 38FE              add SP,-2
 06BC 62D000            mov REG[0xd0],>__r0
 06BF 5100              mov A,[__r1]
 06C1 5405              mov [X+5],A
 06C3                   .dbline 417
 06C3           ;                               if(param = COMP_SERIAL_szGetParam())
 06C3 10                push X
 06C4 7C0000            xcall _COMP_SERIAL_szGetParam
 06C7 62D000            mov REG[0xd0],>__r0
 06CA 5300              mov [__r0],A
 06CC 5A00              mov [__r1],X
 06CE 20                pop X
 06CF 5100              mov A,[__r1]
 06D1 5401              mov [X+1],A
 06D3 5100              mov A,[__r0]
 06D5 5400              mov [X+0],A
 06D7 3C0000            cmp [__r0],0
 06DA B006              jnz X37
 06DC 3C0000            cmp [__r1],0
 06DF A2CB              jz L123
 06E1           X37:
 06E1                   .dbline 418
 06E1           ;                               {
 06E1                   .dbline 419
 06E1           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06E1 62D000            mov REG[0xd0],>__r0
 06E4 5201              mov A,[X+1]
 06E6 5300              mov [__r1],A
 06E8 5200              mov A,[X+0]
 06EA 60D4              mov REG[0xd4],A
 06EC 3E00              mvi A,[__r1]
 06EE 5300              mov [__r1],A
 06F0 550000            mov [__r0],0
 06F3 3C0000            cmp [__r0],0
 06F6 B005              jnz X38
 06F8 3961              cmp A,97
 06FA A00E              jz L127
 06FC           X38:
 06FC 62D000            mov REG[0xd0],>__r0
 06FF 3C0000            cmp [__r0],0
 0702 B0D1              jnz L125
 0704 3C0041            cmp [__r1],65
 0707 B0CC              jnz L125
 0709           X39:
 0709           L127:
 0709                   .dbline 420
 0709           ;                                       {
 0709                   .dbline 421
 0709           ;                                               angle[0] = 0;
 0709 560800            mov [X+8],0
 070C                   .dbline 422
 070C           ;                                               angle[1] = 0;
 070C 560900            mov [X+9],0
 070F                   .dbline 424
 070F           ;                                               
 070F           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 070F 5002              mov A,2
 0711 08                push A
 0712 5024              mov A,36
 0714 08                push A
 0715 5002              mov A,2
 0717 08                push A
 0718 5004              mov A,4
 071A 08                push A
 071B 5205              mov A,[X+5]
 071D 08                push A
 071E 92B6              xcall _servoInstruction
 0720                   .dbline 425
 0720           ;                                               configToggle(RX_MODE);
 0720 5000              mov A,0
 0722 08                push A
 0723 5001              mov A,1
 0725 08                push A
 0726 9402              xcall _configToggle
 0728 38F9              add SP,-7
 072A 8098              xjmp L130
 072C           L129:
 072C                   .dbline 429
 072C           ;                                                       
 072C           ;                                               // Loop until we read a response or time out.
 072C           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 072C           ;                                               {
 072C                   .dbline 430
 072C           ;                                                       if(RECEIVE_cReadChar() == ID)
 072C 10                push X
 072D 7C0000            xcall _RECEIVE_cReadChar
 0730 62D000            mov REG[0xd0],>__r0
 0733 20                pop X
 0734 3B05              cmp A,[X+5]
 0736 B08C              jnz L132
 0738                   .dbline 431
 0738           ;                                                       {
 0738 807B              xjmp L135
 073A           L134:
 073A                   .dbline 433
 073A           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 073A           ;                                                               {
 073A                   .dbline 434
 073A           ;                                                                       if(RECEIVE_cReadChar() == 4)
 073A 10                push X
 073B 7C0000            xcall _RECEIVE_cReadChar
 073E 62D000            mov REG[0xd0],>__r0
 0741 20                pop X
 0742 3904              cmp A,4
 0744 B06F              jnz L137
 0746                   .dbline 435
 0746           ;                                                                       {
 0746                   .dbline 436
 0746           ;                                                                               if(RECEIVE_cGetChar() == 0)
 0746 10                push X
 0747 7C0000            xcall _RECEIVE_cGetChar
 074A 62D000            mov REG[0xd0],>__r0
 074D 20                pop X
 074E 3900              cmp A,0
 0750 B05A              jnz L139
 0752                   .dbline 437
 0752           ;                                                                               {
 0752                   .dbline 438
 0752           ;                                                                                       angle[0] = RECEIVE_cGetChar();
 0752 10                push X
 0753 7C0000            xcall _RECEIVE_cGetChar
 0756 62D000            mov REG[0xd0],>__r0
 0759 20                pop X
 075A 5408              mov [X+8],A
 075C                   .dbline 439
 075C           ;                                                                                       angle[1] = RECEIVE_cGetChar();
 075C 10                push X
 075D 7C0000            xcall _RECEIVE_cGetChar
 0760 62D000            mov REG[0xd0],>__r0
 0763 20                pop X
 0764 5409              mov [X+9],A
 0766                   .dbline 441
 0766           ;                                                                                       
 0766           ;                                                                                       configToggle(PC_MODE);
 0766 5000              mov A,0
 0768 08                push A
 0769 5002              mov A,2
 076B 08                push A
 076C 93BC              xcall _configToggle
 076E                   .dbline 443
 076E           ;                                                                                       
 076E           ;                                                                                       total = ((angle[1])*256) + angle[0];
 076E 5208              mov A,[X+8]
 0770 5407              mov [X+7],A
 0772 5209              mov A,[X+9]
 0774 5406              mov [X+6],A
 0776                   .dbline 444
 0776           ;                                                                                       itoa(param,total,10);
 0776 5000              mov A,0
 0778 08                push A
 0779 500A              mov A,10
 077B 08                push A
 077C 5206              mov A,[X+6]
 077E 08                push A
 077F 5207              mov A,[X+7]
 0781 08                push A
 0782 5200              mov A,[X+0]
 0784 08                push A
 0785 5201              mov A,[X+1]
 0787 08                push A
 0788 7C0000            xcall _itoa
 078B 38F8              add SP,-8
 078D                   .dbline 445
 078D           ;                                                                                       COMP_SERIAL_PutString(param);
 078D 10                push X
 078E 5200              mov A,[X+0]
 0790 08                push A
 0791 5201              mov A,[X+1]
 0793 5C                mov X,A
 0794 18                pop A
 0795 7C0000            xcall _COMP_SERIAL_PutString
 0798 20                pop X
 0799                   .dbline 446
 0799           ;                                                                                       COMP_SERIAL_PutChar('\n');
 0799 10                push X
 079A 500A              mov A,10
 079C 7C0000            xcall _COMP_SERIAL_PutChar
 079F 20                pop X
 07A0                   .dbline 448
 07A0           ; 
 07A0           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 07A0 62D000            mov REG[0xd0],>_TIMEOUT
 07A3 550105            mov [_TIMEOUT+1],5
 07A6 550000            mov [_TIMEOUT],0
 07A9                   .dbline 449
 07A9           ;                                                                               }
 07A9 800A              xjmp L140
 07AB           L139:
 07AB                   .dbline 451
 07AB           ;                                                                               else
 07AB           ;                                                                               {
 07AB                   .dbline 452
 07AB           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 07AB 62D000            mov REG[0xd0],>_TIMEOUT
 07AE 550105            mov [_TIMEOUT+1],5
 07B1 550000            mov [_TIMEOUT],0
 07B4                   .dbline 453
 07B4           ;                                                                               }
 07B4           L140:
 07B4                   .dbline 454
 07B4           ;                                                                       }
 07B4           L137:
 07B4                   .dbline 455
 07B4           ;                                                               }
 07B4           L135:
 07B4                   .dbline 432
 07B4 62D000            mov REG[0xd0],>_TIMEOUT
 07B7 5101              mov A,[_TIMEOUT+1]
 07B9 1105              sub A,5
 07BB 5100              mov A,[_TIMEOUT]
 07BD 3180              xor A,-128
 07BF 1980              sbb A,(0 ^ 0x80)
 07C1 CF78              jc L134
 07C3           X40:
 07C3                   .dbline 456
 07C3           ;                                                       }
 07C3           L132:
 07C3                   .dbline 457
 07C3           ;                                               }
 07C3           L130:
 07C3                   .dbline 428
 07C3 62D000            mov REG[0xd0],>_TIMEOUT
 07C6 5101              mov A,[_TIMEOUT+1]
 07C8 1105              sub A,5
 07CA 5100              mov A,[_TIMEOUT]
 07CC 3180              xor A,-128
 07CE 1980              sbb A,(0 ^ 0x80)
 07D0 CF5B              jc L129
 07D2           X41:
 07D2                   .dbline 458
 07D2           ;                                       }
 07D2 81D8              xjmp L126
 07D4           L125:
 07D4                   .dbline 459
 07D4           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07D4 62D000            mov REG[0xd0],>__r0
 07D7 5201              mov A,[X+1]
 07D9 5300              mov [__r1],A
 07DB 5200              mov A,[X+0]
 07DD 60D4              mov REG[0xd4],A
 07DF 3E00              mvi A,[__r1]
 07E1 5300              mov [__r1],A
 07E3 550000            mov [__r0],0
 07E6 3C0000            cmp [__r0],0
 07E9 B005              jnz X42
 07EB 3970              cmp A,112
 07ED A00E              jz L145
 07EF           X42:
 07EF 62D000            mov REG[0xd0],>__r0
 07F2 3C0000            cmp [__r0],0
 07F5 B0EF              jnz L143
 07F7 3C0050            cmp [__r1],80
 07FA B0EA              jnz L143
 07FC           X43:
 07FC           L145:
 07FC                   .dbline 460
 07FC           ;                                       {
 07FC                   .dbline 461
 07FC           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 07FC 5001              mov A,1
 07FE 08                push A
 07FF 5018              mov A,24
 0801 08                push A
 0802 5002              mov A,2
 0804 08                push A
 0805 5004              mov A,4
 0807 08                push A
 0808 5205              mov A,[X+5]
 080A 08                push A
 080B 91C9              xcall _servoInstruction
 080D                   .dbline 462
 080D           ;                                               configToggle(RX_MODE);
 080D 5000              mov A,0
 080F 08                push A
 0810 5001              mov A,1
 0812 08                push A
 0813 9315              xcall _configToggle
 0815 38F9              add SP,-7
 0817 80BC              xjmp L147
 0819           L146:
 0819                   .dbline 466
 0819           ;                                               
 0819           ;                                               // Loop until we read a response or time out.
 0819           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0819           ;                                               {
 0819                   .dbline 467
 0819           ;                                                       if(RECEIVE_cReadChar() == ID)
 0819 10                push X
 081A 7C0000            xcall _RECEIVE_cReadChar
 081D 62D000            mov REG[0xd0],>__r0
 0820 20                pop X
 0821 3B05              cmp A,[X+5]
 0823 B0B0              jnz L149
 0825                   .dbline 468
 0825           ;                                                       {
 0825                   .dbline 469
 0825           ;                                                               runningTotal = ID;
 0825 5205              mov A,[X+5]
 0827 5403              mov [X+3],A
 0829 560200            mov [X+2],0
 082C 8098              xjmp L152
 082E           L151:
 082E                   .dbline 472
 082E           ;                                                               // Loop until we read a response or time out.
 082E           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 082E           ;                                                               {
 082E                   .dbline 474
 082E           ;                                                                       // Check the length of the packet.
 082E           ;                                                                       if(RECEIVE_cReadChar() == 3)
 082E 10                push X
 082F 7C0000            xcall _RECEIVE_cReadChar
 0832 62D000            mov REG[0xd0],>__r0
 0835 20                pop X
 0836 3903              cmp A,3
 0838 B08C              jnz L154
 083A                   .dbline 475
 083A           ;                                                                       {
 083A                   .dbline 476
 083A           ;                                                                               runningTotal += 3;
 083A 070303            add [X+3],3
 083D 0F0200            adc [X+2],0
 0840 8075              xjmp L157
 0842           L156:
 0842                   .dbline 479
 0842           ;                                                                               // Loop until we read a response or time out.
 0842           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0842           ;                                                                               {
 0842                   .dbline 481
 0842           ;                                                                                       // Check for the checksum or 1.
 0842           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 0842 10                push X
 0843 7C0000            xcall _RECEIVE_cReadChar
 0846 62D000            mov REG[0xd0],>__r0
 0849 20                pop X
 084A 5404              mov [X+4],A
 084C 3900              cmp A,0
 084E A067              jz L159
 0850                   .dbline 482
 0850           ;                                                                                       {
 0850                   .dbline 483
 0850           ;                                                                                               configToggle(PC_MODE);
 0850 5000              mov A,0
 0852 08                push A
 0853 5002              mov A,2
 0855 08                push A
 0856 92D2              xcall _configToggle
 0858 38FE              add SP,-2
 085A                   .dbline 485
 085A           ;                                                                                               
 085A           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 085A 62D000            mov REG[0xd0],>__r0
 085D 5204              mov A,[X+4]
 085F 5300              mov [__r1],A
 0861 550000            mov [__r0],0
 0864 50FF              mov A,-1
 0866 1200              sub A,[__r1]
 0868 5300              mov [__r1],A
 086A 5000              mov A,0
 086C 1A00              sbb A,[__r0]
 086E 5300              mov [__r0],A
 0870 5001              mov A,1
 0872 08                push A
 0873 5000              mov A,0
 0875 08                push A
 0876 5202              mov A,[X+2]
 0878 08                push A
 0879 5203              mov A,[X+3]
 087B 08                push A
 087C 7C0000            xcall __divmod_16X16_16
 087F 38FE              add SP,-2
 0881 18                pop A
 0882 5300              mov [__r3],A
 0884 18                pop A
 0885 3A00              cmp A,[__r0]
 0887 B017              jnz L161
 0889 5100              mov A,[__r3]
 088B 3A00              cmp A,[__r1]
 088D B011              jnz L161
 088F           X44:
 088F                   .dbline 486
 088F           ;                                                                                               {
 088F                   .dbline 488
 088F           ;                                                                                                       // Send a 0 if we hit the checksum.
 088F           ;                                                                                                       COMP_SERIAL_PutChar('0');
 088F 10                push X
 0890 5030              mov A,48
 0892 7C0000            xcall _COMP_SERIAL_PutChar
 0895 20                pop X
 0896                   .dbline 489
 0896           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 0896 10                push X
 0897 500A              mov A,10
 0899 7C0000            xcall _COMP_SERIAL_PutChar
 089C 20                pop X
 089D                   .dbline 490
 089D           ;                                                                                               }
 089D 800F              xjmp L162
 089F           L161:
 089F                   .dbline 492
 089F           ;                                                                                               else
 089F           ;                                                                                               {
 089F                   .dbline 494
 089F           ;                                                                                                       // Send a 1.
 089F           ;                                                                                                       COMP_SERIAL_PutChar('1');
 089F 10                push X
 08A0 5031              mov A,49
 08A2 7C0000            xcall _COMP_SERIAL_PutChar
 08A5 20                pop X
 08A6                   .dbline 495
 08A6           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 08A6 10                push X
 08A7 500A              mov A,10
 08A9 7C0000            xcall _COMP_SERIAL_PutChar
 08AC 20                pop X
 08AD                   .dbline 496
 08AD           ;                                                                                               }
 08AD           L162:
 08AD                   .dbline 498
 08AD           ;               
 08AD           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 08AD 62D000            mov REG[0xd0],>_TIMEOUT
 08B0 550105            mov [_TIMEOUT+1],5
 08B3 550000            mov [_TIMEOUT],0
 08B6                   .dbline 499
 08B6           ;                                                                                       }
 08B6           L159:
 08B6                   .dbline 500
 08B6           ;                                                                               }
 08B6           L157:
 08B6                   .dbline 478
 08B6 62D000            mov REG[0xd0],>_TIMEOUT
 08B9 5101              mov A,[_TIMEOUT+1]
 08BB 1105              sub A,5
 08BD 5100              mov A,[_TIMEOUT]
 08BF 3180              xor A,-128
 08C1 1980              sbb A,(0 ^ 0x80)
 08C3 CF7E              jc L156
 08C5           X45:
 08C5                   .dbline 501
 08C5           ;                                                                       }
 08C5           L154:
 08C5                   .dbline 502
 08C5           ;                                                               }
 08C5           L152:
 08C5                   .dbline 471
 08C5 62D000            mov REG[0xd0],>_TIMEOUT
 08C8 5101              mov A,[_TIMEOUT+1]
 08CA 1105              sub A,5
 08CC 5100              mov A,[_TIMEOUT]
 08CE 3180              xor A,-128
 08D0 1980              sbb A,(0 ^ 0x80)
 08D2 CF5B              jc L151
 08D4           X46:
 08D4                   .dbline 503
 08D4           ;                                                       }
 08D4           L149:
 08D4                   .dbline 504
 08D4           ;                                               }
 08D4           L147:
 08D4                   .dbline 465
 08D4 62D000            mov REG[0xd0],>_TIMEOUT
 08D7 5101              mov A,[_TIMEOUT+1]
 08D9 1105              sub A,5
 08DB 5100              mov A,[_TIMEOUT]
 08DD 3180              xor A,-128
 08DF 1980              sbb A,(0 ^ 0x80)
 08E1 CF37              jc L146
 08E3           X47:
 08E3                   .dbline 505
 08E3           ;                                       }
 08E3 80C7              xjmp L144
 08E5           L143:
 08E5                   .dbline 506
 08E5           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 08E5 62D000            mov REG[0xd0],>__r0
 08E8 5201              mov A,[X+1]
 08EA 5300              mov [__r1],A
 08EC 5200              mov A,[X+0]
 08EE 60D4              mov REG[0xd4],A
 08F0 3E00              mvi A,[__r1]
 08F2 5300              mov [__r1],A
 08F4 550000            mov [__r0],0
 08F7 3C0000            cmp [__r0],0
 08FA B005              jnz X48
 08FC 3974              cmp A,116
 08FE A00E              jz L165
 0900           X48:
 0900 62D000            mov REG[0xd0],>__r0
 0903 3C0000            cmp [__r0],0
 0906 B042              jnz L163
 0908 3C0054            cmp [__r1],84
 090B B03D              jnz L163
 090D           X49:
 090D           L165:
 090D                   .dbline 507
 090D           ;                                       {
 090D                   .dbline 508
 090D           ;                                               if(pingModule(ID))
 090D 62D000            mov REG[0xd0],>__r0
 0910 5205              mov A,[X+5]
 0912 5300              mov [__r1],A
 0914 5000              mov A,0
 0916 08                push A
 0917 5100              mov A,[__r1]
 0919 08                push A
 091A 7C0037            xcall _pingModule
 091D 38FE              add SP,-2
 091F 62D000            mov REG[0xd0],>__r0
 0922 3C0000            cmp [__r0],0
 0925 B006              jnz X50
 0927 3C0000            cmp [__r1],0
 092A A080              jz L164
 092C           X50:
 092C                   .dbline 509
 092C           ;                                               {
 092C                   .dbline 510
 092C           ;                                                       configToggle(PC_MODE);
 092C 5000              mov A,0
 092E 08                push A
 092F 5002              mov A,2
 0931 08                push A
 0932 91F6              xcall _configToggle
 0934 38FE              add SP,-2
 0936                   .dbline 512
 0936           ;                                                                                               
 0936           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 0936 10                push X
 0937 62D000            mov REG[0xd0],>_PARAM
 093A 5100              mov A,[_PARAM]
 093C 7C0000            xcall _COMP_SERIAL_PutChar
 093F 20                pop X
 0940                   .dbline 513
 0940           ;                                                       COMP_SERIAL_PutChar('\n');
 0940 10                push X
 0941 500A              mov A,10
 0943 7C0000            xcall _COMP_SERIAL_PutChar
 0946 20                pop X
 0947                   .dbline 514
 0947           ;                                               }
 0947                   .dbline 515
 0947           ;                                       }
 0947 8063              xjmp L164
 0949           L163:
 0949                   .dbline 516
 0949           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0949 62D000            mov REG[0xd0],>__r0
 094C 5201              mov A,[X+1]
 094E 5300              mov [__r1],A
 0950 5200              mov A,[X+0]
 0952 60D4              mov REG[0xd4],A
 0954 3E00              mvi A,[__r1]
 0956 5300              mov [__r1],A
 0958 550000            mov [__r0],0
 095B 3C0000            cmp [__r0],0
 095E B005              jnz X51
 0960 3963              cmp A,99
 0962 A00E              jz L170
 0964           X51:
 0964 62D000            mov REG[0xd0],>__r0
 0967 3C0000            cmp [__r0],0
 096A B040              jnz L168
 096C 3C0043            cmp [__r1],67
 096F B03B              jnz L168
 0971           X52:
 0971           L170:
 0971                   .dbline 517
 0971           ;                                       {
 0971                   .dbline 518
 0971           ;                                               if(pingModule(ID))
 0971 62D000            mov REG[0xd0],>__r0
 0974 5205              mov A,[X+5]
 0976 5300              mov [__r1],A
 0978 5000              mov A,0
 097A 08                push A
 097B 5100              mov A,[__r1]
 097D 08                push A
 097E 7C0037            xcall _pingModule
 0981 38FE              add SP,-2
 0983 62D000            mov REG[0xd0],>__r0
 0986 3C0000            cmp [__r0],0
 0989 B006              jnz X53
 098B 3C0000            cmp [__r1],0
 098E A01C              jz L171
 0990           X53:
 0990                   .dbline 519
 0990           ;                                               {       
 0990                   .dbline 520
 0990           ;                                                       configToggle(PC_MODE);
 0990 5000              mov A,0
 0992 08                push A
 0993 5002              mov A,2
 0995 08                push A
 0996 9192              xcall _configToggle
 0998 38FE              add SP,-2
 099A                   .dbline 522
 099A           ;                                                       
 099A           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 099A 10                push X
 099B 62D000            mov REG[0xd0],>_PARAM
 099E 5101              mov A,[_PARAM+1]
 09A0 7C0000            xcall _COMP_SERIAL_PutChar
 09A3 20                pop X
 09A4                   .dbline 523
 09A4           ;                                                       COMP_SERIAL_PutChar('\n');
 09A4 10                push X
 09A5 500A              mov A,10
 09A7 7C0000            xcall _COMP_SERIAL_PutChar
 09AA 20                pop X
 09AB                   .dbline 524
 09AB           ;                                               }
 09AB           L171:
 09AB                   .dbline 525
 09AB           ;                                       }
 09AB           L168:
 09AB           L164:
 09AB           L144:
 09AB           L126:
 09AB                   .dbline 526
 09AB           ;                               }
 09AB           L123:
 09AB                   .dbline 527
 09AB           ;                       }
 09AB           L121:
 09AB                   .dbline 528
 09AB           ;               }
 09AB           L118:
 09AB           L100:
 09AB           L97:
 09AB                   .dbline 529
 09AB           ;       }
 09AB           L94:
 09AB                   .dbline 531
 09AB           ;       
 09AB           ;       if(STATE != PC_MODE)
 09AB 62D000            mov REG[0xd0],>_STATE
 09AE 3C0000            cmp [_STATE],0
 09B1 B006              jnz X54
 09B3 3C0102            cmp [_STATE+1],2
 09B6 A00D              jz L174
 09B8           X54:
 09B8                   .dbline 532
 09B8           ;       {
 09B8                   .dbline 533
 09B8           ;               configToggle(PC_MODE);
 09B8 5000              mov A,0
 09BA 08                push A
 09BB 5002              mov A,2
 09BD 08                push A
 09BE 916A              xcall _configToggle
 09C0 38FE              add SP,-2
 09C2                   .dbline 534
 09C2           ;       }
 09C2 800F              xjmp L175
 09C4           L174:
 09C4                   .dbline 536
 09C4           ;       else
 09C4           ;       {
 09C4                   .dbline 537
 09C4           ;               TIMEOUT = 0;
 09C4 62D000            mov REG[0xd0],>_TIMEOUT
 09C7 550100            mov [_TIMEOUT+1],0
 09CA 550000            mov [_TIMEOUT],0
 09CD                   .dbline 538
 09CD           ;               COMP_SERIAL_CmdReset();
 09CD 10                push X
 09CE 7C0000            xcall _COMP_SERIAL_CmdReset
 09D1 20                pop X
 09D2                   .dbline 539
 09D2           ;       }
 09D2           L175:
 09D2                   .dbline -2
 09D2           L93:
 09D2 38F6              add SP,-10
 09D4 20                pop X
 09D5                   .dbline 0 ; func end
 09D5 7F                ret
 09D6                   .dbsym l angle 8 A[2:2]c
 09D6                   .dbsym l total 6 I
 09D6                   .dbsym l ID 5 c
 09D6                   .dbsym l tempByte 4 c
 09D6                   .dbsym l runningTotal 2 I
 09D6                   .dbsym l param 0 pc
 09D6                   .dbend
 09D6                   .dbfunc e servoInstruction _servoInstruction fV
 09D6           ;          total -> X+1
 09D6           ;       checksum -> X+0
 09D6           ;          value -> X-8
 09D6           ;        address -> X-7
 09D6           ;    instruction -> X-6
 09D6           ;         length -> X-5
 09D6           ;             id -> X-4
 09D6           _servoInstruction::
 09D6                   .dbline -1
 09D6 10                push X
 09D7 4F                mov X,SP
 09D8 3803              add SP,3
 09DA                   .dbline 545
 09DA           ; }
 09DA           ; 
 09DA           ; // This function receives a destination, command length, instruction type, address, and value.
 09DA           ; // With these parameters, the function sends a packet to the communication bus.
 09DA           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 09DA           ; {
 09DA                   .dbline 549
 09DA           ;       char checksum;
 09DA           ;       int total;
 09DA           ;       
 09DA           ;       total = id + length + instruction + address + value;
 09DA 62D000            mov REG[0xd0],>__r0
 09DD 52FB              mov A,[X-5]
 09DF 5300              mov [__r1],A
 09E1 550000            mov [__r0],0
 09E4 52FC              mov A,[X-4]
 09E6 0200              add A,[__r1]
 09E8 5300              mov [__r1],A
 09EA 5000              mov A,0
 09EC 0A00              adc A,[__r0]
 09EE 5300              mov [__r0],A
 09F0 52FA              mov A,[X-6]
 09F2 0400              add [__r1],A
 09F4 0E0000            adc [__r0],0
 09F7 52F9              mov A,[X-7]
 09F9 0400              add [__r1],A
 09FB 0E0000            adc [__r0],0
 09FE 52F8              mov A,[X-8]
 0A00 5300              mov [__r3],A
 0A02 550000            mov [__r2],0
 0A05 5100              mov A,[__r1]
 0A07 0200              add A,[__r3]
 0A09 5402              mov [X+2],A
 0A0B 5100              mov A,[__r0]
 0A0D 0A00              adc A,[__r2]
 0A0F 5401              mov [X+1],A
 0A11                   .dbline 552
 0A11           ;       
 0A11           ;       // Calculate the checksum value for our servo communication.
 0A11           ;       checksum = 255-(total%256);
 0A11 5001              mov A,1
 0A13 08                push A
 0A14 5000              mov A,0
 0A16 08                push A
 0A17 5201              mov A,[X+1]
 0A19 08                push A
 0A1A 5202              mov A,[X+2]
 0A1C 08                push A
 0A1D 7C0000            xcall __divmod_16X16_16
 0A20 38FE              add SP,-2
 0A22 18                pop A
 0A23 5300              mov [__r1],A
 0A25 18                pop A
 0A26 50FF              mov A,-1
 0A28 1200              sub A,[__r1]
 0A2A 5400              mov [X+0],A
 0A2C                   .dbline 555
 0A2C           ;       
 0A2C           ;       // Talk to the servo.
 0A2C           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0A2C 10                push X
 0A2D 50FF              mov A,-1
 0A2F 7C0000            xcall _TX_REPEATER_PutChar
 0A32 20                pop X
 0A33                   .dbline 556
 0A33           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0A33 10                push X
 0A34 50FF              mov A,-1
 0A36 7C0000            xcall _TX_REPEATER_PutChar
 0A39 20                pop X
 0A3A                   .dbline 557
 0A3A           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0A3A 10                push X
 0A3B 52FC              mov A,[X-4]
 0A3D 7C0000            xcall _TX_REPEATER_PutChar
 0A40 20                pop X
 0A41                   .dbline 558
 0A41           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0A41 10                push X
 0A42 52FB              mov A,[X-5]
 0A44 7C0000            xcall _TX_REPEATER_PutChar
 0A47 20                pop X
 0A48                   .dbline 559
 0A48           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0A48 10                push X
 0A49 52FA              mov A,[X-6]
 0A4B 7C0000            xcall _TX_REPEATER_PutChar
 0A4E 20                pop X
 0A4F                   .dbline 560
 0A4F           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0A4F 10                push X
 0A50 52F9              mov A,[X-7]
 0A52 7C0000            xcall _TX_REPEATER_PutChar
 0A55 20                pop X
 0A56                   .dbline 561
 0A56           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0A56 10                push X
 0A57 52F8              mov A,[X-8]
 0A59 7C0000            xcall _TX_REPEATER_PutChar
 0A5C 20                pop X
 0A5D                   .dbline 562
 0A5D           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0A5D 10                push X
 0A5E 5200              mov A,[X+0]
 0A60 7C0000            xcall _TX_REPEATER_PutChar
 0A63 20                pop X
 0A64           L177:
 0A64                   .dbline 565
 0A64           ;       
 0A64           ;       // Wait for the transmission to finish.
 0A64           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0A64           L178:
 0A64                   .dbline 565
 0A64 10                push X
 0A65 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0A68 62D000            mov REG[0xd0],>__r0
 0A6B 20                pop X
 0A6C 5300              mov [__r0],A
 0A6E 470020            tst [__r0],32
 0A71 AFF2              jz L177
 0A73                   .dbline 568
 0A73           ;       
 0A73           ;       // Make completely sure we're done.
 0A73           ;       xmitWait();
 0A73 93A4              xcall _xmitWait
 0A75                   .dbline -2
 0A75           L176:
 0A75 38FD              add SP,-3
 0A77 20                pop X
 0A78                   .dbline 0 ; func end
 0A78 7F                ret
 0A79                   .dbsym l total 1 I
 0A79                   .dbsym l checksum 0 c
 0A79                   .dbsym l value -8 c
 0A79                   .dbsym l address -7 c
 0A79                   .dbsym l instruction -6 c
 0A79                   .dbsym l length -5 c
 0A79                   .dbsym l id -4 c
 0A79                   .dbend
 0A79                   .dbfunc e longServoInstruction _longServoInstruction fV
 0A79           ;          total -> X+1
 0A79           ;       checksum -> X+0
 0A79           ;         value2 -> X-9
 0A79           ;         value1 -> X-8
 0A79           ;        address -> X-7
 0A79           ;    instruction -> X-6
 0A79           ;         length -> X-5
 0A79           ;             id -> X-4
 0A79           _longServoInstruction::
 0A79                   .dbline -1
 0A79 10                push X
 0A7A 4F                mov X,SP
 0A7B 3803              add SP,3
 0A7D                   .dbline 573
 0A7D           ; }
 0A7D           ; 
 0A7D           ; // This function receives a destination, command length, instruction type, address, and two values.
 0A7D           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0A7D           ; {
 0A7D                   .dbline 577
 0A7D           ;       char checksum;
 0A7D           ;       int total;
 0A7D           ;       
 0A7D           ;       total = id + length + instruction + address + value1 + value2;
 0A7D 62D000            mov REG[0xd0],>__r0
 0A80 52FB              mov A,[X-5]
 0A82 5300              mov [__r1],A
 0A84 550000            mov [__r0],0
 0A87 52FC              mov A,[X-4]
 0A89 0200              add A,[__r1]
 0A8B 5300              mov [__r1],A
 0A8D 5000              mov A,0
 0A8F 0A00              adc A,[__r0]
 0A91 5300              mov [__r0],A
 0A93 52FA              mov A,[X-6]
 0A95 0400              add [__r1],A
 0A97 0E0000            adc [__r0],0
 0A9A 52F9              mov A,[X-7]
 0A9C 0400              add [__r1],A
 0A9E 0E0000            adc [__r0],0
 0AA1 52F8              mov A,[X-8]
 0AA3 0400              add [__r1],A
 0AA5 0E0000            adc [__r0],0
 0AA8 52F7              mov A,[X-9]
 0AAA 5300              mov [__r3],A
 0AAC 550000            mov [__r2],0
 0AAF 5100              mov A,[__r1]
 0AB1 0200              add A,[__r3]
 0AB3 5402              mov [X+2],A
 0AB5 5100              mov A,[__r0]
 0AB7 0A00              adc A,[__r2]
 0AB9 5401              mov [X+1],A
 0ABB                   .dbline 580
 0ABB           ;       
 0ABB           ;       // Calculate the checksum value for our servo communication.
 0ABB           ;       checksum = 255-(total%256);
 0ABB 5001              mov A,1
 0ABD 08                push A
 0ABE 5000              mov A,0
 0AC0 08                push A
 0AC1 5201              mov A,[X+1]
 0AC3 08                push A
 0AC4 5202              mov A,[X+2]
 0AC6 08                push A
 0AC7 7C0000            xcall __divmod_16X16_16
 0ACA 38FE              add SP,-2
 0ACC 18                pop A
 0ACD 5300              mov [__r1],A
 0ACF 18                pop A
 0AD0 50FF              mov A,-1
 0AD2 1200              sub A,[__r1]
 0AD4 5400              mov [X+0],A
 0AD6                   .dbline 583
 0AD6           ;       
 0AD6           ;       // Talk to the servo.
 0AD6           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0AD6 10                push X
 0AD7 50FF              mov A,-1
 0AD9 7C0000            xcall _TX_REPEATER_PutChar
 0ADC 20                pop X
 0ADD                   .dbline 584
 0ADD           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0ADD 10                push X
 0ADE 50FF              mov A,-1
 0AE0 7C0000            xcall _TX_REPEATER_PutChar
 0AE3 20                pop X
 0AE4                   .dbline 585
 0AE4           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0AE4 10                push X
 0AE5 52FC              mov A,[X-4]
 0AE7 7C0000            xcall _TX_REPEATER_PutChar
 0AEA 20                pop X
 0AEB                   .dbline 586
 0AEB           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0AEB 10                push X
 0AEC 52FB              mov A,[X-5]
 0AEE 7C0000            xcall _TX_REPEATER_PutChar
 0AF1 20                pop X
 0AF2                   .dbline 587
 0AF2           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0AF2 10                push X
 0AF3 52FA              mov A,[X-6]
 0AF5 7C0000            xcall _TX_REPEATER_PutChar
 0AF8 20                pop X
 0AF9                   .dbline 588
 0AF9           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0AF9 10                push X
 0AFA 52F9              mov A,[X-7]
 0AFC 7C0000            xcall _TX_REPEATER_PutChar
 0AFF 20                pop X
 0B00                   .dbline 589
 0B00           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0B00 10                push X
 0B01 52F8              mov A,[X-8]
 0B03 7C0000            xcall _TX_REPEATER_PutChar
 0B06 20                pop X
 0B07                   .dbline 590
 0B07           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0B07 10                push X
 0B08 52F7              mov A,[X-9]
 0B0A 7C0000            xcall _TX_REPEATER_PutChar
 0B0D 20                pop X
 0B0E                   .dbline 591
 0B0E           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0B0E 10                push X
 0B0F 5200              mov A,[X+0]
 0B11 7C0000            xcall _TX_REPEATER_PutChar
 0B14 20                pop X
 0B15           L181:
 0B15                   .dbline 594
 0B15           ;       
 0B15           ;       // Wait for the transmission to finish.
 0B15           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0B15           L182:
 0B15                   .dbline 594
 0B15 10                push X
 0B16 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0B19 62D000            mov REG[0xd0],>__r0
 0B1C 20                pop X
 0B1D 5300              mov [__r0],A
 0B1F 470020            tst [__r0],32
 0B22 AFF2              jz L181
 0B24                   .dbline 597
 0B24           ;       
 0B24           ;       // Make completely sure we're done.
 0B24           ;       xmitWait();
 0B24 92F3              xcall _xmitWait
 0B26                   .dbline -2
 0B26           L180:
 0B26 38FD              add SP,-3
 0B28 20                pop X
 0B29                   .dbline 0 ; func end
 0B29 7F                ret
 0B2A                   .dbsym l total 1 I
 0B2A                   .dbsym l checksum 0 c
 0B2A                   .dbsym l value2 -9 c
 0B2A                   .dbsym l value1 -8 c
 0B2A                   .dbsym l address -7 c
 0B2A                   .dbsym l instruction -6 c
 0B2A                   .dbsym l length -5 c
 0B2A                   .dbsym l id -4 c
 0B2A                   .dbend
 0B2A                   .dbfunc e configToggle _configToggle fV
 0B2A           ;           mode -> X-5
 0B2A           _configToggle::
 0B2A                   .dbline -1
 0B2A 10                push X
 0B2B 4F                mov X,SP
 0B2C                   .dbline 603
 0B2C           ; }
 0B2C           ; 
 0B2C           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0B2C           ; // half duplex UART serial communication line.
 0B2C           ; void configToggle(int mode)
 0B2C           ; {
 0B2C                   .dbline 605
 0B2C           ;       // Disconnect from the global bus and leave the pin high.
 0B2C           ;       PRT0DR |= 0b11111111;
 0B2C 4300FF            or REG[0],-1
 0B2F                   .dbline 606
 0B2F           ;       PRT0GS &= 0b00000000;
 0B2F 620200            mov REG[0x2],0
 0B32                   .dbline 610
 0B32           ; 
 0B32           ;       // Unload the configuration of the current state.
 0B32           ;       // If there is no state, blindly wipe all configurations.
 0B32           ;       if(STATE)
 0B32 62D000            mov REG[0xd0],>_STATE
 0B35 3C0000            cmp [_STATE],0
 0B38 B006              jnz X55
 0B3A 3C0100            cmp [_STATE+1],0
 0B3D A010              jz L185
 0B3F           X55:
 0B3F                   .dbline 611
 0B3F           ;       {
 0B3F                   .dbline 612
 0B3F           ;               unloadConfig(STATE);
 0B3F 62D000            mov REG[0xd0],>_STATE
 0B42 5100              mov A,[_STATE]
 0B44 08                push A
 0B45 5101              mov A,[_STATE+1]
 0B47 08                push A
 0B48 90C9              xcall _unloadConfig
 0B4A 38FE              add SP,-2
 0B4C                   .dbline 613
 0B4C           ;       }
 0B4C 8003              xjmp L186
 0B4E           L185:
 0B4E                   .dbline 615
 0B4E           ;       else
 0B4E           ;       {
 0B4E                   .dbline 616
 0B4E           ;               unloadAllConfigs();
 0B4E 90B9              xcall _unloadAllConfigs
 0B50                   .dbline 617
 0B50           ;       }
 0B50           L186:
 0B50                   .dbline 619
 0B50           ;       
 0B50           ;       if(mode == PC_MODE)
 0B50 3DFB00            cmp [X-5],0
 0B53 B037              jnz L187
 0B55 3DFC02            cmp [X-4],2
 0B58 B032              jnz L187
 0B5A           X56:
 0B5A                   .dbline 620
 0B5A           ;       {
 0B5A                   .dbline 621
 0B5A           ;               LoadConfig_pc_listener();
 0B5A 7C0000            xcall _LoadConfig_pc_listener
 0B5D                   .dbline 623
 0B5D           ; 
 0B5D           ;               COMP_SERIAL_CmdReset();                                                 // Initialize the buffer.
 0B5D 10                push X
 0B5E 7C0000            xcall _COMP_SERIAL_CmdReset
 0B61 20                pop X
 0B62                   .dbline 624
 0B62           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0B62 10                push X
 0B63 5001              mov A,1
 0B65 7C0000            xcall _COMP_SERIAL_IntCntl
 0B68 20                pop X
 0B69                   .dbline 625
 0B69           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0B69 10                push X
 0B6A 5000              mov A,0
 0B6C 7C0000            xcall _COMP_SERIAL_Start
 0B6F 20                pop X
 0B70                   .dbline 627
 0B70           ;               
 0B70           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0B70 10                push X
 0B71 5000              mov A,0
 0B73 7C0000            xcall _TX_REPEATER_Start
 0B76 20                pop X
 0B77                   .dbline 629
 0B77           ;               
 0B77           ;               TIMEOUT = 0;
 0B77 62D000            mov REG[0xd0],>_TIMEOUT
 0B7A 550100            mov [_TIMEOUT+1],0
 0B7D 550000            mov [_TIMEOUT],0
 0B80                   .dbline 630
 0B80           ;               STATE = PC_MODE;
 0B80 62D000            mov REG[0xd0],>_STATE
 0B83 550102            mov [_STATE+1],2
 0B86 550000            mov [_STATE],0
 0B89                   .dbline 631
 0B89           ;       }
 0B89 807A              xjmp L188
 0B8B           L187:
 0B8B                   .dbline 632
 0B8B           ;       else if(mode == RX_MODE)
 0B8B 3DFB00            cmp [X-5],0
 0B8E B02C              jnz L189
 0B90 3DFC01            cmp [X-4],1
 0B93 B027              jnz L189
 0B95           X57:
 0B95                   .dbline 633
 0B95           ;       {
 0B95                   .dbline 634
 0B95           ;               LoadConfig_receiver_config();
 0B95 7C0000            xcall _LoadConfig_receiver_config
 0B98                   .dbline 637
 0B98           ;               
 0B98           ;               // Start the receiver.
 0B98           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0B98 10                push X
 0B99 5000              mov A,0
 0B9B 7C0000            xcall _RECEIVE_Start
 0B9E 20                pop X
 0B9F                   .dbline 640
 0B9F           ;               
 0B9F           ;               // Start response timeout timer and enable its interrupt routine.
 0B9F           ;               TIMEOUT = 0;
 0B9F 62D000            mov REG[0xd0],>_TIMEOUT
 0BA2 550100            mov [_TIMEOUT+1],0
 0BA5 550000            mov [_TIMEOUT],0
 0BA8                   .dbline 641
 0BA8           ;               RX_TIMEOUT_EnableInt();
 0BA8 10                push X
 0BA9 7C0000            xcall _RX_TIMEOUT_EnableInt
 0BAC                   .dbline 642
 0BAC           ;               RX_TIMEOUT_Start();
 0BAC 7C0000            xcall _RX_TIMEOUT_Start
 0BAF 20                pop X
 0BB0                   .dbline 644
 0BB0           ;               
 0BB0           ;               STATE = RX_MODE;
 0BB0 62D000            mov REG[0xd0],>_STATE
 0BB3 550101            mov [_STATE+1],1
 0BB6 550000            mov [_STATE],0
 0BB9                   .dbline 645
 0BB9           ;       }
 0BB9 804A              xjmp L190
 0BBB           L189:
 0BBB                   .dbline 646
 0BBB           ;       else if(mode == TX_MODE)
 0BBB 3DFB00            cmp [X-5],0
 0BBE B045              jnz L191
 0BC0 3DFC00            cmp [X-4],0
 0BC3 B040              jnz L191
 0BC5           X58:
 0BC5                   .dbline 647
 0BC5           ;       {
 0BC5                   .dbline 648
 0BC5           ;               LoadConfig_transmitter_config();
 0BC5 7C0000            xcall _LoadConfig_transmitter_config
 0BC8                   .dbline 650
 0BC8           ;               // Start the transmitter.
 0BC8           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0BC8 10                push X
 0BC9 5000              mov A,0
 0BCB 7C0000            xcall _TRANSMIT_Start
 0BCE 20                pop X
 0BCF                   .dbline 652
 0BCF           ;               
 0BCF           ;               TIMEOUT = 0;
 0BCF 62D000            mov REG[0xd0],>_TIMEOUT
 0BD2 550100            mov [_TIMEOUT+1],0
 0BD5 550000            mov [_TIMEOUT],0
 0BD8                   .dbline 653
 0BD8           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0BD8 10                push X
 0BD9 7C0000            xcall _TX_TIMEOUT_EnableInt
 0BDC                   .dbline 654
 0BDC           ;               TX_TIMEOUT_Start();             // Start the timer.
 0BDC 7C0000            xcall _TX_TIMEOUT_Start
 0BDF 20                pop X
 0BE0           L193:
 0BE0                   .dbline 657
 0BE0           ;               
 0BE0           ;               while(!TIMEOUT)
 0BE0           ;               {
 0BE0                   .dbline 660
 0BE0           ;                       // Do nothing while we wait for one timeout period.
 0BE0           ;                       // This is to allow everyone to get in the right configuration.
 0BE0           ;               }
 0BE0           L194:
 0BE0                   .dbline 656
 0BE0 62D000            mov REG[0xd0],>_TIMEOUT
 0BE3 3C0000            cmp [_TIMEOUT],0
 0BE6 B006              jnz X59
 0BE8 3C0100            cmp [_TIMEOUT+1],0
 0BEB AFF4              jz L193
 0BED           X59:
 0BED                   .dbline 662
 0BED           ;               
 0BED           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0BED 10                push X
 0BEE 7C0000            xcall _TX_TIMEOUT_Stop
 0BF1 20                pop X
 0BF2                   .dbline 663
 0BF2           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0BF2 62D000            mov REG[0xd0],>_TIMEOUT
 0BF5 550100            mov [_TIMEOUT+1],0
 0BF8 550000            mov [_TIMEOUT],0
 0BFB                   .dbline 665
 0BFB           ;               
 0BFB           ;               STATE = TX_MODE;
 0BFB 62D000            mov REG[0xd0],>_STATE
 0BFE 550100            mov [_STATE+1],0
 0C01 550000            mov [_STATE],0
 0C04                   .dbline 666
 0C04           ;       }
 0C04           L191:
 0C04           L190:
 0C04           L188:
 0C04                   .dbline 669
 0C04           ;       
 0C04           ;       // Reconnect to the global bus.
 0C04           ;       PRT0GS |= 0b11111111;
 0C04 4302FF            or REG[0x2],-1
 0C07                   .dbline -2
 0C07           L184:
 0C07 20                pop X
 0C08                   .dbline 0 ; func end
 0C08 7F                ret
 0C09                   .dbsym l mode -5 I
 0C09                   .dbend
 0C09                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0C09           _unloadAllConfigs::
 0C09                   .dbline -1
 0C09                   .dbline 675
 0C09           ; }
 0C09           ; 
 0C09           ; // This function blindly unloads all user configurations. This will be called once,
 0C09           ; // when the system initially has no known state.
 0C09           ; void unloadAllConfigs(void)
 0C09           ; {
 0C09                   .dbline 676
 0C09           ;       UnloadConfig_pc_listener();
 0C09 7C0000            xcall _UnloadConfig_pc_listener
 0C0C                   .dbline 677
 0C0C           ;       UnloadConfig_receiver_config();
 0C0C 7C0000            xcall _UnloadConfig_receiver_config
 0C0F                   .dbline 678
 0C0F           ;       UnloadConfig_transmitter_config();
 0C0F 7C0000            xcall _UnloadConfig_transmitter_config
 0C12                   .dbline -2
 0C12           L196:
 0C12                   .dbline 0 ; func end
 0C12 7F                ret
 0C13                   .dbend
 0C13                   .dbfunc e unloadConfig _unloadConfig fV
 0C13           ;     config_num -> X-5
 0C13           _unloadConfig::
 0C13                   .dbline -1
 0C13 10                push X
 0C14 4F                mov X,SP
 0C15                   .dbline 684
 0C15           ; }
 0C15           ; 
 0C15           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C15           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C15           ; void unloadConfig(int config_num)
 0C15           ; {
 0C15                   .dbline 685
 0C15           ;       if(config_num == PC_MODE)
 0C15 3DFB00            cmp [X-5],0
 0C18 B00B              jnz L198
 0C1A 3DFC02            cmp [X-4],2
 0C1D B006              jnz L198
 0C1F           X60:
 0C1F                   .dbline 686
 0C1F           ;       {
 0C1F                   .dbline 687
 0C1F           ;               UnloadConfig_pc_listener();
 0C1F 7C0000            xcall _UnloadConfig_pc_listener
 0C22                   .dbline 688
 0C22           ;       }
 0C22 801D              xjmp L199
 0C24           L198:
 0C24                   .dbline 689
 0C24           ;       else if(config_num == RX_MODE)
 0C24 3DFB00            cmp [X-5],0
 0C27 B00B              jnz L200
 0C29 3DFC01            cmp [X-4],1
 0C2C B006              jnz L200
 0C2E           X61:
 0C2E                   .dbline 690
 0C2E           ;       {
 0C2E                   .dbline 691
 0C2E           ;               UnloadConfig_receiver_config();
 0C2E 7C0000            xcall _UnloadConfig_receiver_config
 0C31                   .dbline 692
 0C31           ;       }
 0C31 800E              xjmp L201
 0C33           L200:
 0C33                   .dbline 693
 0C33           ;       else if(config_num == TX_MODE)
 0C33 3DFB00            cmp [X-5],0
 0C36 B009              jnz L202
 0C38 3DFC00            cmp [X-4],0
 0C3B B004              jnz L202
 0C3D           X62:
 0C3D                   .dbline 694
 0C3D           ;       {
 0C3D                   .dbline 695
 0C3D           ;               UnloadConfig_transmitter_config();
 0C3D 7C0000            xcall _UnloadConfig_transmitter_config
 0C40                   .dbline 696
 0C40           ;       }
 0C40           L202:
 0C40           L201:
 0C40           L199:
 0C40                   .dbline -2
 0C40           L197:
 0C40 20                pop X
 0C41                   .dbline 0 ; func end
 0C41 7F                ret
 0C42                   .dbsym l config_num -5 I
 0C42                   .dbend
 0C42                   .dbfunc e busListen _busListen fV
 0C42           _busListen::
 0C42                   .dbline -1
 0C42                   .dbline 700
 0C42           ; }
 0C42           ; 
 0C42           ; void busListen(void)
 0C42           ; {
 0C42                   .dbline 701
 0C42           ;       configToggle(RX_MODE);
 0C42 5000              mov A,0
 0C44 08                push A
 0C45 5001              mov A,1
 0C47 08                push A
 0C48 9EE0              xcall _configToggle
 0C4A 38FE              add SP,-2
 0C4C 8013              xjmp L206
 0C4E           L205:
 0C4E                   .dbline 705
 0C4E           ; 
 0C4E           ;       // Wait for the first byte.
 0C4E           ;       while(TIMEOUT < BOOT_TIMEOUT)
 0C4E           ;       {       
 0C4E                   .dbline 706
 0C4E           ;               if(RECEIVE_cReadChar())
 0C4E 10                push X
 0C4F 7C0000            xcall _RECEIVE_cReadChar
 0C52 20                pop X
 0C53 3900              cmp A,0
 0C55 A00A              jz L208
 0C57                   .dbline 707
 0C57           ;               {
 0C57                   .dbline 708
 0C57           ;                       TIMEOUT = BOOT_TIMEOUT;
 0C57 62D000            mov REG[0xd0],>_TIMEOUT
 0C5A 55012C            mov [_TIMEOUT+1],44
 0C5D 550001            mov [_TIMEOUT],1
 0C60                   .dbline 709
 0C60           ;               }
 0C60           L208:
 0C60                   .dbline 710
 0C60           ;       }
 0C60           L206:
 0C60                   .dbline 704
 0C60 62D000            mov REG[0xd0],>_TIMEOUT
 0C63 5101              mov A,[_TIMEOUT+1]
 0C65 112C              sub A,44
 0C67 5100              mov A,[_TIMEOUT]
 0C69 3180              xor A,-128
 0C6B 1981              sbb A,(1 ^ 0x80)
 0C6D CFE0              jc L205
 0C6F           X63:
 0C6F                   .dbline 713
 0C6F           ;       
 0C6F           ;       // Clear the timeout flag.
 0C6F           ;       TIMEOUT = 0;
 0C6F 62D000            mov REG[0xd0],>_TIMEOUT
 0C72 550100            mov [_TIMEOUT+1],0
 0C75 550000            mov [_TIMEOUT],0
 0C78 8013              xjmp L211
 0C7A           L210:
 0C7A                   .dbline 717
 0C7A           ;       
 0C7A           ;       // Wait for BUS_CLEAR_TIME to pass without hearing a byte.
 0C7A           ;       while(TIMEOUT < BUS_CLEAR_TIME)
 0C7A           ;       {       
 0C7A                   .dbline 718
 0C7A           ;               if(RECEIVE_cReadChar())
 0C7A 10                push X
 0C7B 7C0000            xcall _RECEIVE_cReadChar
 0C7E 20                pop X
 0C7F 3900              cmp A,0
 0C81 A00A              jz L213
 0C83                   .dbline 719
 0C83           ;               {
 0C83                   .dbline 720
 0C83           ;                       TIMEOUT = 0;    
 0C83 62D000            mov REG[0xd0],>_TIMEOUT
 0C86 550100            mov [_TIMEOUT+1],0
 0C89 550000            mov [_TIMEOUT],0
 0C8C                   .dbline 721
 0C8C           ;               }
 0C8C           L213:
 0C8C                   .dbline 722
 0C8C           ;       }
 0C8C           L211:
 0C8C                   .dbline 716
 0C8C 62D000            mov REG[0xd0],>_TIMEOUT
 0C8F 5101              mov A,[_TIMEOUT+1]
 0C91 1164              sub A,100
 0C93 5100              mov A,[_TIMEOUT]
 0C95 3180              xor A,-128
 0C97 1980              sbb A,(0 ^ 0x80)
 0C99 CFE0              jc L210
 0C9B           X64:
 0C9B                   .dbline -2
 0C9B           L204:
 0C9B                   .dbline 0 ; func end
 0C9B 7F                ret
 0C9C                   .dbend
 0C9C                   .dbfunc e initializeSlaves _initializeSlaves fV
 0C9C           ;   num_timeouts -> X+4
 0C9C           ;     ping_tries -> X+2
 0C9C           ;              i -> X+0
 0C9C           _initializeSlaves::
 0C9C                   .dbline -1
 0C9C 10                push X
 0C9D 4F                mov X,SP
 0C9E 3806              add SP,6
 0CA0                   .dbline 726
 0CA0           ; }
 0CA0           ; 
 0CA0           ; void initializeSlaves(void)
 0CA0           ; {
 0CA0                   .dbline 727
 0CA0           ;       int num_timeouts = 0;   // The number of consecutive timeouts.
 0CA0 560500            mov [X+5],0
 0CA3 560400            mov [X+4],0
 0CA6                   .dbline 728
 0CA6           ;       int ping_tries = 5;             // The number of times to try a ping on an unregistered module.
 0CA6 560305            mov [X+3],5
 0CA9 560200            mov [X+2],0
 0CAC                   .dbline 729
 0CAC           ;       int i = 0;                              // An iterator for looping.
 0CAC 560100            mov [X+1],0
 0CAF 560000            mov [X+0],0
 0CB2                   .dbline 732
 0CB2           ;       
 0CB2           ;       // Set num modules to zero.
 0CB2           ;       NUM_MODULES = 0;
 0CB2 62D000            mov REG[0xd0],>_NUM_MODULES
 0CB5 550100            mov [_NUM_MODULES+1],0
 0CB8 550000            mov [_NUM_MODULES],0
 0CBB                   .dbline 735
 0CBB           ;       
 0CBB           ;       // Send out a probing message.
 0CBB           ;       sayHello();
 0CBB 7C0315            xcall _sayHello
 0CBE 80D7              xjmp L217
 0CC0           L216:
 0CC0                   .dbline 740
 0CC0           ;       
 0CC0           ;       // This loop continuously probes and listens at intervals
 0CC0           ;       // set by the RX_TIMEOUT_DURATION variable.
 0CC0           ;       while(num_timeouts < MAX_TIMEOUTS)
 0CC0           ;       {       
 0CC0                   .dbline 741
 0CC0           ;               if(validTransmission())
 0CC0 7C036C            xcall _validTransmission
 0CC3 62D000            mov REG[0xd0],>__r0
 0CC6 3C0000            cmp [__r0],0
 0CC9 B006              jnz X65
 0CCB 3C0000            cmp [__r1],0
 0CCE A0A1              jz L219
 0CD0           X65:
 0CD0                   .dbline 742
 0CD0           ;               {
 0CD0                   .dbline 743
 0CD0           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0CD0 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0CD3 3C00C8            cmp [_COMMAND_TYPE],-56
 0CD6 B0BF              jnz L220
 0CD8                   .dbline 744
 0CD8           ;                       {
 0CD8                   .dbline 746
 0CD8           ;                               // If this is for me, assign them an ID.
 0CD8           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0CD8 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0CDB 3C0000            cmp [_COMMAND_DESTINATION],0
 0CDE B0B7              jnz L220
 0CE0                   .dbline 747
 0CE0           ;                               {
 0CE0                   .dbline 748
 0CE0           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0CE0 62D000            mov REG[0xd0],>_NUM_MODULES
 0CE3 7601              inc [_NUM_MODULES+1]
 0CE5 0E0000            adc [_NUM_MODULES],0
 0CE8                   .dbline 749
 0CE8           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0CE8 560500            mov [X+5],0
 0CEB 560400            mov [X+4],0
 0CEE                   .dbline 751
 0CEE           ;               
 0CEE           ;                                       if(!assignID(NUM_MODULES))
 0CEE 5100              mov A,[_NUM_MODULES]
 0CF0 08                push A
 0CF1 5101              mov A,[_NUM_MODULES+1]
 0CF3 08                push A
 0CF4 7C0126            xcall _assignID
 0CF7 38FE              add SP,-2
 0CF9 62D000            mov REG[0xd0],>__r0
 0CFC 3C0000            cmp [__r0],0
 0CFF B096              jnz L220
 0D01 3C0000            cmp [__r1],0
 0D04 B091              jnz L220
 0D06           X66:
 0D06                   .dbline 752
 0D06           ;                                       {
 0D06                   .dbline 756
 0D06           ;                                               // If the module did not respond that the ID was assigned,
 0D06           ;                                               // make an effort to ping it in case that transmission was lost
 0D06           ;                                               // before ultimately deciding that the module didn't configure.
 0D06           ;                                               for(i = 0; i < ping_tries; i++)
 0D06 560100            mov [X+1],0
 0D09 560000            mov [X+0],0
 0D0C 8038              xjmp L230
 0D0E           L227:
 0D0E                   .dbline 757
 0D0E           ;                                               {       
 0D0E                   .dbline 758
 0D0E           ;                                                       if(pingModule(NUM_MODULES))
 0D0E 62D000            mov REG[0xd0],>_NUM_MODULES
 0D11 5100              mov A,[_NUM_MODULES]
 0D13 08                push A
 0D14 5101              mov A,[_NUM_MODULES+1]
 0D16 08                push A
 0D17 7C0037            xcall _pingModule
 0D1A 38FE              add SP,-2
 0D1C 62D000            mov REG[0xd0],>__r0
 0D1F 3C0000            cmp [__r0],0
 0D22 B006              jnz X67
 0D24 3C0000            cmp [__r1],0
 0D27 A018              jz L231
 0D29           X67:
 0D29                   .dbline 759
 0D29           ;                                                       {
 0D29                   .dbline 760
 0D29           ;                                                               i = ping_tries*2;
 0D29 62D000            mov REG[0xd0],>__r0
 0D2C 5203              mov A,[X+3]
 0D2E 5300              mov [__r1],A
 0D30 5202              mov A,[X+2]
 0D32 5300              mov [__r0],A
 0D34 6500              asl [__r1]
 0D36 6B00              rlc [__r0]
 0D38 5100              mov A,[__r1]
 0D3A 5401              mov [X+1],A
 0D3C 5100              mov A,[__r0]
 0D3E 5400              mov [X+0],A
 0D40                   .dbline 761
 0D40           ;                                                       }
 0D40           L231:
 0D40                   .dbline 762
 0D40           ;                                               }
 0D40           L228:
 0D40                   .dbline 756
 0D40 7701              inc [X+1]
 0D42 0F0000            adc [X+0],0
 0D45           L230:
 0D45                   .dbline 756
 0D45 5201              mov A,[X+1]
 0D47 1303              sub A,[X+3]
 0D49 5202              mov A,[X+2]
 0D4B 3180              xor A,-128
 0D4D 62D000            mov REG[0xd0],>__r0
 0D50 5300              mov [__rX],A
 0D52 5200              mov A,[X+0]
 0D54 3180              xor A,-128
 0D56 1A00              sbb A,[__rX]
 0D58 CFB5              jc L227
 0D5A           X68:
 0D5A                   .dbline 765
 0D5A           ;                                               
 0D5A           ;                                               // If we landed right at ping_tries, we failed.
 0D5A           ;                                               if(i == ping_tries)
 0D5A 5200              mov A,[X+0]
 0D5C 3B02              cmp A,[X+2]
 0D5E B037              jnz L220
 0D60 5201              mov A,[X+1]
 0D62 3B03              cmp A,[X+3]
 0D64 B031              jnz L220
 0D66           X69:
 0D66                   .dbline 766
 0D66           ;                                               {
 0D66                   .dbline 767
 0D66           ;                                                       NUM_MODULES--;
 0D66 62D000            mov REG[0xd0],>_NUM_MODULES
 0D69 7A01              dec [_NUM_MODULES+1]
 0D6B 1E0000            sbb [_NUM_MODULES],0
 0D6E                   .dbline 768
 0D6E           ;                                               }
 0D6E                   .dbline 769
 0D6E           ;                                       }
 0D6E                   .dbline 770
 0D6E           ;                               }
 0D6E                   .dbline 771
 0D6E           ;                       }
 0D6E                   .dbline 772
 0D6E           ;               }
 0D6E 8027              xjmp L220
 0D70           L219:
 0D70                   .dbline 773
 0D70           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0D70 62D000            mov REG[0xd0],>_TIMEOUT
 0D73 5101              mov A,[_TIMEOUT+1]
 0D75 1105              sub A,5
 0D77 5100              mov A,[_TIMEOUT]
 0D79 3180              xor A,-128
 0D7B 1980              sbb A,(0 ^ 0x80)
 0D7D C018              jc L235
 0D7F           X70:
 0D7F                   .dbline 774
 0D7F           ;               {       
 0D7F                   .dbline 775
 0D7F           ;                       num_timeouts++;
 0D7F 7705              inc [X+5]
 0D81 0F0400            adc [X+4],0
 0D84                   .dbline 778
 0D84           ;                       
 0D84           ;                       // If we are not maxed out on modules, look for more.
 0D84           ;                       if(NUM_MODULES < MAX_MODULES)
 0D84 62D000            mov REG[0xd0],>_NUM_MODULES
 0D87 5101              mov A,[_NUM_MODULES+1]
 0D89 11FA              sub A,-6
 0D8B 5100              mov A,[_NUM_MODULES]
 0D8D 3180              xor A,-128
 0D8F 1980              sbb A,(0 ^ 0x80)
 0D91 D004              jnc L237
 0D93           X71:
 0D93                   .dbline 779
 0D93           ;                       {
 0D93                   .dbline 780
 0D93           ;                               sayHello();
 0D93 7C0315            xcall _sayHello
 0D96                   .dbline 781
 0D96           ;                       }
 0D96           L237:
 0D96                   .dbline 782
 0D96           ;               }
 0D96           L235:
 0D96           L220:
 0D96                   .dbline 783
 0D96           ;       }
 0D96           L217:
 0D96                   .dbline 739
 0D96 5205              mov A,[X+5]
 0D98 1132              sub A,50
 0D9A 5204              mov A,[X+4]
 0D9C 3180              xor A,-128
 0D9E 1980              sbb A,(0 ^ 0x80)
 0DA0 CF1F              jc L216
 0DA2           X72:
 0DA2                   .dbline 786
 0DA2           ;       
 0DA2           ;       // If we didn't find any new modules, check to see if some already exist.
 0DA2           ;       if(!NUM_MODULES)
 0DA2 62D000            mov REG[0xd0],>_NUM_MODULES
 0DA5 3C0000            cmp [_NUM_MODULES],0
 0DA8 B062              jnz L239
 0DAA 3C0100            cmp [_NUM_MODULES+1],0
 0DAD B05D              jnz L239
 0DAF           X73:
 0DAF                   .dbline 787
 0DAF           ;       {
 0DAF                   .dbline 789
 0DAF           ;               // Try to ping the next module up from our current number ping_tries times.
 0DAF           ;               for(i = 0; i < ping_tries; i++)
 0DAF 560100            mov [X+1],0
 0DB2 560000            mov [X+0],0
 0DB5 8040              xjmp L244
 0DB7           L241:
 0DB7                   .dbline 790
 0DB7           ;               {       
 0DB7                   .dbline 791
 0DB7           ;                       if(pingModule(NUM_MODULES+1))
 0DB7 62D000            mov REG[0xd0],>_NUM_MODULES
 0DBA 5101              mov A,[_NUM_MODULES+1]
 0DBC 0101              add A,1
 0DBE 62D000            mov REG[0xd0],>__r0
 0DC1 5300              mov [__r1],A
 0DC3 62D000            mov REG[0xd0],>_NUM_MODULES
 0DC6 5100              mov A,[_NUM_MODULES]
 0DC8 0900              adc A,0
 0DCA 62D000            mov REG[0xd0],>__r0
 0DCD 08                push A
 0DCE 5100              mov A,[__r1]
 0DD0 08                push A
 0DD1 7C0037            xcall _pingModule
 0DD4 38FE              add SP,-2
 0DD6 62D000            mov REG[0xd0],>__r0
 0DD9 3C0000            cmp [__r0],0
 0DDC B006              jnz X74
 0DDE 3C0000            cmp [__r1],0
 0DE1 A00F              jz L245
 0DE3           X74:
 0DE3                   .dbline 792
 0DE3           ;                       {
 0DE3                   .dbline 793
 0DE3           ;                               NUM_MODULES++;
 0DE3 62D000            mov REG[0xd0],>_NUM_MODULES
 0DE6 7601              inc [_NUM_MODULES+1]
 0DE8 0E0000            adc [_NUM_MODULES],0
 0DEB                   .dbline 794
 0DEB           ;                               i = 0;
 0DEB 560100            mov [X+1],0
 0DEE 560000            mov [X+0],0
 0DF1                   .dbline 795
 0DF1           ;                       }
 0DF1           L245:
 0DF1                   .dbline 796
 0DF1           ;               }
 0DF1           L242:
 0DF1                   .dbline 789
 0DF1 7701              inc [X+1]
 0DF3 0F0000            adc [X+0],0
 0DF6           L244:
 0DF6                   .dbline 789
 0DF6 5201              mov A,[X+1]
 0DF8 1303              sub A,[X+3]
 0DFA 5202              mov A,[X+2]
 0DFC 3180              xor A,-128
 0DFE 62D000            mov REG[0xd0],>__r0
 0E01 5300              mov [__rX],A
 0E03 5200              mov A,[X+0]
 0E05 3180              xor A,-128
 0E07 1A00              sbb A,[__rX]
 0E09 CFAD              jc L241
 0E0B           X75:
 0E0B                   .dbline 797
 0E0B           ;       }
 0E0B           L239:
 0E0B                   .dbline 800
 0E0B           ;       
 0E0B           ;       // Switch back to PC mode.
 0E0B           ;       configToggle(PC_MODE);
 0E0B 5000              mov A,0
 0E0D 08                push A
 0E0E 5002              mov A,2
 0E10 08                push A
 0E11 9D17              xcall _configToggle
 0E13 38FE              add SP,-2
 0E15                   .dbline -2
 0E15           L215:
 0E15 38FA              add SP,-6
 0E17 20                pop X
 0E18                   .dbline 0 ; func end
 0E18 7F                ret
 0E19                   .dbsym l num_timeouts 4 I
 0E19                   .dbsym l ping_tries 2 I
 0E19                   .dbsym l i 0 I
 0E19                   .dbend
 0E19                   .dbfunc e xmitWait _xmitWait fV
 0E19           ;              i -> X+0
 0E19           _xmitWait::
 0E19                   .dbline -1
 0E19 10                push X
 0E1A 4F                mov X,SP
 0E1B 3802              add SP,2
 0E1D                   .dbline 804
 0E1D           ; }
 0E1D           ; 
 0E1D           ; void xmitWait(void)
 0E1D           ; {
 0E1D                   .dbline 807
 0E1D           ;       int i;
 0E1D           ;       
 0E1D           ;       for(i = 0; i < 25; i++)
 0E1D 560100            mov [X+1],0
 0E20 560000            mov [X+0],0
 0E23           L248:
 0E23                   .dbline 808
 0E23           ;       {
 0E23                   .dbline 810
 0E23           ;               // Sit here and spin for about 50 microseconds.
 0E23           ;       }
 0E23           L249:
 0E23                   .dbline 807
 0E23 7701              inc [X+1]
 0E25 0F0000            adc [X+0],0
 0E28                   .dbline 807
 0E28 5201              mov A,[X+1]
 0E2A 1119              sub A,25
 0E2C 5200              mov A,[X+0]
 0E2E 3180              xor A,-128
 0E30 1980              sbb A,(0 ^ 0x80)
 0E32 CFF0              jc L248
 0E34           X76:
 0E34                   .dbline -2
 0E34           L247:
 0E34 38FE              add SP,-2
 0E36 20                pop X
 0E37                   .dbline 0 ; func end
 0E37 7F                ret
 0E38                   .dbsym l i 0 I
 0E38                   .dbend
 0E38                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0E38           _TX_TIMEOUT_ISR::
 0E38                   .dbline -1
 0E38 71C0              or F,-64
 0E3A 08                push A
 0E3B 5DD0              mov A,REG[0xd0]
 0E3D 08                push A
 0E3E                   .dbline 814
 0E3E           ; }
 0E3E           ; 
 0E3E           ; void TX_TIMEOUT_ISR(void)
 0E3E           ; {     
 0E3E                   .dbline 815
 0E3E           ;       TIMEOUT++;
 0E3E 62D000            mov REG[0xd0],>_TIMEOUT
 0E41 7601              inc [_TIMEOUT+1]
 0E43 0E0000            adc [_TIMEOUT],0
 0E46                   .dbline 817
 0E46           ;       
 0E46           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0E46 62DAFD            mov REG[0xda],-3
 0E49                   .dbline -2
 0E49           L252:
 0E49 18                pop A
 0E4A 60D0              mov REG[208],A
 0E4C 18                pop A
 0E4D                   .dbline 0 ; func end
 0E4D 7E                reti
 0E4E                   .dbend
 0E4E                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0E4E           _RX_TIMEOUT_ISR::
 0E4E                   .dbline -1
 0E4E 71C0              or F,-64
 0E50 08                push A
 0E51 5DD0              mov A,REG[0xd0]
 0E53 08                push A
 0E54                   .dbline 821
 0E54           ; }
 0E54           ; 
 0E54           ; void RX_TIMEOUT_ISR(void)
 0E54           ; {     
 0E54                   .dbline 822
 0E54           ;       TIMEOUT++;
 0E54 62D000            mov REG[0xd0],>_TIMEOUT
 0E57 7601              inc [_TIMEOUT+1]
 0E59 0E0000            adc [_TIMEOUT],0
 0E5C                   .dbline 824
 0E5C           ;       
 0E5C           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0E5C 62DAFD            mov REG[0xda],-3
 0E5F                   .dbline -2
 0E5F           L253:
 0E5F 18                pop A
 0E60 60D0              mov REG[208],A
 0E62 18                pop A
 0E63                   .dbline 0 ; func end
 0E63 7E                reti
 0E64                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
