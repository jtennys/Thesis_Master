 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 119
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 7-10-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the parent module of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; #include <stdlib.h>                   // Required for converting character arrays to and from floats and ints.
 0000           ; 
 0000           ; //#include <string.h>
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC and RX modes.
 0000           ; #define               PC_MODE                                         (1)
 0000           ; #define               RX_MODE                                         (2)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // This is the module type identifier.
 0000           ; #define               TYPE                                            ('2')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               COMMAND_TYPE_SPACE                      (200)   // The number where reserved command types start.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates parent is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the parent.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the parent is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               PARENT_ID                                       (0)             // The parent node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; #define               SERVO_START                                     (255)   // The start byte of a servo.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; // These defines are used for the initial probing stage.
 0000           ; #define               INIT_WAIT_TIME                          (50)    // Initial wait time between module probes.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the parent.
 0000           ; #define               MAX_MODULES                                     (250)
 0000           ; 
 0000           ; // Receives a mode identifier and toggles to that mode.
 0000           ; void configToggle(int mode);
 0000           ; // Pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; // Assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; // Attempts to read a valid transmission and store it.
 0000           ; int validTransmission(void);
 0000           ; // Reads a PC command and translates it to the correct packet type.
 0000           ; void decodeTransmission(void);
 0000           ; // Sends out a hello message packet.
 0000           ; void sayHello(void);
 0000           ; // Servo instruction function that sends read or write commands.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // Servo instruction function that sends long two-byte write commands.
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; // Immediately performs a non-blocking read char operation, and returns 0 upon failure.
 0000           ; char iReadChar(void);
 0000           ; // Performs a blocking read char operation.
 0000           ; char readChar(void);
 0000           ; // Checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // Unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the child module controllers.
 0000           ; void initializeChildren(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; // Listen for a child and record the port value.
 0000           ; void childListen(void);
 0000           ; 
 0000           ; int TIMEOUT;                          // This flag is incremented if there is a timeout.
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; char CHILD;                                   // The child port value stored from initialization.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 120
 0000           ;       NUM_MODULES = 0;        // Initialize the number of modules.
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 121
 0009           ;       STATE = 0;                      // Initialize the current hardware state.
 0009 62D000            mov REG[0xd0],>_STATE
 000C 550100            mov [_STATE+1],0
 000F 550000            mov [_STATE],0
 0012                   .dbline 124
 0012           ;       
 0012           ;       // Activate GPIO ISR.
 0012           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 0012 43E020            or REG[0xe0],32
 0015                   .dbline 127
 0015           ;       
 0015           ;       // Turn on global interrupts for the transmission timeout timer.
 0015           ;       M8C_EnableGInt;
 0015 7101                      or  F, 01h
 0017           
 0017 8021              xjmp L3
 0019           L2:
 0019                   .dbline 130
 0019           ;       
 0019           ;       while(1)
 0019           ;       {
 0019                   .dbline 132
 0019           ;               // If there are no modules, find some. Otherwise, look for computer commands.
 0019           ;               if(!NUM_MODULES)
 0019 62D000            mov REG[0xd0],>_NUM_MODULES
 001C 3C0000            cmp [_NUM_MODULES],0
 001F B00B              jnz L5
 0021 3C0100            cmp [_NUM_MODULES+1],0
 0024 B006              jnz L5
 0026           X1:
 0026                   .dbline 133
 0026           ;               {
 0026                   .dbline 134
 0026           ;                       initializeChildren();
 0026 7C0D1F            xcall _initializeChildren
 0029                   .dbline 135
 0029           ;               }
 0029 800F              xjmp L6
 002B           L5:
 002B                   .dbline 136
 002B           ;               else if(COMP_SERIAL_bCmdCheck())
 002B 10                push X
 002C 7C0000            xcall _COMP_SERIAL_bCmdCheck
 002F 62D000            mov REG[0xd0],>__r0
 0032 20                pop X
 0033 3900              cmp A,0
 0035 A003              jz L7
 0037                   .dbline 137
 0037           ;               {
 0037                   .dbline 138
 0037           ;                       decodeTransmission();
 0037 938A              xcall _decodeTransmission
 0039                   .dbline 139
 0039           ;               }
 0039           L7:
 0039           L6:
 0039                   .dbline 140
 0039           ;       }
 0039           L3:
 0039                   .dbline 129
 0039 8FDF              xjmp L2
 003B           X0:
 003B                   .dbline -2
 003B           L1:
 003B                   .dbline 0 ; func end
 003B 8FFF              jmp .
 003D                   .dbend
 003D                   .dbfunc e pingModule _pingModule fI
 003D           ;      module_id -> X-5
 003D           _pingModule::
 003D                   .dbline -1
 003D 10                push X
 003E 4F                mov X,SP
 003F                   .dbline 144
 003F           ; }
 003F           ; 
 003F           ; int pingModule(int module_id)
 003F           ; {
 003F                   .dbline 146
 003F           ;       // Toggle into PC mode.
 003F           ;       configToggle(PC_MODE);
 003F 5000              mov A,0
 0041 08                push A
 0042 5001              mov A,1
 0044 08                push A
 0045 7C0C25            xcall _configToggle
 0048 38FE              add SP,-2
 004A                   .dbline 149
 004A           ;       
 004A           ;       // Transmit a ping to everyone.
 004A           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte one
 004A 10                push X
 004B 50FC              mov A,-4
 004D 7C0000            xcall _TX_REPEATER_14_PutChar
 0050 20                pop X
 0051                   .dbline 150
 0051           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 0051 10                push X
 0052 50FC              mov A,-4
 0054 7C0000            xcall _TX_REPEATER_23_PutChar
 0057 20                pop X
 0058                   .dbline 151
 0058           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte two
 0058 10                push X
 0059 50FC              mov A,-4
 005B 7C0000            xcall _TX_REPEATER_14_PutChar
 005E 20                pop X
 005F                   .dbline 152
 005F           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 005F 10                push X
 0060 50FC              mov A,-4
 0062 7C0000            xcall _TX_REPEATER_23_PutChar
 0065 20                pop X
 0066                   .dbline 153
 0066           ;       TX_REPEATER_14_PutChar(PARENT_ID);                      // My ID
 0066 10                push X
 0067 5000              mov A,0
 0069 7C0000            xcall _TX_REPEATER_14_PutChar
 006C 20                pop X
 006D                   .dbline 154
 006D           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 006D 10                push X
 006E 5000              mov A,0
 0070 7C0000            xcall _TX_REPEATER_23_PutChar
 0073 20                pop X
 0074                   .dbline 155
 0074           ;       TX_REPEATER_14_PutChar(module_id);                      // Destination ID
 0074 62D000            mov REG[0xd0],>__r0
 0077 52FC              mov A,[X-4]
 0079 10                push X
 007A 7C0000            xcall _TX_REPEATER_14_PutChar
 007D 20                pop X
 007E                   .dbline 156
 007E           ;       TX_REPEATER_23_PutChar(module_id);                      // Destination ID
 007E 62D000            mov REG[0xd0],>__r0
 0081 52FC              mov A,[X-4]
 0083 10                push X
 0084 7C0000            xcall _TX_REPEATER_23_PutChar
 0087 20                pop X
 0088                   .dbline 157
 0088           ;       TX_REPEATER_14_PutChar(PING);                           // This is a ping response
 0088 10                push X
 0089 50CB              mov A,-53
 008B 7C0000            xcall _TX_REPEATER_14_PutChar
 008E 20                pop X
 008F                   .dbline 158
 008F           ;       TX_REPEATER_23_PutChar(PING);                           // This is a ping response
 008F 10                push X
 0090 50CB              mov A,-53
 0092 7C0000            xcall _TX_REPEATER_23_PutChar
 0095 20                pop X
 0096                   .dbline 159
 0096           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 0096 10                push X
 0097 50FD              mov A,-3
 0099 7C0000            xcall _TX_REPEATER_14_PutChar
 009C 20                pop X
 009D                   .dbline 160
 009D           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 009D 10                push X
 009E 50FD              mov A,-3
 00A0 7C0000            xcall _TX_REPEATER_23_PutChar
 00A3 20                pop X
 00A4                   .dbline 161
 00A4           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 00A4 10                push X
 00A5 50FD              mov A,-3
 00A7 7C0000            xcall _TX_REPEATER_14_PutChar
 00AA 20                pop X
 00AB                   .dbline 162
 00AB           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 00AB 10                push X
 00AC 50FD              mov A,-3
 00AE 7C0000            xcall _TX_REPEATER_23_PutChar
 00B1 20                pop X
 00B2           L10:
 00B2                   .dbline 165
 00B2           ;       
 00B2           ;       // Wait for the transmission to finish.
 00B2           ;       while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
 00B2           L11:
 00B2                   .dbline 165
 00B2 10                push X
 00B3 7C0000            xcall _TX_REPEATER_14_bReadTxStatus
 00B6 62D000            mov REG[0xd0],>__r0
 00B9 20                pop X
 00BA 5300              mov [__r0],A
 00BC 470020            tst [__r0],32
 00BF AFF2              jz L10
 00C1           L13:
 00C1                   .dbline 166
 00C1           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 00C1           L14:
 00C1                   .dbline 166
 00C1 10                push X
 00C2 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 00C5 62D000            mov REG[0xd0],>__r0
 00C8 20                pop X
 00C9 5300              mov [__r0],A
 00CB 470020            tst [__r0],32
 00CE AFF2              jz L13
 00D0                   .dbline 169
 00D0           ;       
 00D0           ;       // Make completely sure we're done.
 00D0           ;       xmitWait();
 00D0 7C1028            xcall _xmitWait
 00D3                   .dbline 172
 00D3           ;       
 00D3           ;       // Switch to listening mode.
 00D3           ;       configToggle(RX_MODE);
 00D3 5000              mov A,0
 00D5 08                push A
 00D6 5002              mov A,2
 00D8 08                push A
 00D9 7C0C25            xcall _configToggle
 00DC 38FE              add SP,-2
 00DE 8041              xjmp L17
 00E0           L16:
 00E0                   .dbline 176
 00E0           ;       
 00E0           ;       // Listen for the response.
 00E0           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 00E0           ;       {
 00E0                   .dbline 177
 00E0           ;               if(validTransmission())
 00E0 9219              xcall _validTransmission
 00E2 62D000            mov REG[0xd0],>__r0
 00E5 3C0000            cmp [__r0],0
 00E8 B006              jnz X2
 00EA 3C0000            cmp [__r1],0
 00ED A032              jz L19
 00EF           X2:
 00EF                   .dbline 178
 00EF           ;               {
 00EF                   .dbline 180
 00EF           ;                       // If the response is what we are looking for.
 00EF           ;                       if(COMMAND_TYPE == PING)
 00EF 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00F2 3C00CB            cmp [_COMMAND_TYPE],-53
 00F5 B02A              jnz L21
 00F7                   .dbline 181
 00F7           ;                       {
 00F7                   .dbline 183
 00F7           ;                               // If this is for me, check who it was from.
 00F7           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 00F7 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00FA 3C0000            cmp [_COMMAND_DESTINATION],0
 00FD B022              jnz L23
 00FF                   .dbline 184
 00FF           ;                               {
 00FF                   .dbline 186
 00FF           ;                                       // If it's from the right module, return 1.
 00FF           ;                                       if(COMMAND_SOURCE == module_id)
 00FF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0102 5100              mov A,[_COMMAND_SOURCE]
 0104 62D000            mov REG[0xd0],>__r0
 0107 5300              mov [__r1],A
 0109 5000              mov A,0
 010B 3BFB              cmp A,[X-5]
 010D B012              jnz L25
 010F 5100              mov A,[__r1]
 0111 3BFC              cmp A,[X-4]
 0113 B00C              jnz L25
 0115           X3:
 0115                   .dbline 187
 0115           ;                                       {
 0115                   .dbline 188
 0115           ;                                               return 1;
 0115 62D000            mov REG[0xd0],>__r0
 0118 550001            mov [__r1],1
 011B 550000            mov [__r0],0
 011E 8027              xjmp L9
 0120           L25:
 0120                   .dbline 190
 0120           ;                                       }
 0120           ;                               }
 0120           L23:
 0120                   .dbline 191
 0120           ;                       }
 0120           L21:
 0120                   .dbline 192
 0120           ;               }
 0120           L19:
 0120                   .dbline 193
 0120           ;       }
 0120           L17:
 0120                   .dbline 175
 0120 62D000            mov REG[0xd0],>_TIMEOUT
 0123 5101              mov A,[_TIMEOUT+1]
 0125 1105              sub A,5
 0127 5100              mov A,[_TIMEOUT]
 0129 3180              xor A,-128
 012B 1980              sbb A,(0 ^ 0x80)
 012D CFB2              jc L16
 012F           X4:
 012F                   .dbline 195
 012F           ; 
 012F           ;       RX_TIMEOUT_Stop();
 012F 10                push X
 0130 7C0000            xcall _RX_TIMEOUT_Stop
 0133 20                pop X
 0134                   .dbline 196
 0134           ;       TIMEOUT = 0;
 0134 62D000            mov REG[0xd0],>_TIMEOUT
 0137 550100            mov [_TIMEOUT+1],0
 013A 550000            mov [_TIMEOUT],0
 013D                   .dbline 198
 013D           ;       
 013D           ;       return 0;
 013D 62D000            mov REG[0xd0],>__r0
 0140 550000            mov [__r1],0
 0143 550000            mov [__r0],0
 0146                   .dbline -2
 0146           L9:
 0146 20                pop X
 0147                   .dbline 0 ; func end
 0147 7F                ret
 0148                   .dbsym l module_id -5 I
 0148                   .dbend
 0148                   .dbfunc e assignID _assignID fI
 0148           ;    assigned_ID -> X-5
 0148           _assignID::
 0148                   .dbline -1
 0148 10                push X
 0149 4F                mov X,SP
 014A                   .dbline 202
 014A           ; }
 014A           ; 
 014A           ; int assignID(int assigned_ID)
 014A           ; {     
 014A                   .dbline 204
 014A           ;       // Switch to PC mode.
 014A           ;       configToggle(PC_MODE);
 014A 5000              mov A,0
 014C 08                push A
 014D 5001              mov A,1
 014F 08                push A
 0150 7C0C25            xcall _configToggle
 0153 38FE              add SP,-2
 0155                   .dbline 207
 0155           ; 
 0155           ;       // Transmit an ID assignment.
 0155           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte one
 0155 10                push X
 0156 50FC              mov A,-4
 0158 7C0000            xcall _TX_REPEATER_14_PutChar
 015B 20                pop X
 015C                   .dbline 208
 015C           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 015C 10                push X
 015D 50FC              mov A,-4
 015F 7C0000            xcall _TX_REPEATER_23_PutChar
 0162 20                pop X
 0163                   .dbline 209
 0163           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte two
 0163 10                push X
 0164 50FC              mov A,-4
 0166 7C0000            xcall _TX_REPEATER_14_PutChar
 0169 20                pop X
 016A                   .dbline 210
 016A           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 016A 10                push X
 016B 50FC              mov A,-4
 016D 7C0000            xcall _TX_REPEATER_23_PutChar
 0170 20                pop X
 0171                   .dbline 211
 0171           ;       TX_REPEATER_14_PutChar(PARENT_ID);                      // My ID
 0171 10                push X
 0172 5000              mov A,0
 0174 7C0000            xcall _TX_REPEATER_14_PutChar
 0177 20                pop X
 0178                   .dbline 212
 0178           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 0178 10                push X
 0179 5000              mov A,0
 017B 7C0000            xcall _TX_REPEATER_23_PutChar
 017E 20                pop X
 017F                   .dbline 213
 017F           ;       TX_REPEATER_14_PutChar(BLANK_MODULE_ID);        // Destination ID
 017F 10                push X
 0180 50FB              mov A,-5
 0182 7C0000            xcall _TX_REPEATER_14_PutChar
 0185 20                pop X
 0186                   .dbline 214
 0186           ;       TX_REPEATER_23_PutChar(BLANK_MODULE_ID);        // Destination ID
 0186 10                push X
 0187 50FB              mov A,-5
 0189 7C0000            xcall _TX_REPEATER_23_PutChar
 018C 20                pop X
 018D                   .dbline 215
 018D           ;       TX_REPEATER_14_PutChar(ID_ASSIGNMENT);          // This is an ID assignment
 018D 10                push X
 018E 50C9              mov A,-55
 0190 7C0000            xcall _TX_REPEATER_14_PutChar
 0193 20                pop X
 0194                   .dbline 216
 0194           ;       TX_REPEATER_23_PutChar(ID_ASSIGNMENT);          // This is an ID assignment
 0194 10                push X
 0195 50C9              mov A,-55
 0197 7C0000            xcall _TX_REPEATER_23_PutChar
 019A 20                pop X
 019B                   .dbline 217
 019B           ;       TX_REPEATER_14_PutChar(assigned_ID);            // This is the new ID
 019B 62D000            mov REG[0xd0],>__r0
 019E 52FC              mov A,[X-4]
 01A0 10                push X
 01A1 7C0000            xcall _TX_REPEATER_14_PutChar
 01A4 20                pop X
 01A5                   .dbline 218
 01A5           ;       TX_REPEATER_23_PutChar(assigned_ID);            // This is the new ID
 01A5 62D000            mov REG[0xd0],>__r0
 01A8 52FC              mov A,[X-4]
 01AA 10                push X
 01AB 7C0000            xcall _TX_REPEATER_23_PutChar
 01AE 20                pop X
 01AF                   .dbline 219
 01AF           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01AF 10                push X
 01B0 50FD              mov A,-3
 01B2 7C0000            xcall _TX_REPEATER_14_PutChar
 01B5 20                pop X
 01B6                   .dbline 220
 01B6           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01B6 10                push X
 01B7 50FD              mov A,-3
 01B9 7C0000            xcall _TX_REPEATER_23_PutChar
 01BC 20                pop X
 01BD                   .dbline 221
 01BD           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01BD 10                push X
 01BE 50FD              mov A,-3
 01C0 7C0000            xcall _TX_REPEATER_14_PutChar
 01C3 20                pop X
 01C4                   .dbline 222
 01C4           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01C4 10                push X
 01C5 50FD              mov A,-3
 01C7 7C0000            xcall _TX_REPEATER_23_PutChar
 01CA 20                pop X
 01CB           L28:
 01CB                   .dbline 225
 01CB           ;       
 01CB           ;       // Wait for the transmission to finish.
 01CB           ;       while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
 01CB           L29:
 01CB                   .dbline 225
 01CB 10                push X
 01CC 7C0000            xcall _TX_REPEATER_14_bReadTxStatus
 01CF 62D000            mov REG[0xd0],>__r0
 01D2 20                pop X
 01D3 5300              mov [__r0],A
 01D5 470020            tst [__r0],32
 01D8 AFF2              jz L28
 01DA           L31:
 01DA                   .dbline 226
 01DA           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 01DA           L32:
 01DA                   .dbline 226
 01DA 10                push X
 01DB 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 01DE 62D000            mov REG[0xd0],>__r0
 01E1 20                pop X
 01E2 5300              mov [__r0],A
 01E4 470020            tst [__r0],32
 01E7 AFF2              jz L31
 01E9                   .dbline 229
 01E9           ;       
 01E9           ;       // Make completely sure we're done.
 01E9           ;       xmitWait();
 01E9 7C1028            xcall _xmitWait
 01EC                   .dbline 232
 01EC           ;       
 01EC           ;       // Switch to listening mode.
 01EC           ;       configToggle(RX_MODE);
 01EC 5000              mov A,0
 01EE 08                push A
 01EF 5002              mov A,2
 01F1 08                push A
 01F2 7C0C25            xcall _configToggle
 01F5 38FE              add SP,-2
 01F7 8041              xjmp L35
 01F9           L34:
 01F9                   .dbline 236
 01F9           ;       
 01F9           ;       // Listen for the response.
 01F9           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 01F9           ;       {
 01F9                   .dbline 237
 01F9           ;               if(validTransmission())
 01F9 9100              xcall _validTransmission
 01FB 62D000            mov REG[0xd0],>__r0
 01FE 3C0000            cmp [__r0],0
 0201 B006              jnz X5
 0203 3C0000            cmp [__r1],0
 0206 A032              jz L37
 0208           X5:
 0208                   .dbline 238
 0208           ;               {
 0208                   .dbline 240
 0208           ;                       // If this is the response we are looking for.
 0208           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)
 0208 62D000            mov REG[0xd0],>_COMMAND_TYPE
 020B 3C00CA            cmp [_COMMAND_TYPE],-54
 020E B02A              jnz L39
 0210                   .dbline 241
 0210           ;                       {
 0210                   .dbline 243
 0210           ;                               // If this is for me, check who it was from.
 0210           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 0210 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0213 3C0000            cmp [_COMMAND_DESTINATION],0
 0216 B022              jnz L41
 0218                   .dbline 244
 0218           ;                               {
 0218                   .dbline 246
 0218           ;                                       // If it is from the right module, return 1.
 0218           ;                                       if(COMMAND_SOURCE == assigned_ID)
 0218 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 021B 5100              mov A,[_COMMAND_SOURCE]
 021D 62D000            mov REG[0xd0],>__r0
 0220 5300              mov [__r1],A
 0222 5000              mov A,0
 0224 3BFB              cmp A,[X-5]
 0226 B012              jnz L43
 0228 5100              mov A,[__r1]
 022A 3BFC              cmp A,[X-4]
 022C B00C              jnz L43
 022E           X6:
 022E                   .dbline 247
 022E           ;                                       {
 022E                   .dbline 248
 022E           ;                                               return 1;
 022E 62D000            mov REG[0xd0],>__r0
 0231 550001            mov [__r1],1
 0234 550000            mov [__r0],0
 0237 8027              xjmp L27
 0239           L43:
 0239                   .dbline 250
 0239           ;                                       }
 0239           ;                               }
 0239           L41:
 0239                   .dbline 251
 0239           ;                       }
 0239           L39:
 0239                   .dbline 252
 0239           ;               }
 0239           L37:
 0239                   .dbline 253
 0239           ;       }
 0239           L35:
 0239                   .dbline 235
 0239 62D000            mov REG[0xd0],>_TIMEOUT
 023C 5101              mov A,[_TIMEOUT+1]
 023E 1105              sub A,5
 0240 5100              mov A,[_TIMEOUT]
 0242 3180              xor A,-128
 0244 1980              sbb A,(0 ^ 0x80)
 0246 CFB2              jc L34
 0248           X7:
 0248                   .dbline 255
 0248           ;       
 0248           ;       RX_TIMEOUT_Stop();
 0248 10                push X
 0249 7C0000            xcall _RX_TIMEOUT_Stop
 024C 20                pop X
 024D                   .dbline 256
 024D           ;       TIMEOUT = 0;
 024D 62D000            mov REG[0xd0],>_TIMEOUT
 0250 550100            mov [_TIMEOUT+1],0
 0253 550000            mov [_TIMEOUT],0
 0256                   .dbline 258
 0256           ;       
 0256           ;       return 0;
 0256 62D000            mov REG[0xd0],>__r0
 0259 550000            mov [__r1],0
 025C 550000            mov [__r0],0
 025F                   .dbline -2
 025F           L27:
 025F 20                pop X
 0260                   .dbline 0 ; func end
 0260 7F                ret
 0261                   .dbsym l assigned_ID -5 I
 0261                   .dbend
 0261                   .dbfunc e sayHello _sayHello fV
 0261           _sayHello::
 0261                   .dbline -1
 0261                   .dbline 263
 0261           ; }
 0261           ; 
 0261           ; // This function transmits a hello message.
 0261           ; void sayHello(void)
 0261           ; {
 0261                   .dbline 265
 0261           ;       // Toggle into PC mode.
 0261           ;       configToggle(PC_MODE);
 0261 5000              mov A,0
 0263 08                push A
 0264 5001              mov A,1
 0266 08                push A
 0267 7C0C25            xcall _configToggle
 026A 38FE              add SP,-2
 026C                   .dbline 268
 026C           ;       
 026C           ;       // Transmit an ID assignment.
 026C           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte one
 026C 10                push X
 026D 50FC              mov A,-4
 026F 7C0000            xcall _TX_REPEATER_14_PutChar
 0272 20                pop X
 0273                   .dbline 269
 0273           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 0273 10                push X
 0274 50FC              mov A,-4
 0276 7C0000            xcall _TX_REPEATER_23_PutChar
 0279 20                pop X
 027A                   .dbline 270
 027A           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte two
 027A 10                push X
 027B 50FC              mov A,-4
 027D 7C0000            xcall _TX_REPEATER_14_PutChar
 0280 20                pop X
 0281                   .dbline 271
 0281           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 0281 10                push X
 0282 50FC              mov A,-4
 0284 7C0000            xcall _TX_REPEATER_23_PutChar
 0287 20                pop X
 0288                   .dbline 272
 0288           ;       TX_REPEATER_14_PutChar(PARENT_ID);                      // My ID
 0288 10                push X
 0289 5000              mov A,0
 028B 7C0000            xcall _TX_REPEATER_14_PutChar
 028E 20                pop X
 028F                   .dbline 273
 028F           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 028F 10                push X
 0290 5000              mov A,0
 0292 7C0000            xcall _TX_REPEATER_23_PutChar
 0295 20                pop X
 0296                   .dbline 274
 0296           ;       TX_REPEATER_14_PutChar(BLANK_MODULE_ID);        // Destination ID
 0296 10                push X
 0297 50FB              mov A,-5
 0299 7C0000            xcall _TX_REPEATER_14_PutChar
 029C 20                pop X
 029D                   .dbline 275
 029D           ;       TX_REPEATER_23_PutChar(BLANK_MODULE_ID);        // Destination ID
 029D 10                push X
 029E 50FB              mov A,-5
 02A0 7C0000            xcall _TX_REPEATER_23_PutChar
 02A3 20                pop X
 02A4                   .dbline 276
 02A4           ;       TX_REPEATER_14_PutChar(HELLO_BYTE);             // This is a hello message
 02A4 10                push X
 02A5 50C8              mov A,-56
 02A7 7C0000            xcall _TX_REPEATER_14_PutChar
 02AA 20                pop X
 02AB                   .dbline 277
 02AB           ;       TX_REPEATER_23_PutChar(HELLO_BYTE);                     // This is a hello message
 02AB 10                push X
 02AC 50C8              mov A,-56
 02AE 7C0000            xcall _TX_REPEATER_23_PutChar
 02B1 20                pop X
 02B2                   .dbline 278
 02B2           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 02B2 10                push X
 02B3 50FD              mov A,-3
 02B5 7C0000            xcall _TX_REPEATER_14_PutChar
 02B8 20                pop X
 02B9                   .dbline 279
 02B9           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 02B9 10                push X
 02BA 50FD              mov A,-3
 02BC 7C0000            xcall _TX_REPEATER_23_PutChar
 02BF 20                pop X
 02C0                   .dbline 280
 02C0           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 02C0 10                push X
 02C1 50FD              mov A,-3
 02C3 7C0000            xcall _TX_REPEATER_14_PutChar
 02C6 20                pop X
 02C7                   .dbline 281
 02C7           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 02C7 10                push X
 02C8 50FD              mov A,-3
 02CA 7C0000            xcall _TX_REPEATER_23_PutChar
 02CD 20                pop X
 02CE           L46:
 02CE                   .dbline 284
 02CE           ;       
 02CE           ;       // Wait for the transmission to finish.
 02CE           ;       while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
 02CE           L47:
 02CE                   .dbline 284
 02CE 10                push X
 02CF 7C0000            xcall _TX_REPEATER_14_bReadTxStatus
 02D2 62D000            mov REG[0xd0],>__r0
 02D5 20                pop X
 02D6 5300              mov [__r0],A
 02D8 470020            tst [__r0],32
 02DB AFF2              jz L46
 02DD           L49:
 02DD                   .dbline 285
 02DD           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 02DD           L50:
 02DD                   .dbline 285
 02DD 10                push X
 02DE 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 02E1 62D000            mov REG[0xd0],>__r0
 02E4 20                pop X
 02E5 5300              mov [__r0],A
 02E7 470020            tst [__r0],32
 02EA AFF2              jz L49
 02EC                   .dbline 288
 02EC           ;       
 02EC           ;       // Make completely sure we're done.
 02EC           ;       xmitWait();
 02EC 7C1028            xcall _xmitWait
 02EF                   .dbline 291
 02EF           ;       
 02EF           ;       // Switch back to listening mode.
 02EF           ;       configToggle(RX_MODE);
 02EF 5000              mov A,0
 02F1 08                push A
 02F2 5002              mov A,2
 02F4 08                push A
 02F5 7C0C25            xcall _configToggle
 02F8 38FE              add SP,-2
 02FA                   .dbline -2
 02FA           L45:
 02FA                   .dbline 0 ; func end
 02FA 7F                ret
 02FB                   .dbend
 02FB                   .dbfunc e validTransmission _validTransmission fI
 02FB           ;              i -> X+1
 02FB           ;       tempByte -> X+0
 02FB           _validTransmission::
 02FB                   .dbline -1
 02FB 10                push X
 02FC 4F                mov X,SP
 02FD 3803              add SP,3
 02FF                   .dbline 296
 02FF           ; }
 02FF           ; 
 02FF           ; // This function returns whether or not a valid transmission has been received.
 02FF           ; int validTransmission(void)
 02FF           ; {
 02FF                   .dbline 297
 02FF           ;       int i = 0;                      // Index for looping.
 02FF 560200            mov [X+2],0
 0302 560100            mov [X+1],0
 0305                   .dbline 298
 0305           ;       char tempByte = 0;      // Temporary byte storage.
 0305 560000            mov [X+0],0
 0308 809E              xjmp L54
 030A           L53:
 030A                   .dbline 303
 030A           ;       
 030A           ;       // These loops and conditionals are arranged in a way that allows this read
 030A           ;       // operation to be completely non-blocking.
 030A           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 030A           ;       {
 030A                   .dbline 305
 030A           ;               // Wait until we read a start transmit byte.
 030A           ;               if(iReadChar() == START_TRANSMIT)
 030A 7C0F8C            xcall _iReadChar
 030D 62D000            mov REG[0xd0],>__r0
 0310 39FC              cmp A,-4
 0312 B094              jnz L56
 0314                   .dbline 306
 0314           ;               {
 0314 8083              xjmp L59
 0316           L58:
 0316                   .dbline 309
 0316           ;                       // While we haven't timed out, look for something other than a start byte.
 0316           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0316           ;                       {
 0316                   .dbline 311
 0316           ;                               // If we find a nonzero byte...
 0316           ;                               if(tempByte = iReadChar())
 0316 7C0F8C            xcall _iReadChar
 0319 5400              mov [X+0],A
 031B 3900              cmp A,0
 031D A07A              jz L61
 031F                   .dbline 312
 031F           ;                               {
 031F                   .dbline 314
 031F           ;                                       // If the byte we found isn't a start byte...
 031F           ;                                       if(tempByte != START_TRANSMIT)
 031F 3D00FC            cmp [X+0],-4
 0322 A075              jz L63
 0324                   .dbline 315
 0324           ;                                       {
 0324                   .dbline 317
 0324           ;                                               // This byte is probably the command source.
 0324           ;                                               COMMAND_SOURCE = tempByte;
 0324 5200              mov A,[X+0]
 0326 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0329 5300              mov [_COMMAND_SOURCE],A
 032B 805D              xjmp L66
 032D           L65:
 032D                   .dbline 321
 032D           ;                                               
 032D           ;                                               // Look for the rest of the command before we time out.
 032D           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 032D           ;                                               {
 032D                   .dbline 323
 032D           ;                                                       // If we read another nonzero byte...
 032D           ;                                                       if(tempByte = iReadChar())
 032D 7C0F8C            xcall _iReadChar
 0330 62D000            mov REG[0xd0],>__r0
 0333 5400              mov [X+0],A
 0335 3900              cmp A,0
 0337 A051              jz L68
 0339                   .dbline 324
 0339           ;                                                       {
 0339                   .dbline 326
 0339           ;                                                               // If that byte is in the command type indicator space...
 0339           ;                                                               if(tempByte >= COMMAND_TYPE_SPACE)
 0339 3D00C8            cmp [X+0],-56
 033C C04C              jc L70
 033E           X8:
 033E                   .dbline 327
 033E           ;                                                               {
 033E                   .dbline 329
 033E           ;                                                                       // Store the command type.
 033E           ;                                                                       COMMAND_TYPE = tempByte;
 033E 5200              mov A,[X+0]
 0340 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0343 5300              mov [_COMMAND_TYPE],A
 0345 8034              xjmp L73
 0347           L72:
 0347                   .dbline 333
 0347           ;                                                                       
 0347           ;                                                                       // Continue reading if we have not timed out yet.
 0347           ;                                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0347           ;                                                                       {
 0347                   .dbline 335
 0347           ;                                                                               // If we read a nonzero byte...
 0347           ;                                                                               if(tempByte = iReadChar())
 0347 7C0F8C            xcall _iReadChar
 034A 62D000            mov REG[0xd0],>__r0
 034D 5400              mov [X+0],A
 034F 3900              cmp A,0
 0351 A028              jz L75
 0353                   .dbline 336
 0353           ;                                                                               {
 0353                   .dbline 338
 0353           ;                                                                                       // Store the parameter if it is not the end indicator.
 0353           ;                                                                                       if(tempByte != END_TRANSMIT)
 0353 3D00FD            cmp [X+0],-3
 0356 A018              jz L77
 0358                   .dbline 339
 0358           ;                                                                                       {
 0358                   .dbline 340
 0358           ;                                                                                               PARAM[i] = tempByte;
 0358 5202              mov A,[X+2]
 035A 0100              add A,<_PARAM
 035C 5300              mov [__r1],A
 035E 5201              mov A,[X+1]
 0360 0900              adc A,>_PARAM
 0362 60D5              mov REG[0xd5],A
 0364 5200              mov A,[X+0]
 0366 3F00              mvi [__r1],A
 0368                   .dbline 341
 0368           ;                                                                                               i++;
 0368 7702              inc [X+2]
 036A 0F0100            adc [X+1],0
 036D                   .dbline 342
 036D           ;                                                                                       }
 036D 800C              xjmp L78
 036F           L77:
 036F                   .dbline 344
 036F           ;                                                                                       else
 036F           ;                                                                                       {
 036F                   .dbline 345
 036F           ;                                                                                               return 1;
 036F 62D000            mov REG[0xd0],>__r0
 0372 550001            mov [__r1],1
 0375 550000            mov [__r0],0
 0378 8046              xjmp L52
 037A           L78:
 037A                   .dbline 347
 037A           ;                                                                                       }
 037A           ;                                                                               }
 037A           L75:
 037A                   .dbline 348
 037A           ;                                                                       }
 037A           L73:
 037A                   .dbline 332
 037A 62D000            mov REG[0xd0],>_TIMEOUT
 037D 5101              mov A,[_TIMEOUT+1]
 037F 1105              sub A,5
 0381 5100              mov A,[_TIMEOUT]
 0383 3180              xor A,-128
 0385 1980              sbb A,(0 ^ 0x80)
 0387 CFBF              jc L72
 0389           X9:
 0389                   .dbline 349
 0389           ;                                                               }
 0389           L70:
 0389                   .dbline 350
 0389           ;                                                       }
 0389           L68:
 0389                   .dbline 351
 0389           ;                                               }
 0389           L66:
 0389                   .dbline 320
 0389 62D000            mov REG[0xd0],>_TIMEOUT
 038C 5101              mov A,[_TIMEOUT+1]
 038E 1105              sub A,5
 0390 5100              mov A,[_TIMEOUT]
 0392 3180              xor A,-128
 0394 1980              sbb A,(0 ^ 0x80)
 0396 CF96              jc L65
 0398           X10:
 0398                   .dbline 352
 0398           ;                                       }
 0398           L63:
 0398                   .dbline 353
 0398           ;                               }
 0398           L61:
 0398                   .dbline 354
 0398           ;                       }
 0398           L59:
 0398                   .dbline 308
 0398 62D000            mov REG[0xd0],>_TIMEOUT
 039B 5101              mov A,[_TIMEOUT+1]
 039D 1105              sub A,5
 039F 5100              mov A,[_TIMEOUT]
 03A1 3180              xor A,-128
 03A3 1980              sbb A,(0 ^ 0x80)
 03A5 CF70              jc L58
 03A7           X11:
 03A7                   .dbline 355
 03A7           ;               }
 03A7           L56:
 03A7                   .dbline 356
 03A7           ;       }
 03A7           L54:
 03A7                   .dbline 302
 03A7 62D000            mov REG[0xd0],>_TIMEOUT
 03AA 5101              mov A,[_TIMEOUT+1]
 03AC 1105              sub A,5
 03AE 5100              mov A,[_TIMEOUT]
 03B0 3180              xor A,-128
 03B2 1980              sbb A,(0 ^ 0x80)
 03B4 CF55              jc L53
 03B6           X12:
 03B6                   .dbline 358
 03B6           ;       
 03B6           ;       return 0;
 03B6 62D000            mov REG[0xd0],>__r0
 03B9 550000            mov [__r1],0
 03BC 550000            mov [__r0],0
 03BF                   .dbline -2
 03BF           L52:
 03BF 38FD              add SP,-3
 03C1 20                pop X
 03C2                   .dbline 0 ; func end
 03C2 7F                ret
 03C3                   .dbsym l i 1 I
 03C3                   .dbsym l tempByte 0 c
 03C3                   .dbend
 03C3                   .dbfunc e decodeTransmission _decodeTransmission fV
 03C3           ;          speed -> X+10
 03C3           ;          angle -> X+8
 03C3           ;          total -> X+6
 03C3           ;             ID -> X+5
 03C3           ;   runningTotal -> X+3
 03C3           ;       tempByte -> X+2
 03C3           ;          param -> X+0
 03C3           _decodeTransmission::
 03C3                   .dbline -1
 03C3 10                push X
 03C4 4F                mov X,SP
 03C5 380C              add SP,12
 03C7                   .dbline 363
 03C7           ; }
 03C7           ; 
 03C7           ; // This function decodes the transmission and takes the correct action.
 03C7           ; void decodeTransmission(void)
 03C7           ; {
 03C7                   .dbline 365
 03C7           ;       char* param;                    // Stores the most recent parameter from the buffer.
 03C7           ;       char ID = 0;                    // Stores the target module ID.
 03C7 560500            mov [X+5],0
 03CA                   .dbline 366
 03CA           ;       char tempByte = 0;              // Temporary byte storage.
 03CA 560200            mov [X+2],0
 03CD                   .dbline 369
 03CD           ;       char angle[2];                  // Store the two angle bytes for the servo.
 03CD           ;       char speed[2];                  // Store the two speed bytes for the servo.
 03CD           ;       int total = 0;                  // Used to store the converted total of angle or speed bytes.
 03CD 560700            mov [X+7],0
 03D0 560600            mov [X+6],0
 03D3                   .dbline 370
 03D3           ;       int runningTotal = 0;   // Used as part of the dynamic checksum calculation.
 03D3 560400            mov [X+4],0
 03D6 560300            mov [X+3],0
 03D9                   .dbline 373
 03D9           ;       
 03D9           ;       // Read a parameter from the buffer.
 03D9           ;       if(param = COMP_SERIAL_szGetParam())
 03D9 10                push X
 03DA 7C0000            xcall _COMP_SERIAL_szGetParam
 03DD 62D000            mov REG[0xd0],>__r0
 03E0 5300              mov [__r0],A
 03E2 5A00              mov [__r1],X
 03E4 20                pop X
 03E5 5100              mov A,[__r1]
 03E7 5401              mov [X+1],A
 03E9 5100              mov A,[__r0]
 03EB 5400              mov [X+0],A
 03ED 3C0000            cmp [__r0],0
 03F0 B006              jnz X13
 03F2 3C0000            cmp [__r1],0
 03F5 A61B              jz L80
 03F7           X13:
 03F7                   .dbline 374
 03F7           ;       {
 03F7                   .dbline 375
 03F7           ;               if((param[0] == 'x') || (param[0] == 'X'))
 03F7 62D000            mov REG[0xd0],>__r0
 03FA 5201              mov A,[X+1]
 03FC 5300              mov [__r1],A
 03FE 5200              mov A,[X+0]
 0400 60D4              mov REG[0xd4],A
 0402 3E00              mvi A,[__r1]
 0404 5300              mov [__r1],A
 0406 550000            mov [__r0],0
 0409 3C0000            cmp [__r0],0
 040C B005              jnz X14
 040E 3978              cmp A,120
 0410 A00E              jz L84
 0412           X14:
 0412 62D000            mov REG[0xd0],>__r0
 0415 3C0000            cmp [__r0],0
 0418 B011              jnz L82
 041A 3C0058            cmp [__r1],88
 041D B00C              jnz L82
 041F           X15:
 041F           L84:
 041F                   .dbline 376
 041F           ;               {
 041F                   .dbline 378
 041F           ;                       // Reset the robot.
 041F           ;                       NUM_MODULES = 0;
 041F 62D000            mov REG[0xd0],>_NUM_MODULES
 0422 550100            mov [_NUM_MODULES+1],0
 0425 550000            mov [_NUM_MODULES],0
 0428                   .dbline 379
 0428           ;               }
 0428 85E8              xjmp L83
 042A           L82:
 042A                   .dbline 380
 042A           ;               else if((param[0] == 'n') || (param[0] == 'N'))
 042A 62D000            mov REG[0xd0],>__r0
 042D 5201              mov A,[X+1]
 042F 5300              mov [__r1],A
 0431 5200              mov A,[X+0]
 0433 60D4              mov REG[0xd4],A
 0435 3E00              mvi A,[__r1]
 0437 5300              mov [__r1],A
 0439 550000            mov [__r0],0
 043C 3C0000            cmp [__r0],0
 043F B005              jnz X16
 0441 396E              cmp A,110
 0443 A00E              jz L87
 0445           X16:
 0445 62D000            mov REG[0xd0],>__r0
 0448 3C0000            cmp [__r0],0
 044B B035              jnz L85
 044D 3C004E            cmp [__r1],78
 0450 B030              jnz L85
 0452           X17:
 0452           L87:
 0452                   .dbline 381
 0452           ;               {
 0452                   .dbline 382
 0452           ;                       itoa(param,NUM_MODULES,10);             // Convert the NUM_MODULES int to a char array.
 0452 5000              mov A,0
 0454 08                push A
 0455 500A              mov A,10
 0457 08                push A
 0458 62D000            mov REG[0xd0],>_NUM_MODULES
 045B 5100              mov A,[_NUM_MODULES]
 045D 08                push A
 045E 5101              mov A,[_NUM_MODULES+1]
 0460 08                push A
 0461 5200              mov A,[X+0]
 0463 08                push A
 0464 5201              mov A,[X+1]
 0466 08                push A
 0467 7C0000            xcall _itoa
 046A 38FA              add SP,-6
 046C                   .dbline 383
 046C           ;                       COMP_SERIAL_PutString(param);   // Send that array out to the PC.
 046C 10                push X
 046D 5200              mov A,[X+0]
 046F 08                push A
 0470 5201              mov A,[X+1]
 0472 5C                mov X,A
 0473 18                pop A
 0474 7C0000            xcall _COMP_SERIAL_PutString
 0477 20                pop X
 0478                   .dbline 384
 0478           ;                       COMP_SERIAL_PutChar('\n');              // End the transmission with the PC.
 0478 10                push X
 0479 500A              mov A,10
 047B 7C0000            xcall _COMP_SERIAL_PutChar
 047E 20                pop X
 047F                   .dbline 385
 047F           ;               }
 047F 8591              xjmp L86
 0481           L85:
 0481                   .dbline 386
 0481           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 0481 62D000            mov REG[0xd0],>__r0
 0484 5201              mov A,[X+1]
 0486 5300              mov [__r1],A
 0488 5200              mov A,[X+0]
 048A 60D4              mov REG[0xd4],A
 048C 3E00              mvi A,[__r1]
 048E 5300              mov [__r1],A
 0490 550000            mov [__r0],0
 0493 3C0000            cmp [__r0],0
 0496 B005              jnz X18
 0498 3977              cmp A,119
 049A A00E              jz L90
 049C           X18:
 049C 62D000            mov REG[0xd0],>__r0
 049F 3C0000            cmp [__r0],0
 04A2 B214              jnz L88
 04A4 3C0057            cmp [__r1],87
 04A7 B20F              jnz L88
 04A9           X19:
 04A9           L90:
 04A9                   .dbline 387
 04A9           ;               {
 04A9                   .dbline 388
 04A9           ;                       if(param = COMP_SERIAL_szGetParam())
 04A9 10                push X
 04AA 7C0000            xcall _COMP_SERIAL_szGetParam
 04AD 62D000            mov REG[0xd0],>__r0
 04B0 5300              mov [__r0],A
 04B2 5A00              mov [__r1],X
 04B4 20                pop X
 04B5 5100              mov A,[__r1]
 04B7 5401              mov [X+1],A
 04B9 5100              mov A,[__r0]
 04BB 5400              mov [X+0],A
 04BD 3C0000            cmp [__r0],0
 04C0 B006              jnz X20
 04C2 3C0000            cmp [__r1],0
 04C5 A54B              jz L89
 04C7           X20:
 04C7                   .dbline 389
 04C7           ;                       {
 04C7                   .dbline 391
 04C7           ;                               // Convert the ID parameter to a char byte.
 04C7           ;                               ID = atoi(param);
 04C7 5200              mov A,[X+0]
 04C9 08                push A
 04CA 5201              mov A,[X+1]
 04CC 08                push A
 04CD 7C0000            xcall _atoi
 04D0 38FE              add SP,-2
 04D2 62D000            mov REG[0xd0],>__r0
 04D5 5100              mov A,[__r1]
 04D7 5405              mov [X+5],A
 04D9                   .dbline 393
 04D9           ;                               
 04D9           ;                               if(param = COMP_SERIAL_szGetParam())
 04D9 10                push X
 04DA 7C0000            xcall _COMP_SERIAL_szGetParam
 04DD 62D000            mov REG[0xd0],>__r0
 04E0 5300              mov [__r0],A
 04E2 5A00              mov [__r1],X
 04E4 20                pop X
 04E5 5100              mov A,[__r1]
 04E7 5401              mov [X+1],A
 04E9 5100              mov A,[__r0]
 04EB 5400              mov [X+0],A
 04ED 3C0000            cmp [__r0],0
 04F0 B006              jnz X21
 04F2 3C0000            cmp [__r1],0
 04F5 A51B              jz L89
 04F7           X21:
 04F7                   .dbline 394
 04F7           ;                               {
 04F7                   .dbline 395
 04F7           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 04F7 62D000            mov REG[0xd0],>__r0
 04FA 5201              mov A,[X+1]
 04FC 5300              mov [__r1],A
 04FE 5200              mov A,[X+0]
 0500 60D4              mov REG[0xd4],A
 0502 3E00              mvi A,[__r1]
 0504 5300              mov [__r1],A
 0506 550000            mov [__r0],0
 0509 3C0000            cmp [__r0],0
 050C B005              jnz X22
 050E 3961              cmp A,97
 0510 A00E              jz L97
 0512           X22:
 0512 62D000            mov REG[0xd0],>__r0
 0515 3C0000            cmp [__r0],0
 0518 B084              jnz L95
 051A 3C0041            cmp [__r1],65
 051D B07F              jnz L95
 051F           X23:
 051F           L97:
 051F                   .dbline 396
 051F           ;                                       {
 051F                   .dbline 397
 051F           ;                                               if(param = COMP_SERIAL_szGetParam())
 051F 10                push X
 0520 7C0000            xcall _COMP_SERIAL_szGetParam
 0523 62D000            mov REG[0xd0],>__r0
 0526 5300              mov [__r0],A
 0528 5A00              mov [__r1],X
 052A 20                pop X
 052B 5100              mov A,[__r1]
 052D 5401              mov [X+1],A
 052F 5100              mov A,[__r0]
 0531 5400              mov [X+0],A
 0533 3C0000            cmp [__r0],0
 0536 B006              jnz X24
 0538 3C0000            cmp [__r1],0
 053B A4D5              jz L89
 053D           X24:
 053D                   .dbline 398
 053D           ;                                               {
 053D                   .dbline 400
 053D           ;                                                       // Get the angle parameter and convert it to an integer.
 053D           ;                                                       total = atoi(param);
 053D 5200              mov A,[X+0]
 053F 08                push A
 0540 5201              mov A,[X+1]
 0542 08                push A
 0543 7C0000            xcall _atoi
 0546 38FE              add SP,-2
 0548 62D000            mov REG[0xd0],>__r0
 054B 5100              mov A,[__r1]
 054D 5407              mov [X+7],A
 054F 5100              mov A,[__r0]
 0551 5406              mov [X+6],A
 0553                   .dbline 403
 0553           ;                                                       
 0553           ;                                                       // Convert the integer into bytes.
 0553           ;                                                       angle[0] = total%256;
 0553 5001              mov A,1
 0555 08                push A
 0556 5000              mov A,0
 0558 08                push A
 0559 5206              mov A,[X+6]
 055B 08                push A
 055C 5207              mov A,[X+7]
 055E 08                push A
 055F 7C0000            xcall __divmod_16X16_16
 0562 38FE              add SP,-2
 0564 18                pop A
 0565 5300              mov [__r1],A
 0567 18                pop A
 0568 5100              mov A,[__r1]
 056A 5408              mov [X+8],A
 056C                   .dbline 404
 056C           ;                                                       angle[1] = total/256;
 056C 5001              mov A,1
 056E 08                push A
 056F 5000              mov A,0
 0571 08                push A
 0572 5206              mov A,[X+6]
 0574 08                push A
 0575 5207              mov A,[X+7]
 0577 08                push A
 0578 7C0000            xcall __divmod_16X16_16
 057B 18                pop A
 057C 5300              mov [__r1],A
 057E 18                pop A
 057F 38FE              add SP,-2
 0581 5100              mov A,[__r1]
 0583 5409              mov [X+9],A
 0585                   .dbline 407
 0585           ;                                                       
 0585           ;                                                       // Send the servo the angle.
 0585           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 0585 5209              mov A,[X+9]
 0587 08                push A
 0588 5208              mov A,[X+8]
 058A 08                push A
 058B 501E              mov A,30
 058D 08                push A
 058E 5003              mov A,3
 0590 08                push A
 0591 5005              mov A,5
 0593 08                push A
 0594 5205              mov A,[X+5]
 0596 08                push A
 0597 958D              xcall _longServoInstruction
 0599 38FA              add SP,-6
 059B                   .dbline 408
 059B           ;                                               }
 059B                   .dbline 409
 059B           ;                                       }
 059B 8475              xjmp L89
 059D           L95:
 059D                   .dbline 410
 059D           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 059D 62D000            mov REG[0xd0],>__r0
 05A0 5201              mov A,[X+1]
 05A2 5300              mov [__r1],A
 05A4 5200              mov A,[X+0]
 05A6 60D4              mov REG[0xd4],A
 05A8 3E00              mvi A,[__r1]
 05AA 5300              mov [__r1],A
 05AC 550000            mov [__r0],0
 05AF 3C0000            cmp [__r0],0
 05B2 B005              jnz X25
 05B4 3970              cmp A,112
 05B6 A00E              jz L104
 05B8           X25:
 05B8 62D000            mov REG[0xd0],>__r0
 05BB 3C0000            cmp [__r0],0
 05BE B045              jnz L102
 05C0 3C0050            cmp [__r1],80
 05C3 B040              jnz L102
 05C5           X26:
 05C5           L104:
 05C5                   .dbline 411
 05C5           ;                                       {
 05C5                   .dbline 412
 05C5           ;                                               if(param = COMP_SERIAL_szGetParam())
 05C5 10                push X
 05C6 7C0000            xcall _COMP_SERIAL_szGetParam
 05C9 62D000            mov REG[0xd0],>__r0
 05CC 5300              mov [__r0],A
 05CE 5A00              mov [__r1],X
 05D0 20                pop X
 05D1 5100              mov A,[__r1]
 05D3 5401              mov [X+1],A
 05D5 5100              mov A,[__r0]
 05D7 5400              mov [X+0],A
 05D9 3C0000            cmp [__r0],0
 05DC B006              jnz X27
 05DE 3C0000            cmp [__r1],0
 05E1 A42F              jz L89
 05E3           X27:
 05E3                   .dbline 413
 05E3           ;                                               {
 05E3                   .dbline 415
 05E3           ;                                                       // Send the servo the desired power value.
 05E3           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 05E3 5200              mov A,[X+0]
 05E5 08                push A
 05E6 5201              mov A,[X+1]
 05E8 08                push A
 05E9 7C0000            xcall _atoi
 05EC 62D000            mov REG[0xd0],>__r0
 05EF 5100              mov A,[__r1]
 05F1 08                push A
 05F2 5018              mov A,24
 05F4 08                push A
 05F5 5003              mov A,3
 05F7 08                push A
 05F8 5004              mov A,4
 05FA 08                push A
 05FB 5205              mov A,[X+5]
 05FD 08                push A
 05FE 943C              xcall _servoInstruction
 0600 38F9              add SP,-7
 0602                   .dbline 416
 0602           ;                                               }
 0602                   .dbline 417
 0602           ;                                       }
 0602 840E              xjmp L89
 0604           L102:
 0604                   .dbline 418
 0604           ;                                       else if((param[0] == 's') || (param[0] == 'S'))
 0604 62D000            mov REG[0xd0],>__r0
 0607 5201              mov A,[X+1]
 0609 5300              mov [__r1],A
 060B 5200              mov A,[X+0]
 060D 60D4              mov REG[0xd4],A
 060F 3E00              mvi A,[__r1]
 0611 5300              mov [__r1],A
 0613 550000            mov [__r0],0
 0616 3C0000            cmp [__r0],0
 0619 B005              jnz X28
 061B 3973              cmp A,115
 061D A00E              jz L109
 061F           X28:
 061F 62D000            mov REG[0xd0],>__r0
 0622 3C0000            cmp [__r0],0
 0625 B3EB              jnz L89
 0627 3C0053            cmp [__r1],83
 062A B3E6              jnz L89
 062C           X29:
 062C           L109:
 062C                   .dbline 419
 062C           ;                                       {
 062C                   .dbline 420
 062C           ;                                               if(param = COMP_SERIAL_szGetParam())
 062C 10                push X
 062D 7C0000            xcall _COMP_SERIAL_szGetParam
 0630 62D000            mov REG[0xd0],>__r0
 0633 5300              mov [__r0],A
 0635 5A00              mov [__r1],X
 0637 20                pop X
 0638 5100              mov A,[__r1]
 063A 5401              mov [X+1],A
 063C 5100              mov A,[__r0]
 063E 5400              mov [X+0],A
 0640 3C0000            cmp [__r0],0
 0643 B006              jnz X30
 0645 3C0000            cmp [__r1],0
 0648 A3C8              jz L89
 064A           X30:
 064A                   .dbline 421
 064A           ;                                               {
 064A                   .dbline 423
 064A           ;                                                       // Get the speed parameter and convert it to an integer.
 064A           ;                                                       total = atoi(param);
 064A 5200              mov A,[X+0]
 064C 08                push A
 064D 5201              mov A,[X+1]
 064F 08                push A
 0650 7C0000            xcall _atoi
 0653 38FE              add SP,-2
 0655 62D000            mov REG[0xd0],>__r0
 0658 5100              mov A,[__r1]
 065A 5407              mov [X+7],A
 065C 5100              mov A,[__r0]
 065E 5406              mov [X+6],A
 0660                   .dbline 426
 0660           ;                                                       
 0660           ;                                                       // If no total, do nothing because 0 is no speed control (undesired).
 0660           ;                                                       if(total)
 0660 3D0600            cmp [X+6],0
 0663 B006              jnz X31
 0665 3D0700            cmp [X+7],0
 0668 A3A8              jz L89
 066A           X31:
 066A                   .dbline 427
 066A           ;                                                       {
 066A                   .dbline 429
 066A           ;                                                               // Convert the integer into bytes.
 066A           ;                                                               speed[0] = total%256;
 066A 62D000            mov REG[0xd0],>__r0
 066D 5001              mov A,1
 066F 08                push A
 0670 5000              mov A,0
 0672 08                push A
 0673 5206              mov A,[X+6]
 0675 08                push A
 0676 5207              mov A,[X+7]
 0678 08                push A
 0679 7C0000            xcall __divmod_16X16_16
 067C 38FE              add SP,-2
 067E 18                pop A
 067F 5300              mov [__r1],A
 0681 18                pop A
 0682 5100              mov A,[__r1]
 0684 540A              mov [X+10],A
 0686                   .dbline 430
 0686           ;                                                               speed[1] = total/256;
 0686 5001              mov A,1
 0688 08                push A
 0689 5000              mov A,0
 068B 08                push A
 068C 5206              mov A,[X+6]
 068E 08                push A
 068F 5207              mov A,[X+7]
 0691 08                push A
 0692 7C0000            xcall __divmod_16X16_16
 0695 18                pop A
 0696 5300              mov [__r1],A
 0698 18                pop A
 0699 38FE              add SP,-2
 069B 5100              mov A,[__r1]
 069D 540B              mov [X+11],A
 069F                   .dbline 433
 069F           ;                                                               
 069F           ;                                                               // Write the speed value to the servo.
 069F           ;                                                               longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
 069F 520B              mov A,[X+11]
 06A1 08                push A
 06A2 520A              mov A,[X+10]
 06A4 08                push A
 06A5 5020              mov A,32
 06A7 08                push A
 06A8 5003              mov A,3
 06AA 08                push A
 06AB 5005              mov A,5
 06AD 08                push A
 06AE 5205              mov A,[X+5]
 06B0 08                push A
 06B1 9473              xcall _longServoInstruction
 06B3 38FA              add SP,-6
 06B5                   .dbline 434
 06B5           ;                                                       }
 06B5                   .dbline 435
 06B5           ;                                               }
 06B5                   .dbline 436
 06B5           ;                                       }
 06B5                   .dbline 437
 06B5           ;                               }
 06B5                   .dbline 438
 06B5           ;                       }
 06B5                   .dbline 439
 06B5           ;               }
 06B5 835B              xjmp L89
 06B7           L88:
 06B7                   .dbline 440
 06B7           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 06B7 62D000            mov REG[0xd0],>__r0
 06BA 5201              mov A,[X+1]
 06BC 5300              mov [__r1],A
 06BE 5200              mov A,[X+0]
 06C0 60D4              mov REG[0xd4],A
 06C2 3E00              mvi A,[__r1]
 06C4 5300              mov [__r1],A
 06C6 550000            mov [__r0],0
 06C9 3C0000            cmp [__r0],0
 06CC B005              jnz X32
 06CE 3972              cmp A,114
 06D0 A00E              jz L118
 06D2           X32:
 06D2 62D000            mov REG[0xd0],>__r0
 06D5 3C0000            cmp [__r0],0
 06D8 B338              jnz L116
 06DA 3C0052            cmp [__r1],82
 06DD B333              jnz L116
 06DF           X33:
 06DF           L118:
 06DF                   .dbline 441
 06DF           ;               {                       
 06DF                   .dbline 442
 06DF           ;                       if(param = COMP_SERIAL_szGetParam())
 06DF 10                push X
 06E0 7C0000            xcall _COMP_SERIAL_szGetParam
 06E3 62D000            mov REG[0xd0],>__r0
 06E6 5300              mov [__r0],A
 06E8 5A00              mov [__r1],X
 06EA 20                pop X
 06EB 5100              mov A,[__r1]
 06ED 5401              mov [X+1],A
 06EF 5100              mov A,[__r0]
 06F1 5400              mov [X+0],A
 06F3 3C0000            cmp [__r0],0
 06F6 B006              jnz X34
 06F8 3C0000            cmp [__r1],0
 06FB A315              jz L119
 06FD           X34:
 06FD                   .dbline 443
 06FD           ;                       {
 06FD                   .dbline 445
 06FD           ;                               // Extract the target ID param and convert it to an integer.
 06FD           ;                               ID = atoi(param);
 06FD 5200              mov A,[X+0]
 06FF 08                push A
 0700 5201              mov A,[X+1]
 0702 08                push A
 0703 7C0000            xcall _atoi
 0706 38FE              add SP,-2
 0708 62D000            mov REG[0xd0],>__r0
 070B 5100              mov A,[__r1]
 070D 5405              mov [X+5],A
 070F                   .dbline 447
 070F           ;                               
 070F           ;                               if(param = COMP_SERIAL_szGetParam())
 070F 10                push X
 0710 7C0000            xcall _COMP_SERIAL_szGetParam
 0713 62D000            mov REG[0xd0],>__r0
 0716 5300              mov [__r0],A
 0718 5A00              mov [__r1],X
 071A 20                pop X
 071B 5100              mov A,[__r1]
 071D 5401              mov [X+1],A
 071F 5100              mov A,[__r0]
 0721 5400              mov [X+0],A
 0723 3C0000            cmp [__r0],0
 0726 B006              jnz X35
 0728 3C0000            cmp [__r1],0
 072B A2E5              jz L121
 072D           X35:
 072D                   .dbline 448
 072D           ;                               {
 072D                   .dbline 449
 072D           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 072D 62D000            mov REG[0xd0],>__r0
 0730 5201              mov A,[X+1]
 0732 5300              mov [__r1],A
 0734 5200              mov A,[X+0]
 0736 60D4              mov REG[0xd4],A
 0738 3E00              mvi A,[__r1]
 073A 5300              mov [__r1],A
 073C 550000            mov [__r0],0
 073F 3C0000            cmp [__r0],0
 0742 B005              jnz X36
 0744 3961              cmp A,97
 0746 A00E              jz L125
 0748           X36:
 0748 62D000            mov REG[0xd0],>__r0
 074B 3C0000            cmp [__r0],0
 074E B0C7              jnz L123
 0750 3C0041            cmp [__r1],65
 0753 B0C2              jnz L123
 0755           X37:
 0755           L125:
 0755                   .dbline 450
 0755           ;                                       {
 0755                   .dbline 452
 0755           ;                                               // Initialize the angle bytes to 0.
 0755           ;                                               angle[0] = 0;
 0755 560800            mov [X+8],0
 0758                   .dbline 453
 0758           ;                                               angle[1] = 0;
 0758 560900            mov [X+9],0
 075B                   .dbline 456
 075B           ;                                               
 075B           ;                                               // Send a request to the servo for its angle.
 075B           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 075B 5002              mov A,2
 075D 08                push A
 075E 5024              mov A,36
 0760 08                push A
 0761 5002              mov A,2
 0763 08                push A
 0764 5004              mov A,4
 0766 08                push A
 0767 5205              mov A,[X+5]
 0769 08                push A
 076A 92D0              xcall _servoInstruction
 076C                   .dbline 459
 076C           ;                                               
 076C           ;                                               // Switch to read the response.
 076C           ;                                               configToggle(RX_MODE);
 076C 5000              mov A,0
 076E 08                push A
 076F 5002              mov A,2
 0771 08                push A
 0772 94B1              xcall _configToggle
 0774 38F9              add SP,-7
 0776 808E              xjmp L128
 0778           L127:
 0778                   .dbline 463
 0778           ;                                                       
 0778           ;                                               // Loop until we read a response or time out.
 0778           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0778           ;                                               {
 0778                   .dbline 465
 0778           ;                                                       // If the response is from the right ID...
 0778           ;                                                       if(iReadChar() == ID)
 0778 7C0F8C            xcall _iReadChar
 077B 62D000            mov REG[0xd0],>__r0
 077E 3B05              cmp A,[X+5]
 0780 B084              jnz L130
 0782                   .dbline 466
 0782           ;                                                       {
 0782 8073              xjmp L133
 0784           L132:
 0784                   .dbline 468
 0784           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0784           ;                                                               {
 0784                   .dbline 470
 0784           ;                                                                       // The length of the response remainder should be 4.
 0784           ;                                                                       if(iReadChar() == 4)
 0784 7C0F8C            xcall _iReadChar
 0787 62D000            mov REG[0xd0],>__r0
 078A 3904              cmp A,4
 078C B069              jnz L135
 078E                   .dbline 471
 078E           ;                                                                       {
 078E                   .dbline 473
 078E           ;                                                                               // The error value should be 0 if successful.
 078E           ;                                                                               if(readChar() == 0)
 078E 7C0FDA            xcall _readChar
 0791 62D000            mov REG[0xd0],>__r0
 0794 3900              cmp A,0
 0796 B056              jnz L137
 0798                   .dbline 474
 0798           ;                                                                               {
 0798                   .dbline 476
 0798           ;                                                                                       // Grab the bytes from the buffer.
 0798           ;                                                                                       angle[0] = readChar();
 0798 7C0FDA            xcall _readChar
 079B 62D000            mov REG[0xd0],>__r0
 079E 5408              mov [X+8],A
 07A0                   .dbline 477
 07A0           ;                                                                                       angle[1] = readChar();
 07A0 7C0FDA            xcall _readChar
 07A3 62D000            mov REG[0xd0],>__r0
 07A6 5409              mov [X+9],A
 07A8                   .dbline 480
 07A8           ;                                                                                       
 07A8           ;                                                                                       // Switch to PC mode to forward the response.
 07A8           ;                                                                                       configToggle(PC_MODE);
 07A8 5000              mov A,0
 07AA 08                push A
 07AB 5001              mov A,1
 07AD 08                push A
 07AE 9475              xcall _configToggle
 07B0                   .dbline 483
 07B0           ;                                                                                       
 07B0           ;                                                                                       // Convert the bytes to an integer.
 07B0           ;                                                                                       total = ((angle[1])*256) + angle[0];
 07B0 5208              mov A,[X+8]
 07B2 5407              mov [X+7],A
 07B4 5209              mov A,[X+9]
 07B6 5406              mov [X+6],A
 07B8                   .dbline 486
 07B8           ;                                                                                       
 07B8           ;                                                                                       // Convert the integer to a character array.
 07B8           ;                                                                                       itoa(param,total,10);
 07B8 5000              mov A,0
 07BA 08                push A
 07BB 500A              mov A,10
 07BD 08                push A
 07BE 5206              mov A,[X+6]
 07C0 08                push A
 07C1 5207              mov A,[X+7]
 07C3 08                push A
 07C4 5200              mov A,[X+0]
 07C6 08                push A
 07C7 5201              mov A,[X+1]
 07C9 08                push A
 07CA 7C0000            xcall _itoa
 07CD 38F8              add SP,-8
 07CF                   .dbline 489
 07CF           ;                                                                                       
 07CF           ;                                                                                       // Write the response to the computer.
 07CF           ;                                                                                       COMP_SERIAL_PutString(param);
 07CF 10                push X
 07D0 5200              mov A,[X+0]
 07D2 08                push A
 07D3 5201              mov A,[X+1]
 07D5 5C                mov X,A
 07D6 18                pop A
 07D7 7C0000            xcall _COMP_SERIAL_PutString
 07DA 20                pop X
 07DB                   .dbline 490
 07DB           ;                                                                                       COMP_SERIAL_PutChar('\n');
 07DB 10                push X
 07DC 500A              mov A,10
 07DE 7C0000            xcall _COMP_SERIAL_PutChar
 07E1 20                pop X
 07E2                   .dbline 493
 07E2           ; 
 07E2           ;                                                                                       // Force a timeout to exit all loops.
 07E2           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 07E2 62D000            mov REG[0xd0],>_TIMEOUT
 07E5 550105            mov [_TIMEOUT+1],5
 07E8 550000            mov [_TIMEOUT],0
 07EB                   .dbline 494
 07EB           ;                                                                               }
 07EB 800A              xjmp L138
 07ED           L137:
 07ED                   .dbline 496
 07ED           ;                                                                               else
 07ED           ;                                                                               {
 07ED                   .dbline 498
 07ED           ;                                                                                       // Force a timeout to exit all loops.
 07ED           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 07ED 62D000            mov REG[0xd0],>_TIMEOUT
 07F0 550105            mov [_TIMEOUT+1],5
 07F3 550000            mov [_TIMEOUT],0
 07F6                   .dbline 499
 07F6           ;                                                                               }
 07F6           L138:
 07F6                   .dbline 500
 07F6           ;                                                                       }
 07F6           L135:
 07F6                   .dbline 501
 07F6           ;                                                               }
 07F6           L133:
 07F6                   .dbline 467
 07F6 62D000            mov REG[0xd0],>_TIMEOUT
 07F9 5101              mov A,[_TIMEOUT+1]
 07FB 1105              sub A,5
 07FD 5100              mov A,[_TIMEOUT]
 07FF 3180              xor A,-128
 0801 1980              sbb A,(0 ^ 0x80)
 0803 CF80              jc L132
 0805           X38:
 0805                   .dbline 502
 0805           ;                                                       }
 0805           L130:
 0805                   .dbline 503
 0805           ;                                               }
 0805           L128:
 0805                   .dbline 462
 0805 62D000            mov REG[0xd0],>_TIMEOUT
 0808 5101              mov A,[_TIMEOUT+1]
 080A 1105              sub A,5
 080C 5100              mov A,[_TIMEOUT]
 080E 3180              xor A,-128
 0810 1980              sbb A,(0 ^ 0x80)
 0812 CF65              jc L127
 0814           X39:
 0814                   .dbline 504
 0814           ;                                       }
 0814 81FC              xjmp L124
 0816           L123:
 0816                   .dbline 505
 0816           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 0816 62D000            mov REG[0xd0],>__r0
 0819 5201              mov A,[X+1]
 081B 5300              mov [__r1],A
 081D 5200              mov A,[X+0]
 081F 60D4              mov REG[0xd4],A
 0821 3E00              mvi A,[__r1]
 0823 5300              mov [__r1],A
 0825 550000            mov [__r0],0
 0828 3C0000            cmp [__r0],0
 082B B005              jnz X40
 082D 3970              cmp A,112
 082F A00E              jz L143
 0831           X40:
 0831 62D000            mov REG[0xd0],>__r0
 0834 3C0000            cmp [__r0],0
 0837 B0E6              jnz L141
 0839 3C0050            cmp [__r1],80
 083C B0E1              jnz L141
 083E           X41:
 083E           L143:
 083E                   .dbline 506
 083E           ;                                       {
 083E                   .dbline 508
 083E           ;                                               // Send a request to the servo for its power status.
 083E           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 083E 5001              mov A,1
 0840 08                push A
 0841 5018              mov A,24
 0843 08                push A
 0844 5002              mov A,2
 0846 08                push A
 0847 5004              mov A,4
 0849 08                push A
 084A 5205              mov A,[X+5]
 084C 08                push A
 084D 91ED              xcall _servoInstruction
 084F                   .dbline 511
 084F           ;                                               
 084F           ;                                               // Switch to read the response.
 084F           ;                                               configToggle(RX_MODE);
 084F 5000              mov A,0
 0851 08                push A
 0852 5002              mov A,2
 0854 08                push A
 0855 93CE              xcall _configToggle
 0857 38F9              add SP,-7
 0859 80B3              xjmp L145
 085B           L144:
 085B                   .dbline 515
 085B           ;                                               
 085B           ;                                               // Loop until we read a response or time out.
 085B           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 085B           ;                                               {
 085B                   .dbline 516
 085B           ;                                                       if(iReadChar() == ID)
 085B 972F              xcall _iReadChar
 085D 62D000            mov REG[0xd0],>__r0
 0860 3B05              cmp A,[X+5]
 0862 B0AA              jnz L147
 0864                   .dbline 517
 0864           ;                                                       {
 0864                   .dbline 518
 0864           ;                                                               runningTotal = ID;
 0864 5205              mov A,[X+5]
 0866 5404              mov [X+4],A
 0868 560300            mov [X+3],0
 086B 8092              xjmp L150
 086D           L149:
 086D                   .dbline 521
 086D           ;                                                               // Loop until we read a response or time out.
 086D           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 086D           ;                                                               {
 086D                   .dbline 523
 086D           ;                                                                       // Check the length of the packet.
 086D           ;                                                                       if(iReadChar() == 3)
 086D 971D              xcall _iReadChar
 086F 62D000            mov REG[0xd0],>__r0
 0872 3903              cmp A,3
 0874 B089              jnz L152
 0876                   .dbline 524
 0876           ;                                                                       {
 0876                   .dbline 526
 0876           ;                                                                               // Tack the value onto our running total.
 0876           ;                                                                               runningTotal += 3;
 0876 070403            add [X+4],3
 0879 0F0300            adc [X+3],0
 087C 8072              xjmp L155
 087E           L154:
 087E                   .dbline 530
 087E           ;                                                                               
 087E           ;                                                                               // Loop until we read a response or time out.
 087E           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 087E           ;                                                                               {
 087E                   .dbline 532
 087E           ;                                                                                       // Check for the checksum or 1.
 087E           ;                                                                                       if(tempByte = iReadChar())
 087E 970C              xcall _iReadChar
 0880 62D000            mov REG[0xd0],>__r0
 0883 5402              mov [X+2],A
 0885 3900              cmp A,0
 0887 A067              jz L157
 0889                   .dbline 533
 0889           ;                                                                                       {
 0889                   .dbline 535
 0889           ;                                                                                               // Switch to PC mode to forward the result.
 0889           ;                                                                                               configToggle(PC_MODE);
 0889 5000              mov A,0
 088B 08                push A
 088C 5001              mov A,1
 088E 08                push A
 088F 9394              xcall _configToggle
 0891 38FE              add SP,-2
 0893                   .dbline 537
 0893           ;                                                                                               
 0893           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 0893 62D000            mov REG[0xd0],>__r0
 0896 5202              mov A,[X+2]
 0898 5300              mov [__r1],A
 089A 550000            mov [__r0],0
 089D 50FF              mov A,-1
 089F 1200              sub A,[__r1]
 08A1 5300              mov [__r1],A
 08A3 5000              mov A,0
 08A5 1A00              sbb A,[__r0]
 08A7 5300              mov [__r0],A
 08A9 5001              mov A,1
 08AB 08                push A
 08AC 5000              mov A,0
 08AE 08                push A
 08AF 5203              mov A,[X+3]
 08B1 08                push A
 08B2 5204              mov A,[X+4]
 08B4 08                push A
 08B5 7C0000            xcall __divmod_16X16_16
 08B8 38FE              add SP,-2
 08BA 18                pop A
 08BB 5300              mov [__r3],A
 08BD 18                pop A
 08BE 3A00              cmp A,[__r0]
 08C0 B017              jnz L159
 08C2 5100              mov A,[__r3]
 08C4 3A00              cmp A,[__r1]
 08C6 B011              jnz L159
 08C8           X42:
 08C8                   .dbline 538
 08C8           ;                                                                                               {
 08C8                   .dbline 540
 08C8           ;                                                                                                       // Send a 0 if we hit the checksum.
 08C8           ;                                                                                                       COMP_SERIAL_PutChar('0');
 08C8 10                push X
 08C9 5030              mov A,48
 08CB 7C0000            xcall _COMP_SERIAL_PutChar
 08CE 20                pop X
 08CF                   .dbline 541
 08CF           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 08CF 10                push X
 08D0 500A              mov A,10
 08D2 7C0000            xcall _COMP_SERIAL_PutChar
 08D5 20                pop X
 08D6                   .dbline 542
 08D6           ;                                                                                               }
 08D6 800F              xjmp L160
 08D8           L159:
 08D8                   .dbline 544
 08D8           ;                                                                                               else
 08D8           ;                                                                                               {
 08D8                   .dbline 546
 08D8           ;                                                                                                       // Send a 1 if we hit it first.
 08D8           ;                                                                                                       COMP_SERIAL_PutChar('1');
 08D8 10                push X
 08D9 5031              mov A,49
 08DB 7C0000            xcall _COMP_SERIAL_PutChar
 08DE 20                pop X
 08DF                   .dbline 547
 08DF           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 08DF 10                push X
 08E0 500A              mov A,10
 08E2 7C0000            xcall _COMP_SERIAL_PutChar
 08E5 20                pop X
 08E6                   .dbline 548
 08E6           ;                                                                                               }
 08E6           L160:
 08E6                   .dbline 550
 08E6           ;               
 08E6           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 08E6 62D000            mov REG[0xd0],>_TIMEOUT
 08E9 550105            mov [_TIMEOUT+1],5
 08EC 550000            mov [_TIMEOUT],0
 08EF                   .dbline 551
 08EF           ;                                                                                       }
 08EF           L157:
 08EF                   .dbline 552
 08EF           ;                                                                               }
 08EF           L155:
 08EF                   .dbline 529
 08EF 62D000            mov REG[0xd0],>_TIMEOUT
 08F2 5101              mov A,[_TIMEOUT+1]
 08F4 1105              sub A,5
 08F6 5100              mov A,[_TIMEOUT]
 08F8 3180              xor A,-128
 08FA 1980              sbb A,(0 ^ 0x80)
 08FC CF81              jc L154
 08FE           X43:
 08FE                   .dbline 553
 08FE           ;                                                                       }
 08FE           L152:
 08FE                   .dbline 554
 08FE           ;                                                               }
 08FE           L150:
 08FE                   .dbline 520
 08FE 62D000            mov REG[0xd0],>_TIMEOUT
 0901 5101              mov A,[_TIMEOUT+1]
 0903 1105              sub A,5
 0905 5100              mov A,[_TIMEOUT]
 0907 3180              xor A,-128
 0909 1980              sbb A,(0 ^ 0x80)
 090B CF61              jc L149
 090D           X44:
 090D                   .dbline 555
 090D           ;                                                       }
 090D           L147:
 090D                   .dbline 556
 090D           ;                                               }
 090D           L145:
 090D                   .dbline 514
 090D 62D000            mov REG[0xd0],>_TIMEOUT
 0910 5101              mov A,[_TIMEOUT+1]
 0912 1105              sub A,5
 0914 5100              mov A,[_TIMEOUT]
 0916 3180              xor A,-128
 0918 1980              sbb A,(0 ^ 0x80)
 091A CF40              jc L144
 091C           X45:
 091C                   .dbline 557
 091C           ;                                       }
 091C 80F4              xjmp L142
 091E           L141:
 091E                   .dbline 558
 091E           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 091E 62D000            mov REG[0xd0],>__r0
 0921 5201              mov A,[X+1]
 0923 5300              mov [__r1],A
 0925 5200              mov A,[X+0]
 0927 60D4              mov REG[0xd4],A
 0929 3E00              mvi A,[__r1]
 092B 5300              mov [__r1],A
 092D 550000            mov [__r0],0
 0930 3C0000            cmp [__r0],0
 0933 B005              jnz X46
 0935 3974              cmp A,116
 0937 A00E              jz L163
 0939           X46:
 0939 62D000            mov REG[0xd0],>__r0
 093C 3C0000            cmp [__r0],0
 093F B057              jnz L161
 0941 3C0054            cmp [__r1],84
 0944 B052              jnz L161
 0946           X47:
 0946           L163:
 0946                   .dbline 559
 0946           ;                                       {
 0946                   .dbline 562
 0946           ;                                               // If this isn't for the parent, ping the module to get a
 0946           ;                                               // status packet and return the data.
 0946           ;                                               if(ID == 0)
 0946 3D0500            cmp [X+5],0
 0949 B011              jnz L164
 094B                   .dbline 563
 094B           ;                                               {
 094B                   .dbline 564
 094B           ;                                                       COMP_SERIAL_PutChar(TYPE);
 094B 10                push X
 094C 5032              mov A,50
 094E 7C0000            xcall _COMP_SERIAL_PutChar
 0951 20                pop X
 0952                   .dbline 565
 0952           ;                                                       COMP_SERIAL_PutChar('\n');
 0952 10                push X
 0953 500A              mov A,10
 0955 7C0000            xcall _COMP_SERIAL_PutChar
 0958 20                pop X
 0959                   .dbline 566
 0959           ;                                               }
 0959 80B7              xjmp L162
 095B           L164:
 095B                   .dbline 567
 095B           ;                                               else if(pingModule(ID))
 095B 62D000            mov REG[0xd0],>__r0
 095E 5205              mov A,[X+5]
 0960 5300              mov [__r1],A
 0962 5000              mov A,0
 0964 08                push A
 0965 5100              mov A,[__r1]
 0967 08                push A
 0968 7C003D            xcall _pingModule
 096B 38FE              add SP,-2
 096D 62D000            mov REG[0xd0],>__r0
 0970 3C0000            cmp [__r0],0
 0973 B006              jnz X48
 0975 3C0000            cmp [__r1],0
 0978 A098              jz L162
 097A           X48:
 097A                   .dbline 568
 097A           ;                                               {
 097A                   .dbline 569
 097A           ;                                                       configToggle(PC_MODE);
 097A 5000              mov A,0
 097C 08                push A
 097D 5001              mov A,1
 097F 08                push A
 0980 92A3              xcall _configToggle
 0982 38FE              add SP,-2
 0984                   .dbline 571
 0984           ;                                                                                               
 0984           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 0984 10                push X
 0985 62D000            mov REG[0xd0],>_PARAM
 0988 5100              mov A,[_PARAM]
 098A 7C0000            xcall _COMP_SERIAL_PutChar
 098D 20                pop X
 098E                   .dbline 572
 098E           ;                                                       COMP_SERIAL_PutChar('\n');
 098E 10                push X
 098F 500A              mov A,10
 0991 7C0000            xcall _COMP_SERIAL_PutChar
 0994 20                pop X
 0995                   .dbline 573
 0995           ;                                               }
 0995                   .dbline 574
 0995           ;                                       }
 0995 807B              xjmp L162
 0997           L161:
 0997                   .dbline 575
 0997           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0997 62D000            mov REG[0xd0],>__r0
 099A 5201              mov A,[X+1]
 099C 5300              mov [__r1],A
 099E 5200              mov A,[X+0]
 09A0 60D4              mov REG[0xd4],A
 09A2 3E00              mvi A,[__r1]
 09A4 5300              mov [__r1],A
 09A6 550000            mov [__r0],0
 09A9 3C0000            cmp [__r0],0
 09AC B005              jnz X49
 09AE 3963              cmp A,99
 09B0 A00E              jz L170
 09B2           X49:
 09B2 62D000            mov REG[0xd0],>__r0
 09B5 3C0000            cmp [__r0],0
 09B8 B058              jnz L168
 09BA 3C0043            cmp [__r1],67
 09BD B053              jnz L168
 09BF           X50:
 09BF           L170:
 09BF                   .dbline 576
 09BF           ;                                       {
 09BF                   .dbline 579
 09BF           ;                                               // If this isn't for the parent, ping the module to get a
 09BF           ;                                               // status packet and return the data.
 09BF           ;                                               if(ID == 0)
 09BF 3D0500            cmp [X+5],0
 09C2 B014              jnz L171
 09C4                   .dbline 580
 09C4           ;                                               {
 09C4                   .dbline 581
 09C4           ;                                                       COMP_SERIAL_PutChar(CHILD);
 09C4 10                push X
 09C5 62D000            mov REG[0xd0],>_CHILD
 09C8 5100              mov A,[_CHILD]
 09CA 7C0000            xcall _COMP_SERIAL_PutChar
 09CD 20                pop X
 09CE                   .dbline 582
 09CE           ;                                                       COMP_SERIAL_PutChar('\n');
 09CE 10                push X
 09CF 500A              mov A,10
 09D1 7C0000            xcall _COMP_SERIAL_PutChar
 09D4 20                pop X
 09D5                   .dbline 583
 09D5           ;                                               }
 09D5 803B              xjmp L172
 09D7           L171:
 09D7                   .dbline 584
 09D7           ;                                               else if(pingModule(ID))
 09D7 62D000            mov REG[0xd0],>__r0
 09DA 5205              mov A,[X+5]
 09DC 5300              mov [__r1],A
 09DE 5000              mov A,0
 09E0 08                push A
 09E1 5100              mov A,[__r1]
 09E3 08                push A
 09E4 7C003D            xcall _pingModule
 09E7 38FE              add SP,-2
 09E9 62D000            mov REG[0xd0],>__r0
 09EC 3C0000            cmp [__r0],0
 09EF B006              jnz X51
 09F1 3C0000            cmp [__r1],0
 09F4 A01C              jz L173
 09F6           X51:
 09F6                   .dbline 585
 09F6           ;                                               {       
 09F6                   .dbline 586
 09F6           ;                                                       configToggle(PC_MODE);
 09F6 5000              mov A,0
 09F8 08                push A
 09F9 5001              mov A,1
 09FB 08                push A
 09FC 9227              xcall _configToggle
 09FE 38FE              add SP,-2
 0A00                   .dbline 588
 0A00           ;                                                       
 0A00           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 0A00 10                push X
 0A01 62D000            mov REG[0xd0],>_PARAM
 0A04 5101              mov A,[_PARAM+1]
 0A06 7C0000            xcall _COMP_SERIAL_PutChar
 0A09 20                pop X
 0A0A                   .dbline 589
 0A0A           ;                                                       COMP_SERIAL_PutChar('\n');
 0A0A 10                push X
 0A0B 500A              mov A,10
 0A0D 7C0000            xcall _COMP_SERIAL_PutChar
 0A10 20                pop X
 0A11                   .dbline 590
 0A11           ;                                               }
 0A11           L173:
 0A11           L172:
 0A11                   .dbline 591
 0A11           ;                                       }
 0A11           L168:
 0A11           L162:
 0A11           L142:
 0A11           L124:
 0A11                   .dbline 592
 0A11           ;                               }
 0A11           L121:
 0A11                   .dbline 593
 0A11           ;                       }
 0A11           L119:
 0A11                   .dbline 594
 0A11           ;               }
 0A11           L116:
 0A11           L89:
 0A11           L86:
 0A11           L83:
 0A11                   .dbline 595
 0A11           ;       }
 0A11           L80:
 0A11                   .dbline 598
 0A11           ;       
 0A11           ;       // Reset the timeout and switch to PC mode.
 0A11           ;       if(STATE != PC_MODE)
 0A11 62D000            mov REG[0xd0],>_STATE
 0A14 3C0000            cmp [_STATE],0
 0A17 B006              jnz X52
 0A19 3C0101            cmp [_STATE+1],1
 0A1C A00D              jz L176
 0A1E           X52:
 0A1E                   .dbline 599
 0A1E           ;       {
 0A1E                   .dbline 600
 0A1E           ;               configToggle(PC_MODE);
 0A1E 5000              mov A,0
 0A20 08                push A
 0A21 5001              mov A,1
 0A23 08                push A
 0A24 91FF              xcall _configToggle
 0A26 38FE              add SP,-2
 0A28                   .dbline 601
 0A28           ;       }
 0A28 800F              xjmp L177
 0A2A           L176:
 0A2A                   .dbline 603
 0A2A           ;       else
 0A2A           ;       {
 0A2A                   .dbline 604
 0A2A           ;               TIMEOUT = 0;
 0A2A 62D000            mov REG[0xd0],>_TIMEOUT
 0A2D 550100            mov [_TIMEOUT+1],0
 0A30 550000            mov [_TIMEOUT],0
 0A33                   .dbline 605
 0A33           ;               COMP_SERIAL_CmdReset();
 0A33 10                push X
 0A34 7C0000            xcall _COMP_SERIAL_CmdReset
 0A37 20                pop X
 0A38                   .dbline 606
 0A38           ;       }
 0A38           L177:
 0A38                   .dbline -2
 0A38           L79:
 0A38 38F4              add SP,-12
 0A3A 20                pop X
 0A3B                   .dbline 0 ; func end
 0A3B 7F                ret
 0A3C                   .dbsym l speed 10 A[2:2]c
 0A3C                   .dbsym l angle 8 A[2:2]c
 0A3C                   .dbsym l total 6 I
 0A3C                   .dbsym l ID 5 c
 0A3C                   .dbsym l runningTotal 3 I
 0A3C                   .dbsym l tempByte 2 c
 0A3C                   .dbsym l param 0 pc
 0A3C                   .dbend
 0A3C                   .dbfunc e servoInstruction _servoInstruction fV
 0A3C           ;          total -> X+1
 0A3C           ;       checksum -> X+0
 0A3C           ;          value -> X-8
 0A3C           ;        address -> X-7
 0A3C           ;    instruction -> X-6
 0A3C           ;         length -> X-5
 0A3C           ;             id -> X-4
 0A3C           _servoInstruction::
 0A3C                   .dbline -1
 0A3C 10                push X
 0A3D 4F                mov X,SP
 0A3E 3803              add SP,3
 0A40                   .dbline 612
 0A40           ; }
 0A40           ; 
 0A40           ; // This function receives a destination, command length, instruction type, address, and value.
 0A40           ; // With these parameters, the function sends a packet to the communication bus.
 0A40           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0A40           ; {
 0A40                   .dbline 617
 0A40           ;       char checksum;  // The checksum byte value.
 0A40           ;       int total;              // The total for use in calculating the checksum.
 0A40           ;       
 0A40           ;       // Get the total of all bytes.
 0A40           ;       total = id + length + instruction + address + value;
 0A40 62D000            mov REG[0xd0],>__r0
 0A43 52FB              mov A,[X-5]
 0A45 5300              mov [__r1],A
 0A47 550000            mov [__r0],0
 0A4A 52FC              mov A,[X-4]
 0A4C 0200              add A,[__r1]
 0A4E 5300              mov [__r1],A
 0A50 5000              mov A,0
 0A52 0A00              adc A,[__r0]
 0A54 5300              mov [__r0],A
 0A56 52FA              mov A,[X-6]
 0A58 0400              add [__r1],A
 0A5A 0E0000            adc [__r0],0
 0A5D 52F9              mov A,[X-7]
 0A5F 0400              add [__r1],A
 0A61 0E0000            adc [__r0],0
 0A64 52F8              mov A,[X-8]
 0A66 5300              mov [__r3],A
 0A68 550000            mov [__r2],0
 0A6B 5100              mov A,[__r1]
 0A6D 0200              add A,[__r3]
 0A6F 5402              mov [X+2],A
 0A71 5100              mov A,[__r0]
 0A73 0A00              adc A,[__r2]
 0A75 5401              mov [X+1],A
 0A77                   .dbline 620
 0A77           ;       
 0A77           ;       // Calculate the checksum value for our servo communication.
 0A77           ;       checksum = 255-(total%256);
 0A77 5001              mov A,1
 0A79 08                push A
 0A7A 5000              mov A,0
 0A7C 08                push A
 0A7D 5201              mov A,[X+1]
 0A7F 08                push A
 0A80 5202              mov A,[X+2]
 0A82 08                push A
 0A83 7C0000            xcall __divmod_16X16_16
 0A86 38FE              add SP,-2
 0A88 18                pop A
 0A89 5300              mov [__r1],A
 0A8B 18                pop A
 0A8C 50FF              mov A,-1
 0A8E 1200              sub A,[__r1]
 0A90 5400              mov [X+0],A
 0A92                   .dbline 623
 0A92           ;       
 0A92           ;       // Talk to the servo.
 0A92           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte one
 0A92 10                push X
 0A93 50FF              mov A,-1
 0A95 7C0000            xcall _TX_REPEATER_14_PutChar
 0A98 20                pop X
 0A99                   .dbline 624
 0A99           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte one
 0A99 10                push X
 0A9A 50FF              mov A,-1
 0A9C 7C0000            xcall _TX_REPEATER_23_PutChar
 0A9F 20                pop X
 0AA0                   .dbline 625
 0AA0           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte two
 0AA0 10                push X
 0AA1 50FF              mov A,-1
 0AA3 7C0000            xcall _TX_REPEATER_14_PutChar
 0AA6 20                pop X
 0AA7                   .dbline 626
 0AA7           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte two
 0AA7 10                push X
 0AA8 50FF              mov A,-1
 0AAA 7C0000            xcall _TX_REPEATER_23_PutChar
 0AAD 20                pop X
 0AAE                   .dbline 627
 0AAE           ;       TX_REPEATER_14_PutChar(id);                     // The servo ID
 0AAE 10                push X
 0AAF 52FC              mov A,[X-4]
 0AB1 7C0000            xcall _TX_REPEATER_14_PutChar
 0AB4 20                pop X
 0AB5                   .dbline 628
 0AB5           ;       TX_REPEATER_23_PutChar(id);                             // The servo ID
 0AB5 10                push X
 0AB6 52FC              mov A,[X-4]
 0AB8 7C0000            xcall _TX_REPEATER_23_PutChar
 0ABB 20                pop X
 0ABC                   .dbline 629
 0ABC           ;       TX_REPEATER_14_PutChar(length);         // Remaining packet length
 0ABC 10                push X
 0ABD 52FB              mov A,[X-5]
 0ABF 7C0000            xcall _TX_REPEATER_14_PutChar
 0AC2 20                pop X
 0AC3                   .dbline 630
 0AC3           ;       TX_REPEATER_23_PutChar(length);                 // Remaining packet length
 0AC3 10                push X
 0AC4 52FB              mov A,[X-5]
 0AC6 7C0000            xcall _TX_REPEATER_23_PutChar
 0AC9 20                pop X
 0ACA                   .dbline 631
 0ACA           ;       TX_REPEATER_14_PutChar(instruction);    // Servo instruction
 0ACA 10                push X
 0ACB 52FA              mov A,[X-6]
 0ACD 7C0000            xcall _TX_REPEATER_14_PutChar
 0AD0 20                pop X
 0AD1                   .dbline 632
 0AD1           ;       TX_REPEATER_23_PutChar(instruction);    // Servo instruction
 0AD1 10                push X
 0AD2 52FA              mov A,[X-6]
 0AD4 7C0000            xcall _TX_REPEATER_23_PutChar
 0AD7 20                pop X
 0AD8                   .dbline 633
 0AD8           ;       TX_REPEATER_14_PutChar(address);                // Target memory address on the servo EEPROM
 0AD8 10                push X
 0AD9 52F9              mov A,[X-7]
 0ADB 7C0000            xcall _TX_REPEATER_14_PutChar
 0ADE 20                pop X
 0ADF                   .dbline 634
 0ADF           ;       TX_REPEATER_23_PutChar(address);                // Target memory address on the servo EEPROM
 0ADF 10                push X
 0AE0 52F9              mov A,[X-7]
 0AE2 7C0000            xcall _TX_REPEATER_23_PutChar
 0AE5 20                pop X
 0AE6                   .dbline 635
 0AE6           ;       TX_REPEATER_14_PutChar(value);                  // The write value or number of bytes to read
 0AE6 10                push X
 0AE7 52F8              mov A,[X-8]
 0AE9 7C0000            xcall _TX_REPEATER_14_PutChar
 0AEC 20                pop X
 0AED                   .dbline 636
 0AED           ;       TX_REPEATER_23_PutChar(value);                  // The write value or number of bytes to read
 0AED 10                push X
 0AEE 52F8              mov A,[X-8]
 0AF0 7C0000            xcall _TX_REPEATER_23_PutChar
 0AF3 20                pop X
 0AF4                   .dbline 637
 0AF4           ;       TX_REPEATER_14_PutChar(checksum);               // This is the end of this transmission
 0AF4 10                push X
 0AF5 5200              mov A,[X+0]
 0AF7 7C0000            xcall _TX_REPEATER_14_PutChar
 0AFA 20                pop X
 0AFB                   .dbline 638
 0AFB           ;       TX_REPEATER_23_PutChar(checksum);               // This is the end of this transmission
 0AFB 10                push X
 0AFC 5200              mov A,[X+0]
 0AFE 7C0000            xcall _TX_REPEATER_23_PutChar
 0B01 20                pop X
 0B02           L179:
 0B02                   .dbline 641
 0B02           ;       
 0B02           ;       // Wait for the transmission to finish.
 0B02           ;       while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
 0B02           L180:
 0B02                   .dbline 641
 0B02 10                push X
 0B03 7C0000            xcall _TX_REPEATER_14_bReadTxStatus
 0B06 62D000            mov REG[0xd0],>__r0
 0B09 20                pop X
 0B0A 5300              mov [__r0],A
 0B0C 470020            tst [__r0],32
 0B0F AFF2              jz L179
 0B11           L182:
 0B11                   .dbline 642
 0B11           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 0B11           L183:
 0B11                   .dbline 642
 0B11 10                push X
 0B12 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 0B15 62D000            mov REG[0xd0],>__r0
 0B18 20                pop X
 0B19 5300              mov [__r0],A
 0B1B 470020            tst [__r0],32
 0B1E AFF2              jz L182
 0B20                   .dbline 645
 0B20           ;       
 0B20           ;       // Make completely sure we're done.
 0B20           ;       xmitWait();
 0B20 9506              xcall _xmitWait
 0B22                   .dbline -2
 0B22           L178:
 0B22 38FD              add SP,-3
 0B24 20                pop X
 0B25                   .dbline 0 ; func end
 0B25 7F                ret
 0B26                   .dbsym l total 1 I
 0B26                   .dbsym l checksum 0 c
 0B26                   .dbsym l value -8 c
 0B26                   .dbsym l address -7 c
 0B26                   .dbsym l instruction -6 c
 0B26                   .dbsym l length -5 c
 0B26                   .dbsym l id -4 c
 0B26                   .dbend
 0B26                   .dbfunc e longServoInstruction _longServoInstruction fV
 0B26           ;          total -> X+1
 0B26           ;       checksum -> X+0
 0B26           ;         value2 -> X-9
 0B26           ;         value1 -> X-8
 0B26           ;        address -> X-7
 0B26           ;    instruction -> X-6
 0B26           ;         length -> X-5
 0B26           ;             id -> X-4
 0B26           _longServoInstruction::
 0B26                   .dbline -1
 0B26 10                push X
 0B27 4F                mov X,SP
 0B28 3803              add SP,3
 0B2A                   .dbline 650
 0B2A           ; }
 0B2A           ; 
 0B2A           ; // This function receives a destination, command length, instruction type, address, and two values.
 0B2A           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0B2A           ; {
 0B2A                   .dbline 655
 0B2A           ;       char checksum;  // The checksum byte value.
 0B2A           ;       int total;              // The total for use in calculating the checksum.
 0B2A           ;       
 0B2A           ;       // Get the total of all bytes.
 0B2A           ;       total = id + length + instruction + address + value1 + value2;
 0B2A 62D000            mov REG[0xd0],>__r0
 0B2D 52FB              mov A,[X-5]
 0B2F 5300              mov [__r1],A
 0B31 550000            mov [__r0],0
 0B34 52FC              mov A,[X-4]
 0B36 0200              add A,[__r1]
 0B38 5300              mov [__r1],A
 0B3A 5000              mov A,0
 0B3C 0A00              adc A,[__r0]
 0B3E 5300              mov [__r0],A
 0B40 52FA              mov A,[X-6]
 0B42 0400              add [__r1],A
 0B44 0E0000            adc [__r0],0
 0B47 52F9              mov A,[X-7]
 0B49 0400              add [__r1],A
 0B4B 0E0000            adc [__r0],0
 0B4E 52F8              mov A,[X-8]
 0B50 0400              add [__r1],A
 0B52 0E0000            adc [__r0],0
 0B55 52F7              mov A,[X-9]
 0B57 5300              mov [__r3],A
 0B59 550000            mov [__r2],0
 0B5C 5100              mov A,[__r1]
 0B5E 0200              add A,[__r3]
 0B60 5402              mov [X+2],A
 0B62 5100              mov A,[__r0]
 0B64 0A00              adc A,[__r2]
 0B66 5401              mov [X+1],A
 0B68                   .dbline 658
 0B68           ;       
 0B68           ;       // Calculate the checksum value for our servo communication.
 0B68           ;       checksum = 255-(total%256);
 0B68 5001              mov A,1
 0B6A 08                push A
 0B6B 5000              mov A,0
 0B6D 08                push A
 0B6E 5201              mov A,[X+1]
 0B70 08                push A
 0B71 5202              mov A,[X+2]
 0B73 08                push A
 0B74 7C0000            xcall __divmod_16X16_16
 0B77 38FE              add SP,-2
 0B79 18                pop A
 0B7A 5300              mov [__r1],A
 0B7C 18                pop A
 0B7D 50FF              mov A,-1
 0B7F 1200              sub A,[__r1]
 0B81 5400              mov [X+0],A
 0B83                   .dbline 661
 0B83           ;       
 0B83           ;       // Talk to the servo.
 0B83           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte one
 0B83 10                push X
 0B84 50FF              mov A,-1
 0B86 7C0000            xcall _TX_REPEATER_14_PutChar
 0B89 20                pop X
 0B8A                   .dbline 662
 0B8A           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte one
 0B8A 10                push X
 0B8B 50FF              mov A,-1
 0B8D 7C0000            xcall _TX_REPEATER_23_PutChar
 0B90 20                pop X
 0B91                   .dbline 663
 0B91           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte two
 0B91 10                push X
 0B92 50FF              mov A,-1
 0B94 7C0000            xcall _TX_REPEATER_14_PutChar
 0B97 20                pop X
 0B98                   .dbline 664
 0B98           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte two
 0B98 10                push X
 0B99 50FF              mov A,-1
 0B9B 7C0000            xcall _TX_REPEATER_23_PutChar
 0B9E 20                pop X
 0B9F                   .dbline 665
 0B9F           ;       TX_REPEATER_14_PutChar(id);                     // The servo ID
 0B9F 10                push X
 0BA0 52FC              mov A,[X-4]
 0BA2 7C0000            xcall _TX_REPEATER_14_PutChar
 0BA5 20                pop X
 0BA6                   .dbline 666
 0BA6           ;       TX_REPEATER_23_PutChar(id);                             // The servo ID
 0BA6 10                push X
 0BA7 52FC              mov A,[X-4]
 0BA9 7C0000            xcall _TX_REPEATER_23_PutChar
 0BAC 20                pop X
 0BAD                   .dbline 667
 0BAD           ;       TX_REPEATER_14_PutChar(length);         // Remaining packet length
 0BAD 10                push X
 0BAE 52FB              mov A,[X-5]
 0BB0 7C0000            xcall _TX_REPEATER_14_PutChar
 0BB3 20                pop X
 0BB4                   .dbline 668
 0BB4           ;       TX_REPEATER_23_PutChar(length);                 // Remaining packet length
 0BB4 10                push X
 0BB5 52FB              mov A,[X-5]
 0BB7 7C0000            xcall _TX_REPEATER_23_PutChar
 0BBA 20                pop X
 0BBB                   .dbline 669
 0BBB           ;       TX_REPEATER_14_PutChar(instruction);    // Servo instruction
 0BBB 10                push X
 0BBC 52FA              mov A,[X-6]
 0BBE 7C0000            xcall _TX_REPEATER_14_PutChar
 0BC1 20                pop X
 0BC2                   .dbline 670
 0BC2           ;       TX_REPEATER_23_PutChar(instruction);    // Servo instruction
 0BC2 10                push X
 0BC3 52FA              mov A,[X-6]
 0BC5 7C0000            xcall _TX_REPEATER_23_PutChar
 0BC8 20                pop X
 0BC9                   .dbline 671
 0BC9           ;       TX_REPEATER_14_PutChar(address);                // Target memory address on the servo EEPROM
 0BC9 10                push X
 0BCA 52F9              mov A,[X-7]
 0BCC 7C0000            xcall _TX_REPEATER_14_PutChar
 0BCF 20                pop X
 0BD0                   .dbline 672
 0BD0           ;       TX_REPEATER_23_PutChar(address);                // Target memory address on the servo EEPROM
 0BD0 10                push X
 0BD1 52F9              mov A,[X-7]
 0BD3 7C0000            xcall _TX_REPEATER_23_PutChar
 0BD6 20                pop X
 0BD7                   .dbline 673
 0BD7           ;       TX_REPEATER_14_PutChar(value1);         // The first write value
 0BD7 10                push X
 0BD8 52F8              mov A,[X-8]
 0BDA 7C0000            xcall _TX_REPEATER_14_PutChar
 0BDD 20                pop X
 0BDE                   .dbline 674
 0BDE           ;       TX_REPEATER_23_PutChar(value1);                 // The first write value
 0BDE 10                push X
 0BDF 52F8              mov A,[X-8]
 0BE1 7C0000            xcall _TX_REPEATER_23_PutChar
 0BE4 20                pop X
 0BE5                   .dbline 675
 0BE5           ;       TX_REPEATER_14_PutChar(value2);         // The second write value
 0BE5 10                push X
 0BE6 52F7              mov A,[X-9]
 0BE8 7C0000            xcall _TX_REPEATER_14_PutChar
 0BEB 20                pop X
 0BEC                   .dbline 676
 0BEC           ;       TX_REPEATER_23_PutChar(value2);                 // The second write value
 0BEC 10                push X
 0BED 52F7              mov A,[X-9]
 0BEF 7C0000            xcall _TX_REPEATER_23_PutChar
 0BF2 20                pop X
 0BF3                   .dbline 677
 0BF3           ;       TX_REPEATER_14_PutChar(checksum);               // This is the end of this transmission
 0BF3 10                push X
 0BF4 5200              mov A,[X+0]
 0BF6 7C0000            xcall _TX_REPEATER_14_PutChar
 0BF9 20                pop X
 0BFA                   .dbline 678
 0BFA           ;       TX_REPEATER_23_PutChar(checksum);               // This is the end of this transmission
 0BFA 10                push X
 0BFB 5200              mov A,[X+0]
 0BFD 7C0000            xcall _TX_REPEATER_23_PutChar
 0C00 20                pop X
 0C01           L186:
 0C01                   .dbline 681
 0C01           ;       
 0C01           ;       // Wait for the transmission to finish.
 0C01           ;       while(!(TX_REPEATER_14_bReadTxStatus() & TX_REPEATER_14_TX_COMPLETE));
 0C01           L187:
 0C01                   .dbline 681
 0C01 10                push X
 0C02 7C0000            xcall _TX_REPEATER_14_bReadTxStatus
 0C05 62D000            mov REG[0xd0],>__r0
 0C08 20                pop X
 0C09 5300              mov [__r0],A
 0C0B 470020            tst [__r0],32
 0C0E AFF2              jz L186
 0C10           L189:
 0C10                   .dbline 682
 0C10           ;       while(!(TX_REPEATER_23_bReadTxStatus() & TX_REPEATER_23_TX_COMPLETE));
 0C10           L190:
 0C10                   .dbline 682
 0C10 10                push X
 0C11 7C0000            xcall _TX_REPEATER_23_bReadTxStatus
 0C14 62D000            mov REG[0xd0],>__r0
 0C17 20                pop X
 0C18 5300              mov [__r0],A
 0C1A 470020            tst [__r0],32
 0C1D AFF2              jz L189
 0C1F                   .dbline 685
 0C1F           ;       
 0C1F           ;       // Make completely sure we're done.
 0C1F           ;       xmitWait();
 0C1F 9407              xcall _xmitWait
 0C21                   .dbline -2
 0C21           L185:
 0C21 38FD              add SP,-3
 0C23 20                pop X
 0C24                   .dbline 0 ; func end
 0C24 7F                ret
 0C25                   .dbsym l total 1 I
 0C25                   .dbsym l checksum 0 c
 0C25                   .dbsym l value2 -9 c
 0C25                   .dbsym l value1 -8 c
 0C25                   .dbsym l address -7 c
 0C25                   .dbsym l instruction -6 c
 0C25                   .dbsym l length -5 c
 0C25                   .dbsym l id -4 c
 0C25                   .dbend
 0C25                   .dbfunc e configToggle _configToggle fV
 0C25           ;           mode -> X-5
 0C25           _configToggle::
 0C25                   .dbline -1
 0C25 10                push X
 0C26 4F                mov X,SP
 0C27                   .dbline 691
 0C27           ; }
 0C27           ; 
 0C27           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0C27           ; // half duplex UART serial communication line.
 0C27           ; void configToggle(int mode)
 0C27           ; {
 0C27                   .dbline 693
 0C27           ;       // Disconnect from the global bus and leave the pin high.
 0C27           ;       PRT0DR |= 0b11111111;
 0C27 4300FF            or REG[0],-1
 0C2A                   .dbline 694
 0C2A           ;       PRT0GS &= 0b00000000;
 0C2A 620200            mov REG[0x2],0
 0C2D                   .dbline 698
 0C2D           ; 
 0C2D           ;       // Unload the configuration of the current state.
 0C2D           ;       // If there is no state, blindly wipe all configurations.
 0C2D           ;       if(STATE)
 0C2D 62D000            mov REG[0xd0],>_STATE
 0C30 3C0000            cmp [_STATE],0
 0C33 B006              jnz X53
 0C35 3C0100            cmp [_STATE+1],0
 0C38 A010              jz L193
 0C3A           X53:
 0C3A                   .dbline 699
 0C3A           ;       {
 0C3A                   .dbline 700
 0C3A           ;               unloadConfig(STATE);
 0C3A 62D000            mov REG[0xd0],>_STATE
 0C3D 5100              mov A,[_STATE]
 0C3F 08                push A
 0C40 5101              mov A,[_STATE+1]
 0C42 08                push A
 0C43 90BA              xcall _unloadConfig
 0C45 38FE              add SP,-2
 0C47                   .dbline 701
 0C47           ;       }
 0C47 8003              xjmp L194
 0C49           L193:
 0C49                   .dbline 703
 0C49           ;       else
 0C49           ;       {
 0C49                   .dbline 704
 0C49           ;               unloadAllConfigs();
 0C49 90AD              xcall _unloadAllConfigs
 0C4B                   .dbline 705
 0C4B           ;       }
 0C4B           L194:
 0C4B                   .dbline 707
 0C4B           ;       
 0C4B           ;       if(mode == PC_MODE)
 0C4B 3DFB00            cmp [X-5],0
 0C4E B061              jnz L195
 0C50 3DFC01            cmp [X-4],1
 0C53 B05C              jnz L195
 0C55           X54:
 0C55                   .dbline 708
 0C55           ;       {
 0C55                   .dbline 709
 0C55           ;               LoadConfig_pc_listener();
 0C55 7C0000            xcall _LoadConfig_pc_listener
 0C58                   .dbline 711
 0C58           ; 
 0C58           ;               COMP_SERIAL_CmdReset();                                                         // Initialize the buffer.
 0C58 10                push X
 0C59 7C0000            xcall _COMP_SERIAL_CmdReset
 0C5C 20                pop X
 0C5D                   .dbline 712
 0C5D           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT);         // Enable RX interrupts  
 0C5D 10                push X
 0C5E 5001              mov A,1
 0C60 7C0000            xcall _COMP_SERIAL_IntCntl
 0C63 20                pop X
 0C64                   .dbline 713
 0C64           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                            // Starts the UART.
 0C64 10                push X
 0C65 5000              mov A,0
 0C67 7C0000            xcall _COMP_SERIAL_Start
 0C6A 20                pop X
 0C6B                   .dbline 715
 0C6B           ;               
 0C6B           ;               TX_REPEATER_14_Start(TX_REPEATER_14_PARITY_NONE);       // Start the 014 TX repeater.
 0C6B 10                push X
 0C6C 5000              mov A,0
 0C6E 7C0000            xcall _TX_REPEATER_14_Start
 0C71 20                pop X
 0C72                   .dbline 716
 0C72           ;               TX_REPEATER_23_Start(TX_REPEATER_23_PARITY_NONE);       // Start the 23 TX repeater.
 0C72 10                push X
 0C73 5000              mov A,0
 0C75 7C0000            xcall _TX_REPEATER_23_Start
 0C78 20                pop X
 0C79                   .dbline 718
 0C79           ;               
 0C79           ;               TIMEOUT = 0;                    // Clear the timeout flag.
 0C79 62D000            mov REG[0xd0],>_TIMEOUT
 0C7C 550100            mov [_TIMEOUT+1],0
 0C7F 550000            mov [_TIMEOUT],0
 0C82                   .dbline 719
 0C82           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0C82 10                push X
 0C83 7C0000            xcall _TX_TIMEOUT_EnableInt
 0C86                   .dbline 720
 0C86           ;               TX_TIMEOUT_Start();             // Start the timer.
 0C86 7C0000            xcall _TX_TIMEOUT_Start
 0C89 20                pop X
 0C8A           L197:
 0C8A                   .dbline 723
 0C8A           ;               
 0C8A           ;               // Do nothing while we allow everyone to load the right configuration.
 0C8A           ;               while(!TIMEOUT){ }
 0C8A                   .dbline 723
 0C8A           L198:
 0C8A                   .dbline 723
 0C8A 62D000            mov REG[0xd0],>_TIMEOUT
 0C8D 3C0000            cmp [_TIMEOUT],0
 0C90 B006              jnz X55
 0C92 3C0100            cmp [_TIMEOUT+1],0
 0C95 AFF4              jz L197
 0C97           X55:
 0C97                   .dbline 726
 0C97           ;               
 0C97           ;               // Stop the timer and reset the timeout flag.
 0C97           ;               TX_TIMEOUT_Stop();
 0C97 10                push X
 0C98 7C0000            xcall _TX_TIMEOUT_Stop
 0C9B 20                pop X
 0C9C                   .dbline 727
 0C9C           ;               TIMEOUT = 0;
 0C9C 62D000            mov REG[0xd0],>_TIMEOUT
 0C9F 550100            mov [_TIMEOUT+1],0
 0CA2 550000            mov [_TIMEOUT],0
 0CA5                   .dbline 730
 0CA5           ;               
 0CA5           ;               // Store the state.
 0CA5           ;               STATE = PC_MODE;
 0CA5 62D000            mov REG[0xd0],>_STATE
 0CA8 550101            mov [_STATE+1],1
 0CAB 550000            mov [_STATE],0
 0CAE                   .dbline 731
 0CAE           ;       }
 0CAE 8044              xjmp L196
 0CB0           L195:
 0CB0                   .dbline 732
 0CB0           ;       else if(mode == RX_MODE)
 0CB0 3DFB00            cmp [X-5],0
 0CB3 B03F              jnz L200
 0CB5 3DFC02            cmp [X-4],2
 0CB8 B03A              jnz L200
 0CBA           X56:
 0CBA                   .dbline 733
 0CBA           ;       {
 0CBA                   .dbline 734
 0CBA           ;               LoadConfig_receiver_config();
 0CBA 7C0000            xcall _LoadConfig_receiver_config
 0CBD                   .dbline 738
 0CBD           ;               
 0CBD           ;               // Start the receivers.
 0CBD           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0CBD           ;               {
 0CBD                   .dbline 740
 0CBD           ;               // Start listening for a response through child port 1.
 0CBD           ;               RECEIVE_1_Start(RECEIVE_1_PARITY_NONE);
 0CBD 10                push X
 0CBE 5000              mov A,0
 0CC0 7C0000            xcall _RECEIVE_1_Start
 0CC3 20                pop X
 0CC4                   .dbline 741
 0CC4           ;               }
 0CC4                   .dbline 743
 0CC4           ;               
 0CC4           ;               {
 0CC4                   .dbline 745
 0CC4           ;               // Start listening for a response through child port 2.
 0CC4           ;               RECEIVE_2_Start(RECEIVE_2_PARITY_NONE);
 0CC4 10                push X
 0CC5 5000              mov A,0
 0CC7 7C0000            xcall _RECEIVE_2_Start
 0CCA 20                pop X
 0CCB                   .dbline 746
 0CCB           ;               }
 0CCB                   .dbline 748
 0CCB           ;               
 0CCB           ;               {
 0CCB                   .dbline 750
 0CCB           ;               // Start listening for a response through child port 3.
 0CCB           ;               RECEIVE_3_Start(RECEIVE_3_PARITY_NONE);
 0CCB 10                push X
 0CCC 5000              mov A,0
 0CCE 7C0000            xcall _RECEIVE_3_Start
 0CD1 20                pop X
 0CD2                   .dbline 751
 0CD2           ;               }
 0CD2                   .dbline 753
 0CD2           ;               
 0CD2           ;               {
 0CD2                   .dbline 755
 0CD2           ;               // Start listening for a response through child port 4.
 0CD2           ;               RECEIVE_4_Start(RECEIVE_4_PARITY_NONE);
 0CD2 10                push X
 0CD3 5000              mov A,0
 0CD5 7C0000            xcall _RECEIVE_4_Start
 0CD8 20                pop X
 0CD9                   .dbline 756
 0CD9           ;               }
 0CD9                   .dbline 759
 0CD9           ;               
 0CD9           ;               // Start response timeout timer and enable its interrupt routine.
 0CD9           ;               TIMEOUT = 0;
 0CD9 62D000            mov REG[0xd0],>_TIMEOUT
 0CDC 550100            mov [_TIMEOUT+1],0
 0CDF 550000            mov [_TIMEOUT],0
 0CE2                   .dbline 760
 0CE2           ;               RX_TIMEOUT_EnableInt();
 0CE2 10                push X
 0CE3 7C0000            xcall _RX_TIMEOUT_EnableInt
 0CE6                   .dbline 761
 0CE6           ;               RX_TIMEOUT_Start();
 0CE6 7C0000            xcall _RX_TIMEOUT_Start
 0CE9 20                pop X
 0CEA                   .dbline 764
 0CEA           ;               
 0CEA           ;               // Store the state.
 0CEA           ;               STATE = RX_MODE;
 0CEA 62D000            mov REG[0xd0],>_STATE
 0CED 550102            mov [_STATE+1],2
 0CF0 550000            mov [_STATE],0
 0CF3                   .dbline 765
 0CF3           ;       }
 0CF3           L200:
 0CF3           L196:
 0CF3                   .dbline 768
 0CF3           ;       
 0CF3           ;       // Reconnect to the global bus.
 0CF3           ;       PRT0GS |= 0b11111111;
 0CF3 4302FF            or REG[0x2],-1
 0CF6                   .dbline -2
 0CF6           L192:
 0CF6 20                pop X
 0CF7                   .dbline 0 ; func end
 0CF7 7F                ret
 0CF8                   .dbsym l mode -5 I
 0CF8                   .dbend
 0CF8                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0CF8           _unloadAllConfigs::
 0CF8                   .dbline -1
 0CF8                   .dbline 774
 0CF8           ; }
 0CF8           ; 
 0CF8           ; // This function blindly unloads all user configurations. This will be called once,
 0CF8           ; // when the system initially has no known state.
 0CF8           ; void unloadAllConfigs(void)
 0CF8           ; {
 0CF8                   .dbline 775
 0CF8           ;       UnloadConfig_pc_listener();
 0CF8 7C0000            xcall _UnloadConfig_pc_listener
 0CFB                   .dbline 776
 0CFB           ;       UnloadConfig_receiver_config();
 0CFB 7C0000            xcall _UnloadConfig_receiver_config
 0CFE                   .dbline -2
 0CFE           L202:
 0CFE                   .dbline 0 ; func end
 0CFE 7F                ret
 0CFF                   .dbend
 0CFF                   .dbfunc e unloadConfig _unloadConfig fV
 0CFF           ;     config_num -> X-5
 0CFF           _unloadConfig::
 0CFF                   .dbline -1
 0CFF 10                push X
 0D00 4F                mov X,SP
 0D01                   .dbline 782
 0D01           ; }
 0D01           ; 
 0D01           ; // This function unloads the configuration corresponding to the config number passed to it.
 0D01           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0D01           ; void unloadConfig(int config_num)
 0D01           ; {
 0D01                   .dbline 783
 0D01           ;       if(config_num == PC_MODE)
 0D01 3DFB00            cmp [X-5],0
 0D04 B00B              jnz L204
 0D06 3DFC01            cmp [X-4],1
 0D09 B006              jnz L204
 0D0B           X57:
 0D0B                   .dbline 784
 0D0B           ;       {
 0D0B                   .dbline 785
 0D0B           ;               UnloadConfig_pc_listener();
 0D0B 7C0000            xcall _UnloadConfig_pc_listener
 0D0E                   .dbline 786
 0D0E           ;       }
 0D0E 800E              xjmp L205
 0D10           L204:
 0D10                   .dbline 787
 0D10           ;       else if(config_num == RX_MODE)
 0D10 3DFB00            cmp [X-5],0
 0D13 B009              jnz L206
 0D15 3DFC02            cmp [X-4],2
 0D18 B004              jnz L206
 0D1A           X58:
 0D1A                   .dbline 788
 0D1A           ;       {
 0D1A                   .dbline 789
 0D1A           ;               UnloadConfig_receiver_config();
 0D1A 7C0000            xcall _UnloadConfig_receiver_config
 0D1D                   .dbline 790
 0D1D           ;       }
 0D1D           L206:
 0D1D           L205:
 0D1D                   .dbline -2
 0D1D           L203:
 0D1D 20                pop X
 0D1E                   .dbline 0 ; func end
 0D1E 7F                ret
 0D1F                   .dbsym l config_num -5 I
 0D1F                   .dbend
 0D1F                   .dbfunc e initializeChildren _initializeChildren fV
 0D1F           ;   num_timeouts -> X+4
 0D1F           ;     ping_tries -> X+2
 0D1F           ;              i -> X+0
 0D1F           _initializeChildren::
 0D1F                   .dbline -1
 0D1F 10                push X
 0D20 4F                mov X,SP
 0D21 3806              add SP,6
 0D23                   .dbline 794
 0D23           ; }
 0D23           ; 
 0D23           ; void initializeChildren(void)
 0D23           ; {
 0D23                   .dbline 795
 0D23           ;       int num_timeouts = 0;   // The number of consecutive timeouts.
 0D23 560500            mov [X+5],0
 0D26 560400            mov [X+4],0
 0D29                   .dbline 796
 0D29           ;       int ping_tries = 5;             // The number of times to try a ping on an unregistered module.
 0D29 560305            mov [X+3],5
 0D2C 560200            mov [X+2],0
 0D2F                   .dbline 797
 0D2F           ;       int i = 0;                              // An iterator for looping.
 0D2F 560100            mov [X+1],0
 0D32 560000            mov [X+0],0
 0D35                   .dbline 800
 0D35           ;       
 0D35           ;       // Set num modules to zero.
 0D35           ;       NUM_MODULES = 0;
 0D35 62D000            mov REG[0xd0],>_NUM_MODULES
 0D38 550100            mov [_NUM_MODULES+1],0
 0D3B 550000            mov [_NUM_MODULES],0
 0D3E                   .dbline 803
 0D3E           ;       
 0D3E           ;       // Set the child value to zero.
 0D3E           ;       CHILD = 0;      
 0D3E 62D000            mov REG[0xd0],>_CHILD
 0D41 550000            mov [_CHILD],0
 0D44 8006              xjmp L210
 0D46           L209:
 0D46                   .dbline 806
 0D46           ;       
 0D46           ;       while(CHILD == 0)
 0D46           ;       {
 0D46                   .dbline 808
 0D46           ;               // Send out a probing message.
 0D46           ;               sayHello();
 0D46 7C0261            xcall _sayHello
 0D49                   .dbline 811
 0D49           ;               
 0D49           ;               // Listen for a response.
 0D49           ;               childListen();
 0D49 9179              xcall _childListen
 0D4B                   .dbline 812
 0D4B           ;       }
 0D4B           L210:
 0D4B                   .dbline 805
 0D4B 62D000            mov REG[0xd0],>_CHILD
 0D4E 3C0000            cmp [_CHILD],0
 0D51 AFF4              jz L209
 0D53                   .dbline 815
 0D53           ;       
 0D53           ;       // Send out a probing message.
 0D53           ;       sayHello();
 0D53 7C0261            xcall _sayHello
 0D56 80EA              xjmp L213
 0D58           L212:
 0D58                   .dbline 820
 0D58           ;       
 0D58           ;       // This loop continuously probes and listens at intervals
 0D58           ;       // set by the RX_TIMEOUT_DURATION variable.
 0D58           ;       while(num_timeouts < MAX_TIMEOUTS)
 0D58           ;       {       
 0D58                   .dbline 821
 0D58           ;               if(validTransmission())
 0D58 7C02FB            xcall _validTransmission
 0D5B 62D000            mov REG[0xd0],>__r0
 0D5E 3C0000            cmp [__r0],0
 0D61 B006              jnz X59
 0D63 3C0000            cmp [__r1],0
 0D66 A096              jz L215
 0D68           X59:
 0D68                   .dbline 822
 0D68           ;               {
 0D68                   .dbline 823
 0D68           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0D68 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0D6B 3C00C8            cmp [_COMMAND_TYPE],-56
 0D6E B0D2              jnz L216
 0D70                   .dbline 824
 0D70           ;                       {
 0D70                   .dbline 826
 0D70           ;                               // If this is for me, assign them an ID.
 0D70           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 0D70 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0D73 3C0000            cmp [_COMMAND_DESTINATION],0
 0D76 B0CA              jnz L216
 0D78                   .dbline 827
 0D78           ;                               {
 0D78                   .dbline 828
 0D78           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0D78 62D000            mov REG[0xd0],>_NUM_MODULES
 0D7B 7601              inc [_NUM_MODULES+1]
 0D7D 0E0000            adc [_NUM_MODULES],0
 0D80                   .dbline 829
 0D80           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0D80 560500            mov [X+5],0
 0D83 560400            mov [X+4],0
 0D86                   .dbline 831
 0D86           ;               
 0D86           ;                                       if(!assignID(NUM_MODULES))
 0D86 5100              mov A,[_NUM_MODULES]
 0D88 08                push A
 0D89 5101              mov A,[_NUM_MODULES+1]
 0D8B 08                push A
 0D8C 7C0148            xcall _assignID
 0D8F 38FE              add SP,-2
 0D91 62D000            mov REG[0xd0],>__r0
 0D94 3C0000            cmp [__r0],0
 0D97 B0A9              jnz L216
 0D99 3C0000            cmp [__r1],0
 0D9C B0A4              jnz L216
 0D9E           X60:
 0D9E                   .dbline 832
 0D9E           ;                                       {
 0D9E                   .dbline 836
 0D9E           ;                                               // If the module did not respond that the ID was assigned,
 0D9E           ;                                               // make an effort to ping it in case that transmission was lost
 0D9E           ;                                               // before ultimately deciding that the module didn't configure.
 0D9E           ;                                               for(i = 0; i < ping_tries; i++)
 0D9E 560100            mov [X+1],0
 0DA1 560000            mov [X+0],0
 0DA4 802D              xjmp L226
 0DA6           L223:
 0DA6                   .dbline 837
 0DA6           ;                                               {       
 0DA6                   .dbline 838
 0DA6           ;                                                       if(pingModule(NUM_MODULES))
 0DA6 62D000            mov REG[0xd0],>_NUM_MODULES
 0DA9 5100              mov A,[_NUM_MODULES]
 0DAB 08                push A
 0DAC 5101              mov A,[_NUM_MODULES+1]
 0DAE 08                push A
 0DAF 7C003D            xcall _pingModule
 0DB2 38FE              add SP,-2
 0DB4 62D000            mov REG[0xd0],>__r0
 0DB7 3C0000            cmp [__r0],0
 0DBA B006              jnz X61
 0DBC 3C0000            cmp [__r1],0
 0DBF A00D              jz L227
 0DC1           X61:
 0DC1                   .dbline 839
 0DC1           ;                                                       {
 0DC1                   .dbline 840
 0DC1           ;                                                               i = ping_tries+1;
 0DC1 5203              mov A,[X+3]
 0DC3 0101              add A,1
 0DC5 5401              mov [X+1],A
 0DC7 5202              mov A,[X+2]
 0DC9 0900              adc A,0
 0DCB 5400              mov [X+0],A
 0DCD                   .dbline 841
 0DCD           ;                                                       }
 0DCD           L227:
 0DCD                   .dbline 842
 0DCD           ;                                               }
 0DCD           L224:
 0DCD                   .dbline 836
 0DCD 7701              inc [X+1]
 0DCF 0F0000            adc [X+0],0
 0DD2           L226:
 0DD2                   .dbline 836
 0DD2 5201              mov A,[X+1]
 0DD4 1303              sub A,[X+3]
 0DD6 5202              mov A,[X+2]
 0DD8 3180              xor A,-128
 0DDA 62D000            mov REG[0xd0],>__r0
 0DDD 5300              mov [__rX],A
 0DDF 5200              mov A,[X+0]
 0DE1 3180              xor A,-128
 0DE3 1A00              sbb A,[__rX]
 0DE5 CFC0              jc L223
 0DE7           X62:
 0DE7                   .dbline 845
 0DE7           ;                                               
 0DE7           ;                                               // If we landed right at ping_tries, we failed.
 0DE7           ;                                               if(i == ping_tries)
 0DE7 5200              mov A,[X+0]
 0DE9 3B02              cmp A,[X+2]
 0DEB B055              jnz L216
 0DED 5201              mov A,[X+1]
 0DEF 3B03              cmp A,[X+3]
 0DF1 B04F              jnz L216
 0DF3           X63:
 0DF3                   .dbline 846
 0DF3           ;                                               {
 0DF3                   .dbline 847
 0DF3           ;                                                       NUM_MODULES--;
 0DF3 62D000            mov REG[0xd0],>_NUM_MODULES
 0DF6 7A01              dec [_NUM_MODULES+1]
 0DF8 1E0000            sbb [_NUM_MODULES],0
 0DFB                   .dbline 848
 0DFB           ;                                               }
 0DFB                   .dbline 849
 0DFB           ;                                       }
 0DFB                   .dbline 850
 0DFB           ;                               }
 0DFB                   .dbline 851
 0DFB           ;                       }
 0DFB                   .dbline 852
 0DFB           ;               }
 0DFB 8045              xjmp L216
 0DFD           L215:
 0DFD                   .dbline 853
 0DFD           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0DFD 62D000            mov REG[0xd0],>_TIMEOUT
 0E00 5101              mov A,[_TIMEOUT+1]
 0E02 1105              sub A,5
 0E04 5100              mov A,[_TIMEOUT]
 0E06 3180              xor A,-128
 0E08 1980              sbb A,(0 ^ 0x80)
 0E0A C036              jc L231
 0E0C           X64:
 0E0C                   .dbline 854
 0E0C           ;               {       
 0E0C                   .dbline 856
 0E0C           ;                       // Only increment the number of timeouts if we have found a module.
 0E0C           ;                       if(NUM_MODULES)
 0E0C 62D000            mov REG[0xd0],>_NUM_MODULES
 0E0F 3C0000            cmp [_NUM_MODULES],0
 0E12 B006              jnz X65
 0E14 3C0100            cmp [_NUM_MODULES+1],0
 0E17 A008              jz L236
 0E19           X65:
 0E19                   .dbline 857
 0E19           ;                       {
 0E19                   .dbline 858
 0E19           ;                               num_timeouts++;
 0E19 7705              inc [X+5]
 0E1B 0F0400            adc [X+4],0
 0E1E                   .dbline 859
 0E1E           ;                       }
 0E1E 8010              xjmp L234
 0E20           L235:
 0E20                   .dbline 864
 0E20           ;                       else
 0E20           ;                       {
 0E20           ;                               // Wait additional time between transmissions if no modules have been found.
 0E20           ;                               // This is done to give the first child a chance to configure if it hasn't.
 0E20           ;                               while(TIMEOUT < INIT_WAIT_TIME) { }
 0E20                   .dbline 864
 0E20           L236:
 0E20                   .dbline 864
 0E20 62D000            mov REG[0xd0],>_TIMEOUT
 0E23 5101              mov A,[_TIMEOUT+1]
 0E25 1132              sub A,50
 0E27 5100              mov A,[_TIMEOUT]
 0E29 3180              xor A,-128
 0E2B 1980              sbb A,(0 ^ 0x80)
 0E2D CFF2              jc L235
 0E2F           X66:
 0E2F                   .dbline 865
 0E2F           ;                       }
 0E2F           L234:
 0E2F                   .dbline 868
 0E2F           ;                       
 0E2F           ;                       // If we are not maxed out on modules, look for more.
 0E2F           ;                       if(NUM_MODULES < MAX_MODULES)
 0E2F 62D000            mov REG[0xd0],>_NUM_MODULES
 0E32 5101              mov A,[_NUM_MODULES+1]
 0E34 11FA              sub A,-6
 0E36 5100              mov A,[_NUM_MODULES]
 0E38 3180              xor A,-128
 0E3A 1980              sbb A,(0 ^ 0x80)
 0E3C D004              jnc L238
 0E3E           X67:
 0E3E                   .dbline 869
 0E3E           ;                       {
 0E3E                   .dbline 870
 0E3E           ;                               sayHello();
 0E3E 7C0261            xcall _sayHello
 0E41                   .dbline 871
 0E41           ;                       }
 0E41           L238:
 0E41                   .dbline 872
 0E41           ;               }
 0E41           L231:
 0E41           L216:
 0E41                   .dbline 873
 0E41           ;       }
 0E41           L213:
 0E41                   .dbline 819
 0E41 5205              mov A,[X+5]
 0E43 1132              sub A,50
 0E45 5204              mov A,[X+4]
 0E47 3180              xor A,-128
 0E49 1980              sbb A,(0 ^ 0x80)
 0E4B CF0C              jc L212
 0E4D           X68:
 0E4D                   .dbline 876
 0E4D           ;       
 0E4D           ;       // If we didn't find any new modules, check to see if some already exist.
 0E4D           ;       if(!NUM_MODULES)
 0E4D 62D000            mov REG[0xd0],>_NUM_MODULES
 0E50 3C0000            cmp [_NUM_MODULES],0
 0E53 B062              jnz L240
 0E55 3C0100            cmp [_NUM_MODULES+1],0
 0E58 B05D              jnz L240
 0E5A           X69:
 0E5A                   .dbline 877
 0E5A           ;       {
 0E5A                   .dbline 879
 0E5A           ;               // Try to ping the next module up from our current number ping_tries times.
 0E5A           ;               for(i = 0; i < ping_tries; i++)
 0E5A 560100            mov [X+1],0
 0E5D 560000            mov [X+0],0
 0E60 8040              xjmp L245
 0E62           L242:
 0E62                   .dbline 880
 0E62           ;               {       
 0E62                   .dbline 881
 0E62           ;                       if(pingModule(NUM_MODULES+1))
 0E62 62D000            mov REG[0xd0],>_NUM_MODULES
 0E65 5101              mov A,[_NUM_MODULES+1]
 0E67 0101              add A,1
 0E69 62D000            mov REG[0xd0],>__r0
 0E6C 5300              mov [__r1],A
 0E6E 62D000            mov REG[0xd0],>_NUM_MODULES
 0E71 5100              mov A,[_NUM_MODULES]
 0E73 0900              adc A,0
 0E75 62D000            mov REG[0xd0],>__r0
 0E78 08                push A
 0E79 5100              mov A,[__r1]
 0E7B 08                push A
 0E7C 7C003D            xcall _pingModule
 0E7F 38FE              add SP,-2
 0E81 62D000            mov REG[0xd0],>__r0
 0E84 3C0000            cmp [__r0],0
 0E87 B006              jnz X70
 0E89 3C0000            cmp [__r1],0
 0E8C A00F              jz L246
 0E8E           X70:
 0E8E                   .dbline 882
 0E8E           ;                       {
 0E8E                   .dbline 883
 0E8E           ;                               NUM_MODULES++;
 0E8E 62D000            mov REG[0xd0],>_NUM_MODULES
 0E91 7601              inc [_NUM_MODULES+1]
 0E93 0E0000            adc [_NUM_MODULES],0
 0E96                   .dbline 884
 0E96           ;                               i = 0;
 0E96 560100            mov [X+1],0
 0E99 560000            mov [X+0],0
 0E9C                   .dbline 885
 0E9C           ;                       }
 0E9C           L246:
 0E9C                   .dbline 886
 0E9C           ;               }
 0E9C           L243:
 0E9C                   .dbline 879
 0E9C 7701              inc [X+1]
 0E9E 0F0000            adc [X+0],0
 0EA1           L245:
 0EA1                   .dbline 879
 0EA1 5201              mov A,[X+1]
 0EA3 1303              sub A,[X+3]
 0EA5 5202              mov A,[X+2]
 0EA7 3180              xor A,-128
 0EA9 62D000            mov REG[0xd0],>__r0
 0EAC 5300              mov [__rX],A
 0EAE 5200              mov A,[X+0]
 0EB0 3180              xor A,-128
 0EB2 1A00              sbb A,[__rX]
 0EB4 CFAD              jc L242
 0EB6           X71:
 0EB6                   .dbline 887
 0EB6           ;       }
 0EB6           L240:
 0EB6                   .dbline 890
 0EB6           ;       
 0EB6           ;       // Switch back to PC mode.
 0EB6           ;       configToggle(PC_MODE);
 0EB6 5000              mov A,0
 0EB8 08                push A
 0EB9 5001              mov A,1
 0EBB 08                push A
 0EBC 9D67              xcall _configToggle
 0EBE 38FE              add SP,-2
 0EC0                   .dbline -2
 0EC0           L208:
 0EC0 38FA              add SP,-6
 0EC2 20                pop X
 0EC3                   .dbline 0 ; func end
 0EC3 7F                ret
 0EC4                   .dbsym l num_timeouts 4 I
 0EC4                   .dbsym l ping_tries 2 I
 0EC4                   .dbsym l i 0 I
 0EC4                   .dbend
 0EC4                   .dbfunc e childListen _childListen fV
 0EC4           _childListen::
 0EC4                   .dbline -1
 0EC4                   .dbline 895
 0EC4           ; }
 0EC4           ; 
 0EC4           ; // This function listens for children and registers the port that they talk to.
 0EC4           ; void childListen(void)
 0EC4           ; {     
 0EC4 80B7              xjmp L250
 0EC6           L249:
 0EC6                   .dbline 898
 0EC6           ;       // Wait to either hear a child or time out.
 0EC6           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0EC6           ;       {               
 0EC6                   .dbline 901
 0EC6           ;               // Check all of the ports for a start byte. Only one port will produce one.
 0EC6           ;               // Only non-blocking commands are used to avoid getting stuck listening downstream.
 0EC6           ;               if(RECEIVE_1_cReadChar() == START_TRANSMIT)
 0EC6 10                push X
 0EC7 7C0000            xcall _RECEIVE_1_cReadChar
 0ECA 62D000            mov REG[0xd0],>__r0
 0ECD 20                pop X
 0ECE 39FC              cmp A,-4
 0ED0 B023              jnz L252
 0ED2                   .dbline 902
 0ED2           ;               {
 0ED2 8010              xjmp L255
 0ED4           L254:
 0ED4                   .dbline 904
 0ED4           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0ED4           ;                       {
 0ED4                   .dbline 905
 0ED4           ;                               if(RECEIVE_1_cReadChar() == END_TRANSMIT)
 0ED4 10                push X
 0ED5 7C0000            xcall _RECEIVE_1_cReadChar
 0ED8 20                pop X
 0ED9 39FD              cmp A,-3
 0EDB B007              jnz L257
 0EDD                   .dbline 906
 0EDD           ;                               {
 0EDD                   .dbline 907
 0EDD           ;                                       CHILD = PORT_1;
 0EDD 62D000            mov REG[0xd0],>_CHILD
 0EE0 550031            mov [_CHILD],49
 0EE3                   .dbline 908
 0EE3           ;                               }
 0EE3           L257:
 0EE3                   .dbline 909
 0EE3           ;                       }
 0EE3           L255:
 0EE3                   .dbline 903
 0EE3 62D000            mov REG[0xd0],>_TIMEOUT
 0EE6 5101              mov A,[_TIMEOUT+1]
 0EE8 1105              sub A,5
 0EEA 5100              mov A,[_TIMEOUT]
 0EEC 3180              xor A,-128
 0EEE 1980              sbb A,(0 ^ 0x80)
 0EF0 CFE3              jc L254
 0EF2           X72:
 0EF2                   .dbline 910
 0EF2           ;               }
 0EF2 8089              xjmp L253
 0EF4           L252:
 0EF4                   .dbline 911
 0EF4           ;               else if(RECEIVE_2_cReadChar() == START_TRANSMIT)
 0EF4 10                push X
 0EF5 7C0000            xcall _RECEIVE_2_cReadChar
 0EF8 62D000            mov REG[0xd0],>__r0
 0EFB 20                pop X
 0EFC 39FC              cmp A,-4
 0EFE B023              jnz L259
 0F00                   .dbline 912
 0F00           ;               {
 0F00 8010              xjmp L262
 0F02           L261:
 0F02                   .dbline 914
 0F02           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0F02           ;                       {
 0F02                   .dbline 915
 0F02           ;                               if(RECEIVE_2_cReadChar() == END_TRANSMIT)
 0F02 10                push X
 0F03 7C0000            xcall _RECEIVE_2_cReadChar
 0F06 20                pop X
 0F07 39FD              cmp A,-3
 0F09 B007              jnz L264
 0F0B                   .dbline 916
 0F0B           ;                               {
 0F0B                   .dbline 917
 0F0B           ;                                       CHILD = PORT_2;
 0F0B 62D000            mov REG[0xd0],>_CHILD
 0F0E 550032            mov [_CHILD],50
 0F11                   .dbline 918
 0F11           ;                               }
 0F11           L264:
 0F11                   .dbline 919
 0F11           ;                       }
 0F11           L262:
 0F11                   .dbline 913
 0F11 62D000            mov REG[0xd0],>_TIMEOUT
 0F14 5101              mov A,[_TIMEOUT+1]
 0F16 1105              sub A,5
 0F18 5100              mov A,[_TIMEOUT]
 0F1A 3180              xor A,-128
 0F1C 1980              sbb A,(0 ^ 0x80)
 0F1E CFE3              jc L261
 0F20           X73:
 0F20                   .dbline 920
 0F20           ;               }
 0F20 805B              xjmp L260
 0F22           L259:
 0F22                   .dbline 921
 0F22           ;               else if(RECEIVE_3_cReadChar() == START_TRANSMIT)
 0F22 10                push X
 0F23 7C0000            xcall _RECEIVE_3_cReadChar
 0F26 62D000            mov REG[0xd0],>__r0
 0F29 20                pop X
 0F2A 39FC              cmp A,-4
 0F2C B023              jnz L266
 0F2E                   .dbline 922
 0F2E           ;               {
 0F2E 8010              xjmp L269
 0F30           L268:
 0F30                   .dbline 924
 0F30           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0F30           ;                       {
 0F30                   .dbline 925
 0F30           ;                               if(RECEIVE_3_cReadChar() == END_TRANSMIT)
 0F30 10                push X
 0F31 7C0000            xcall _RECEIVE_3_cReadChar
 0F34 20                pop X
 0F35 39FD              cmp A,-3
 0F37 B007              jnz L271
 0F39                   .dbline 926
 0F39           ;                               {
 0F39                   .dbline 927
 0F39           ;                                       CHILD = PORT_3;
 0F39 62D000            mov REG[0xd0],>_CHILD
 0F3C 550033            mov [_CHILD],51
 0F3F                   .dbline 928
 0F3F           ;                               }
 0F3F           L271:
 0F3F                   .dbline 929
 0F3F           ;                       }
 0F3F           L269:
 0F3F                   .dbline 923
 0F3F 62D000            mov REG[0xd0],>_TIMEOUT
 0F42 5101              mov A,[_TIMEOUT+1]
 0F44 1105              sub A,5
 0F46 5100              mov A,[_TIMEOUT]
 0F48 3180              xor A,-128
 0F4A 1980              sbb A,(0 ^ 0x80)
 0F4C CFE3              jc L268
 0F4E           X74:
 0F4E                   .dbline 930
 0F4E           ;               }
 0F4E 802D              xjmp L267
 0F50           L266:
 0F50                   .dbline 931
 0F50           ;               else if(RECEIVE_4_cReadChar() == START_TRANSMIT)
 0F50 10                push X
 0F51 7C0000            xcall _RECEIVE_4_cReadChar
 0F54 62D000            mov REG[0xd0],>__r0
 0F57 20                pop X
 0F58 39FC              cmp A,-4
 0F5A B021              jnz L273
 0F5C                   .dbline 932
 0F5C           ;               {
 0F5C 8010              xjmp L276
 0F5E           L275:
 0F5E                   .dbline 934
 0F5E           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0F5E           ;                       {
 0F5E                   .dbline 935
 0F5E           ;                               if(RECEIVE_4_cReadChar() == END_TRANSMIT)
 0F5E 10                push X
 0F5F 7C0000            xcall _RECEIVE_4_cReadChar
 0F62 20                pop X
 0F63 39FD              cmp A,-3
 0F65 B007              jnz L278
 0F67                   .dbline 936
 0F67           ;                               {
 0F67                   .dbline 937
 0F67           ;                                       CHILD = PORT_4;
 0F67 62D000            mov REG[0xd0],>_CHILD
 0F6A 550034            mov [_CHILD],52
 0F6D                   .dbline 938
 0F6D           ;                               }
 0F6D           L278:
 0F6D                   .dbline 939
 0F6D           ;                       }
 0F6D           L276:
 0F6D                   .dbline 933
 0F6D 62D000            mov REG[0xd0],>_TIMEOUT
 0F70 5101              mov A,[_TIMEOUT+1]
 0F72 1105              sub A,5
 0F74 5100              mov A,[_TIMEOUT]
 0F76 3180              xor A,-128
 0F78 1980              sbb A,(0 ^ 0x80)
 0F7A CFE3              jc L275
 0F7C           X75:
 0F7C                   .dbline 940
 0F7C           ;               }
 0F7C           L273:
 0F7C           L267:
 0F7C           L260:
 0F7C           L253:
 0F7C                   .dbline 941
 0F7C           ;       }
 0F7C           L250:
 0F7C                   .dbline 897
 0F7C 62D000            mov REG[0xd0],>_TIMEOUT
 0F7F 5101              mov A,[_TIMEOUT+1]
 0F81 1105              sub A,5
 0F83 5100              mov A,[_TIMEOUT]
 0F85 3180              xor A,-128
 0F87 1980              sbb A,(0 ^ 0x80)
 0F89 CF3C              jc L249
 0F8B           X76:
 0F8B                   .dbline -2
 0F8B           L248:
 0F8B                   .dbline 0 ; func end
 0F8B 7F                ret
 0F8C                   .dbend
 0F8C                   .dbfunc e iReadChar _iReadChar fc
 0F8C           _iReadChar::
 0F8C                   .dbline -1
 0F8C                   .dbline 946
 0F8C           ; }
 0F8C           ; 
 0F8C           ; // This function converts the PSoC cReadChar calls of all ports into a single return.
 0F8C           ; char iReadChar(void)
 0F8C           ; {
 0F8C                   .dbline 947
 0F8C           ;       if(CHILD == PORT_1)
 0F8C 62D000            mov REG[0xd0],>_CHILD
 0F8F 3C0031            cmp [_CHILD],49
 0F92 B00B              jnz L281
 0F94                   .dbline 948
 0F94           ;       {
 0F94                   .dbline 949
 0F94           ;               return RECEIVE_1_cReadChar();
 0F94 10                push X
 0F95 7C0000            xcall _RECEIVE_1_cReadChar
 0F98 62D000            mov REG[0xd0],>__r0
 0F9B 20                pop X
 0F9C 803C              xjmp L280
 0F9E           L281:
 0F9E                   .dbline 951
 0F9E           ;       }
 0F9E           ;       else if(CHILD == PORT_2)
 0F9E 62D000            mov REG[0xd0],>_CHILD
 0FA1 3C0032            cmp [_CHILD],50
 0FA4 B00B              jnz L283
 0FA6                   .dbline 952
 0FA6           ;       {
 0FA6                   .dbline 953
 0FA6           ;               return RECEIVE_2_cReadChar();
 0FA6 10                push X
 0FA7 7C0000            xcall _RECEIVE_2_cReadChar
 0FAA 62D000            mov REG[0xd0],>__r0
 0FAD 20                pop X
 0FAE 802A              xjmp L280
 0FB0           L283:
 0FB0                   .dbline 955
 0FB0           ;       }
 0FB0           ;       else if(CHILD == PORT_3)
 0FB0 62D000            mov REG[0xd0],>_CHILD
 0FB3 3C0033            cmp [_CHILD],51
 0FB6 B00B              jnz L285
 0FB8                   .dbline 956
 0FB8           ;       {
 0FB8                   .dbline 957
 0FB8           ;               return RECEIVE_3_cReadChar();
 0FB8 10                push X
 0FB9 7C0000            xcall _RECEIVE_3_cReadChar
 0FBC 62D000            mov REG[0xd0],>__r0
 0FBF 20                pop X
 0FC0 8018              xjmp L280
 0FC2           L285:
 0FC2                   .dbline 959
 0FC2           ;       }
 0FC2           ;       else if(CHILD == PORT_4)
 0FC2 62D000            mov REG[0xd0],>_CHILD
 0FC5 3C0034            cmp [_CHILD],52
 0FC8 B00B              jnz L287
 0FCA                   .dbline 960
 0FCA           ;       {
 0FCA                   .dbline 961
 0FCA           ;               return RECEIVE_4_cReadChar();
 0FCA 10                push X
 0FCB 7C0000            xcall _RECEIVE_4_cReadChar
 0FCE 62D000            mov REG[0xd0],>__r0
 0FD1 20                pop X
 0FD2 8006              xjmp L280
 0FD4           L287:
 0FD4                   .dbline 964
 0FD4           ;       }
 0FD4           ;       else
 0FD4           ;       {
 0FD4                   .dbline 965
 0FD4           ;               return 0;
 0FD4 62D000            mov REG[0xd0],>__r0
 0FD7 5000              mov A,0
 0FD9                   .dbline -2
 0FD9           L280:
 0FD9                   .dbline 0 ; func end
 0FD9 7F                ret
 0FDA                   .dbend
 0FDA                   .dbfunc e readChar _readChar fc
 0FDA           _readChar::
 0FDA                   .dbline -1
 0FDA                   .dbline 971
 0FDA           ;       }
 0FDA           ; }
 0FDA           ; 
 0FDA           ; // This function converts the PSoC cGetChar calls of all ports into a single return.
 0FDA           ; char readChar(void)
 0FDA           ; {     
 0FDA                   .dbline 972
 0FDA           ;       if(CHILD == PORT_1)
 0FDA 62D000            mov REG[0xd0],>_CHILD
 0FDD 3C0031            cmp [_CHILD],49
 0FE0 B00B              jnz L290
 0FE2                   .dbline 973
 0FE2           ;       {
 0FE2                   .dbline 974
 0FE2           ;               return RECEIVE_1_cGetChar();
 0FE2 10                push X
 0FE3 7C0000            xcall _RECEIVE_1_cGetChar
 0FE6 62D000            mov REG[0xd0],>__r0
 0FE9 20                pop X
 0FEA 803C              xjmp L289
 0FEC           L290:
 0FEC                   .dbline 976
 0FEC           ;       }
 0FEC           ;       else if(CHILD == PORT_2)
 0FEC 62D000            mov REG[0xd0],>_CHILD
 0FEF 3C0032            cmp [_CHILD],50
 0FF2 B00B              jnz L292
 0FF4                   .dbline 977
 0FF4           ;       {
 0FF4                   .dbline 978
 0FF4           ;               return RECEIVE_2_cGetChar();
 0FF4 10                push X
 0FF5 7C0000            xcall _RECEIVE_2_cGetChar
 0FF8 62D000            mov REG[0xd0],>__r0
 0FFB 20                pop X
 0FFC 802A              xjmp L289
 0FFE           L292:
 0FFE                   .dbline 980
 0FFE           ;       }
 0FFE           ;       else if(CHILD == PORT_3)
 0FFE 62D000            mov REG[0xd0],>_CHILD
 1001 3C0033            cmp [_CHILD],51
 1004 B00B              jnz L294
 1006                   .dbline 981
 1006           ;       {
 1006                   .dbline 982
 1006           ;               return RECEIVE_3_cGetChar();
 1006 10                push X
 1007 7C0000            xcall _RECEIVE_3_cGetChar
 100A 62D000            mov REG[0xd0],>__r0
 100D 20                pop X
 100E 8018              xjmp L289
 1010           L294:
 1010                   .dbline 984
 1010           ;       }
 1010           ;       else if(CHILD == PORT_4)
 1010 62D000            mov REG[0xd0],>_CHILD
 1013 3C0034            cmp [_CHILD],52
 1016 B00B              jnz L296
 1018                   .dbline 985
 1018           ;       {
 1018                   .dbline 986
 1018           ;               return RECEIVE_4_cGetChar();
 1018 10                push X
 1019 7C0000            xcall _RECEIVE_4_cGetChar
 101C 62D000            mov REG[0xd0],>__r0
 101F 20                pop X
 1020 8006              xjmp L289
 1022           L296:
 1022                   .dbline 989
 1022           ;       }
 1022           ;       else
 1022           ;       {
 1022                   .dbline 990
 1022           ;               return 0;
 1022 62D000            mov REG[0xd0],>__r0
 1025 5000              mov A,0
 1027                   .dbline -2
 1027           L289:
 1027                   .dbline 0 ; func end
 1027 7F                ret
 1028                   .dbend
 1028                   .dbfunc e xmitWait _xmitWait fV
 1028           ;              i -> X+0
 1028           _xmitWait::
 1028                   .dbline -1
 1028 10                push X
 1029 4F                mov X,SP
 102A 3802              add SP,2
 102C                   .dbline 995
 102C           ;       }
 102C           ; }
 102C           ; 
 102C           ; void xmitWait(void)
 102C           ; {
 102C                   .dbline 998
 102C           ;       int i;
 102C           ;       
 102C           ;       for(i = 0; i < 25; i++)
 102C 560100            mov [X+1],0
 102F 560000            mov [X+0],0
 1032           L299:
 1032                   .dbline 999
 1032           ;       {
 1032                   .dbline 1001
 1032           ;               // Sit here and spin for about 50 microseconds.
 1032           ;       }
 1032           L300:
 1032                   .dbline 998
 1032 7701              inc [X+1]
 1034 0F0000            adc [X+0],0
 1037                   .dbline 998
 1037 5201              mov A,[X+1]
 1039 1119              sub A,25
 103B 5200              mov A,[X+0]
 103D 3180              xor A,-128
 103F 1980              sbb A,(0 ^ 0x80)
 1041 CFF0              jc L299
 1043           X77:
 1043                   .dbline -2
 1043           L298:
 1043 38FE              add SP,-2
 1045 20                pop X
 1046                   .dbline 0 ; func end
 1046 7F                ret
 1047                   .dbsym l i 0 I
 1047                   .dbend
 1047                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 1047           _TX_TIMEOUT_ISR::
 1047                   .dbline -1
 1047 71C0              or F,-64
 1049 08                push A
 104A 5DD0              mov A,REG[0xd0]
 104C 08                push A
 104D                   .dbline 1005
 104D           ; }
 104D           ; 
 104D           ; void TX_TIMEOUT_ISR(void)
 104D           ; {     
 104D                   .dbline 1007
 104D           ;       // Increment the number of timeouts.
 104D           ;       TIMEOUT++;
 104D 62D000            mov REG[0xd0],>_TIMEOUT
 1050 7601              inc [_TIMEOUT+1]
 1052 0E0000            adc [_TIMEOUT],0
 1055                   .dbline 1009
 1055           ;       
 1055           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 1055 62DAFD            mov REG[0xda],-3
 1058                   .dbline -2
 1058           L303:
 1058 18                pop A
 1059 60D0              mov REG[208],A
 105B 18                pop A
 105C                   .dbline 0 ; func end
 105C 7E                reti
 105D                   .dbend
 105D                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 105D           _RX_TIMEOUT_ISR::
 105D                   .dbline -1
 105D 71C0              or F,-64
 105F 08                push A
 1060 5DD0              mov A,REG[0xd0]
 1062 08                push A
 1063                   .dbline 1013
 1063           ; }
 1063           ; 
 1063           ; void RX_TIMEOUT_ISR(void)
 1063           ; {     
 1063                   .dbline 1015
 1063           ;       // Increment the number of timeouts.
 1063           ;       TIMEOUT++;
 1063 62D000            mov REG[0xd0],>_TIMEOUT
 1066 7601              inc [_TIMEOUT+1]
 1068 0E0000            adc [_TIMEOUT],0
 106B                   .dbline 1017
 106B           ;       
 106B           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 106B 62DAFD            mov REG[0xda],-3
 106E                   .dbline -2
 106E           L304:
 106E 18                pop A
 106F 60D0              mov REG[208],A
 1071 18                pop A
 1072                   .dbline 0 ; func end
 1072 7E                reti
 1073                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
