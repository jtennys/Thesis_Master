 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 103
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; 
 0000           ; #include <m8c.h>              // part specific constants and macros
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0000           ; #include "psocdynamic.h"
 0000           ; #include <stdlib.h>
 0000           ; #include <string.h>
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0000           ; #define               PC_MODE                                         (2)
 0000           ; #define               RX_MODE                                         (1)
 0000           ; #define               TX_MODE                                         (0)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; // These defines are used for the initial probing stage. This module first waits until it hears
 0000           ; // a byte on the bus. Once this happens, this module waits until there is a BUS_CLEAR_TIME
 0000           ; // period of no communication before attempting to probe for modules and assign ID numbers.
 0000           ; // MAX_TIMEOUTS is the number of failed attempts allowed to find an unconfigured module after
 0000           ; // the first module is found. After all of this, this module goes into a PC listening mode.
 0000           ; #define               BUS_CLEAR_TIME                          (100)   // Min time after a byte to assume bus is clear at boot.
 0000           ; #define               BOOT_TIMEOUT                            (300)   // If nothing is heard by this time, we start the init anyway.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the master
 0000           ; #define               MAX_MODULES                                     (250)
 0000           ; 
 0000           ; #define               SERVO_START                                     (255)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the
 0000           ; // system configuration between receive and transmit modes for half duplex UART.
 0000           ; void configToggle(int mode);
 0000           ; 
 0000           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; 
 0000           ; // This function assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; 
 0000           ; int validTransmission(void);
 0000           ; 
 0000           ; void decodeTransmission(void);
 0000           ; 
 0000           ; void busListen(void);
 0000           ; 
 0000           ; void sayHello(void);
 0000           ; 
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; 
 0000           ; int clearConfig(int module_id);
 0000           ; // This function checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the slave module controllers.
 0000           ; void initializeSlaves(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; 
 0000           ; // This flag is set if there is a timeout.
 0000           ; int TIMEOUT;
 0000           ; 
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 105
 0000           ;       // Activate GPIO ISR.
 0000           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 0000 43E020            or REG[0xe0],32
 0003                   .dbline 108
 0003           ;       
 0003           ;       // Turn on global interrupts for the transmission timeout timer.
 0003           ;       M8C_EnableGInt;
 0003 7101                      or  F, 01h
 0005           
 0005                   .dbline 111
 0005           ;       
 0005           ;       // Initialize all of the slave modules.
 0005           ;       initializeSlaves();
 0005 7C0C58            xcall _initializeSlaves
 0008 800F              xjmp L3
 000A           L2:
 000A                   .dbline 114
 000A           ;       
 000A           ;       while(1)
 000A           ;       {       
 000A                   .dbline 116
 000A           ;               // If there's a command from the computer, read it.
 000A           ;               if(COMP_SERIAL_bCmdCheck())
 000A 10                push X
 000B 7C0000            xcall _COMP_SERIAL_bCmdCheck
 000E 62D000            mov REG[0xd0],>__r0
 0011 20                pop X
 0012 3900              cmp A,0
 0014 A003              jz L5
 0016                   .dbline 117
 0016           ;               {
 0016                   .dbline 118
 0016           ;                       decodeTransmission();
 0016 942C              xcall _decodeTransmission
 0018                   .dbline 119
 0018           ;               }
 0018           L5:
 0018                   .dbline 120
 0018           ;       }
 0018           L3:
 0018                   .dbline 113
 0018 8FF1              xjmp L2
 001A           X0:
 001A                   .dbline -2
 001A           L1:
 001A                   .dbline 0 ; func end
 001A 8FFF              jmp .
 001C                   .dbend
 001C                   .dbfunc e pingModule _pingModule fI
 001C           ;       response -> X+0
 001C           ;      module_id -> X-5
 001C           _pingModule::
 001C                   .dbline -1
 001C 10                push X
 001D 4F                mov X,SP
 001E 3802              add SP,2
 0020                   .dbline 124
 0020           ; }
 0020           ; 
 0020           ; int pingModule(int module_id)
 0020           ; {
 0020                   .dbline 125
 0020           ;       int response = 0;
 0020 560100            mov [X+1],0
 0023 560000            mov [X+0],0
 0026                   .dbline 127
 0026           ;       
 0026           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0026 5000              mov A,0
 0028 08                push A
 0029 08                push A
 002A 7C0AEB            xcall _configToggle
 002D 38FE              add SP,-2
 002F                   .dbline 130
 002F           ;                       
 002F           ;       // Transmit a hello.
 002F           ;       TRANSMIT_PutChar(START_TRANSMIT);
 002F 10                push X
 0030 50FC              mov A,-4
 0032 7C0000            xcall _TRANSMIT_PutChar
 0035 20                pop X
 0036                   .dbline 131
 0036           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0036 10                push X
 0037 50FC              mov A,-4
 0039 7C0000            xcall _TRANSMIT_PutChar
 003C 20                pop X
 003D                   .dbline 132
 003D           ;       TRANSMIT_PutChar(MASTER_ID);
 003D 10                push X
 003E 5000              mov A,0
 0040 7C0000            xcall _TRANSMIT_PutChar
 0043 20                pop X
 0044                   .dbline 133
 0044           ;       TRANSMIT_PutChar(module_id);
 0044 62D000            mov REG[0xd0],>__r0
 0047 52FC              mov A,[X-4]
 0049 10                push X
 004A 7C0000            xcall _TRANSMIT_PutChar
 004D 20                pop X
 004E                   .dbline 134
 004E           ;       TRANSMIT_PutChar(PING);
 004E 10                push X
 004F 50CB              mov A,-53
 0051 7C0000            xcall _TRANSMIT_PutChar
 0054 20                pop X
 0055                   .dbline 135
 0055           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0055 10                push X
 0056 50FD              mov A,-3
 0058 7C0000            xcall _TRANSMIT_PutChar
 005B 20                pop X
 005C                   .dbline 136
 005C           ;       TRANSMIT_PutChar(END_TRANSMIT);
 005C 10                push X
 005D 50FD              mov A,-3
 005F 7C0000            xcall _TRANSMIT_PutChar
 0062 20                pop X
 0063           L8:
 0063                   .dbline 139
 0063           ;       
 0063           ;       // Wait for the transmission to finish.
 0063           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0063           L9:
 0063                   .dbline 139
 0063 10                push X
 0064 7C0000            xcall _TRANSMIT_bReadTxStatus
 0067 62D000            mov REG[0xd0],>__r0
 006A 20                pop X
 006B 5300              mov [__r0],A
 006D 470020            tst [__r0],32
 0070 AFF2              jz L8
 0072                   .dbline 141
 0072           ;       
 0072           ;       xmitWait();
 0072 7C0D96            xcall _xmitWait
 0075                   .dbline 143
 0075           ;       
 0075           ;       configToggle(RX_MODE);  // Listen for the response.
 0075 5000              mov A,0
 0077 08                push A
 0078 5001              mov A,1
 007A 08                push A
 007B 7C0AEB            xcall _configToggle
 007E 38FE              add SP,-2
 0080                   .dbline 145
 0080           ;       
 0080           ;       RX_TIMEOUT_Stop();
 0080 10                push X
 0081 7C0000            xcall _RX_TIMEOUT_Stop
 0084 20                pop X
 0085                   .dbline 146
 0085           ;       TIMEOUT = 0;
 0085 62D000            mov REG[0xd0],>_TIMEOUT
 0088 550100            mov [_TIMEOUT+1],0
 008B 550000            mov [_TIMEOUT],0
 008E                   .dbline 147
 008E           ;       RX_TIMEOUT_Start();
 008E 10                push X
 008F 7C0000            xcall _RX_TIMEOUT_Start
 0092 20                pop X
 0093 803C              xjmp L12
 0095           L11:
 0095                   .dbline 150
 0095           ;       
 0095           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 0095           ;       {
 0095                   .dbline 151
 0095           ;               if(validTransmission())
 0095 92B9              xcall _validTransmission
 0097 62D000            mov REG[0xd0],>__r0
 009A 3C0000            cmp [__r0],0
 009D B006              jnz X1
 009F 3C0000            cmp [__r1],0
 00A2 A02D              jz L14
 00A4           X1:
 00A4                   .dbline 152
 00A4           ;               {
 00A4                   .dbline 153
 00A4           ;                       if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00A4 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00A7 3C00CB            cmp [_COMMAND_TYPE],-53
 00AA B025              jnz L16
 00AC                   .dbline 154
 00AC           ;                       {
 00AC                   .dbline 156
 00AC           ;                               // If this is for me, check who it was from.
 00AC           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 00AC 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00AF 3C0000            cmp [_COMMAND_DESTINATION],0
 00B2 B01D              jnz L18
 00B4                   .dbline 157
 00B4           ;                               {
 00B4                   .dbline 158
 00B4           ;                                       if(COMMAND_SOURCE == module_id)
 00B4 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00B7 5100              mov A,[_COMMAND_SOURCE]
 00B9 62D000            mov REG[0xd0],>__r0
 00BC 5300              mov [__r1],A
 00BE 5000              mov A,0
 00C0 3BFB              cmp A,[X-5]
 00C2 B00D              jnz L20
 00C4 5100              mov A,[__r1]
 00C6 3BFC              cmp A,[X-4]
 00C8 B007              jnz L20
 00CA           X2:
 00CA                   .dbline 159
 00CA           ;                                       {
 00CA                   .dbline 160
 00CA           ;                                               response = 1;
 00CA 560101            mov [X+1],1
 00CD 560000            mov [X+0],0
 00D0                   .dbline 161
 00D0           ;                                       }
 00D0           L20:
 00D0                   .dbline 162
 00D0           ;                               }
 00D0           L18:
 00D0                   .dbline 163
 00D0           ;                       }
 00D0           L16:
 00D0                   .dbline 164
 00D0           ;               }
 00D0           L14:
 00D0                   .dbline 165
 00D0           ;       }
 00D0           L12:
 00D0                   .dbline 149
 00D0 62D000            mov REG[0xd0],>_TIMEOUT
 00D3 5101              mov A,[_TIMEOUT+1]
 00D5 1105              sub A,5
 00D7 5100              mov A,[_TIMEOUT]
 00D9 3180              xor A,-128
 00DB 1980              sbb A,(0 ^ 0x80)
 00DD D00B              jnc L22
 00DF           X3:
 00DF 3D0000            cmp [X+0],0
 00E2 B006              jnz X4
 00E4 3D0100            cmp [X+1],0
 00E7 AFAD              jz L11
 00E9           X4:
 00E9           L22:
 00E9                   .dbline 167
 00E9           ;       
 00E9           ;       RX_TIMEOUT_Stop();
 00E9 10                push X
 00EA 7C0000            xcall _RX_TIMEOUT_Stop
 00ED 20                pop X
 00EE                   .dbline 168
 00EE           ;       TIMEOUT = 0;
 00EE 62D000            mov REG[0xd0],>_TIMEOUT
 00F1 550100            mov [_TIMEOUT+1],0
 00F4 550000            mov [_TIMEOUT],0
 00F7                   .dbline 169
 00F7           ;       RX_TIMEOUT_Start();
 00F7 10                push X
 00F8 7C0000            xcall _RX_TIMEOUT_Start
 00FB 20                pop X
 00FC                   .dbline 171
 00FC           ;       
 00FC           ;       return response;
 00FC 62D000            mov REG[0xd0],>__r0
 00FF 5201              mov A,[X+1]
 0101 5300              mov [__r1],A
 0103 5200              mov A,[X+0]
 0105 5300              mov [__r0],A
 0107                   .dbline -2
 0107           L7:
 0107 38FE              add SP,-2
 0109 20                pop X
 010A                   .dbline 0 ; func end
 010A 7F                ret
 010B                   .dbsym l response 0 I
 010B                   .dbsym l module_id -5 I
 010B                   .dbend
 010B                   .dbfunc e assignID _assignID fI
 010B           ;        success -> X+0
 010B           ;    assigned_ID -> X-5
 010B           _assignID::
 010B                   .dbline -1
 010B 10                push X
 010C 4F                mov X,SP
 010D 3802              add SP,2
 010F                   .dbline 175
 010F           ; }
 010F           ; 
 010F           ; int assignID(int assigned_ID)
 010F           ; {
 010F                   .dbline 176
 010F           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 010F 560100            mov [X+1],0
 0112 560000            mov [X+0],0
 0115                   .dbline 178
 0115           ;       
 0115           ;       configToggle(TX_MODE);  // Switch to TX mode.
 0115 5000              mov A,0
 0117 08                push A
 0118 08                push A
 0119 7C0AEB            xcall _configToggle
 011C 38FE              add SP,-2
 011E                   .dbline 181
 011E           ; 
 011E           ;       // Transmit the assignment.
 011E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 011E 10                push X
 011F 50FC              mov A,-4
 0121 7C0000            xcall _TRANSMIT_PutChar
 0124 20                pop X
 0125                   .dbline 182
 0125           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0125 10                push X
 0126 50FC              mov A,-4
 0128 7C0000            xcall _TRANSMIT_PutChar
 012B 20                pop X
 012C                   .dbline 183
 012C           ;       TRANSMIT_PutChar(MASTER_ID);
 012C 10                push X
 012D 5000              mov A,0
 012F 7C0000            xcall _TRANSMIT_PutChar
 0132 20                pop X
 0133                   .dbline 184
 0133           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0133 10                push X
 0134 50FB              mov A,-5
 0136 7C0000            xcall _TRANSMIT_PutChar
 0139 20                pop X
 013A                   .dbline 185
 013A           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 013A 10                push X
 013B 50C9              mov A,-55
 013D 7C0000            xcall _TRANSMIT_PutChar
 0140 20                pop X
 0141                   .dbline 186
 0141           ;       TRANSMIT_PutChar(assigned_ID);
 0141 62D000            mov REG[0xd0],>__r0
 0144 52FC              mov A,[X-4]
 0146 10                push X
 0147 7C0000            xcall _TRANSMIT_PutChar
 014A 20                pop X
 014B                   .dbline 187
 014B           ;       TRANSMIT_PutChar(END_TRANSMIT);
 014B 10                push X
 014C 50FD              mov A,-3
 014E 7C0000            xcall _TRANSMIT_PutChar
 0151 20                pop X
 0152                   .dbline 188
 0152           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0152 10                push X
 0153 50FD              mov A,-3
 0155 7C0000            xcall _TRANSMIT_PutChar
 0158 20                pop X
 0159           L24:
 0159                   .dbline 191
 0159           ;       
 0159           ;       // Wait for the transmission to finish.
 0159           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0159           L25:
 0159                   .dbline 191
 0159 10                push X
 015A 7C0000            xcall _TRANSMIT_bReadTxStatus
 015D 62D000            mov REG[0xd0],>__r0
 0160 20                pop X
 0161 5300              mov [__r0],A
 0163 470020            tst [__r0],32
 0166 AFF2              jz L24
 0168                   .dbline 193
 0168           ;       
 0168           ;       xmitWait();
 0168 7C0D96            xcall _xmitWait
 016B                   .dbline 195
 016B           ;       
 016B           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 016B 5000              mov A,0
 016D 08                push A
 016E 5001              mov A,1
 0170 08                push A
 0171 7C0AEB            xcall _configToggle
 0174 38FE              add SP,-2
 0176                   .dbline 197
 0176           ;       
 0176           ;       RX_TIMEOUT_Stop();
 0176 10                push X
 0177 7C0000            xcall _RX_TIMEOUT_Stop
 017A 20                pop X
 017B                   .dbline 198
 017B           ;       TIMEOUT = 0;
 017B 62D000            mov REG[0xd0],>_TIMEOUT
 017E 550100            mov [_TIMEOUT+1],0
 0181 550000            mov [_TIMEOUT],0
 0184                   .dbline 199
 0184           ;       RX_TIMEOUT_Start();
 0184 10                push X
 0185 7C0000            xcall _RX_TIMEOUT_Start
 0188 20                pop X
 0189 803C              xjmp L28
 018B           L27:
 018B                   .dbline 202
 018B           ;       
 018B           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 018B           ;       {
 018B                   .dbline 203
 018B           ;               if(validTransmission())
 018B 91C3              xcall _validTransmission
 018D 62D000            mov REG[0xd0],>__r0
 0190 3C0000            cmp [__r0],0
 0193 B006              jnz X5
 0195 3C0000            cmp [__r1],0
 0198 A02D              jz L30
 019A           X5:
 019A                   .dbline 204
 019A           ;               {
 019A                   .dbline 205
 019A           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 019A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 019D 3C00CA            cmp [_COMMAND_TYPE],-54
 01A0 B025              jnz L32
 01A2                   .dbline 206
 01A2           ;                       {
 01A2                   .dbline 208
 01A2           ;                               // If this is for me, check who it was from.
 01A2           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 01A2 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 01A5 3C0000            cmp [_COMMAND_DESTINATION],0
 01A8 B01D              jnz L34
 01AA                   .dbline 209
 01AA           ;                               {
 01AA                   .dbline 210
 01AA           ;                                       if(COMMAND_SOURCE == assigned_ID)
 01AA 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 01AD 5100              mov A,[_COMMAND_SOURCE]
 01AF 62D000            mov REG[0xd0],>__r0
 01B2 5300              mov [__r1],A
 01B4 5000              mov A,0
 01B6 3BFB              cmp A,[X-5]
 01B8 B00D              jnz L36
 01BA 5100              mov A,[__r1]
 01BC 3BFC              cmp A,[X-4]
 01BE B007              jnz L36
 01C0           X6:
 01C0                   .dbline 211
 01C0           ;                                       {
 01C0                   .dbline 212
 01C0           ;                                               success = 1;
 01C0 560101            mov [X+1],1
 01C3 560000            mov [X+0],0
 01C6                   .dbline 213
 01C6           ;                                       }
 01C6           L36:
 01C6                   .dbline 214
 01C6           ;                               }
 01C6           L34:
 01C6                   .dbline 215
 01C6           ;                       }
 01C6           L32:
 01C6                   .dbline 216
 01C6           ;               }
 01C6           L30:
 01C6                   .dbline 217
 01C6           ;       }
 01C6           L28:
 01C6                   .dbline 201
 01C6 62D000            mov REG[0xd0],>_TIMEOUT
 01C9 5101              mov A,[_TIMEOUT+1]
 01CB 1105              sub A,5
 01CD 5100              mov A,[_TIMEOUT]
 01CF 3180              xor A,-128
 01D1 1980              sbb A,(0 ^ 0x80)
 01D3 D00B              jnc L38
 01D5           X7:
 01D5 3D0000            cmp [X+0],0
 01D8 B006              jnz X8
 01DA 3D0100            cmp [X+1],0
 01DD AFAD              jz L27
 01DF           X8:
 01DF           L38:
 01DF                   .dbline 219
 01DF           ;       
 01DF           ;       RX_TIMEOUT_Stop();
 01DF 10                push X
 01E0 7C0000            xcall _RX_TIMEOUT_Stop
 01E3 20                pop X
 01E4                   .dbline 220
 01E4           ;       TIMEOUT = 0;
 01E4 62D000            mov REG[0xd0],>_TIMEOUT
 01E7 550100            mov [_TIMEOUT+1],0
 01EA 550000            mov [_TIMEOUT],0
 01ED                   .dbline 221
 01ED           ;       RX_TIMEOUT_Start();
 01ED 10                push X
 01EE 7C0000            xcall _RX_TIMEOUT_Start
 01F1 20                pop X
 01F2                   .dbline 223
 01F2           ;       
 01F2           ;       return success;
 01F2 62D000            mov REG[0xd0],>__r0
 01F5 5201              mov A,[X+1]
 01F7 5300              mov [__r1],A
 01F9 5200              mov A,[X+0]
 01FB 5300              mov [__r0],A
 01FD                   .dbline -2
 01FD           L23:
 01FD 38FE              add SP,-2
 01FF 20                pop X
 0200                   .dbline 0 ; func end
 0200 7F                ret
 0201                   .dbsym l success 0 I
 0201                   .dbsym l assigned_ID -5 I
 0201                   .dbend
 0201                   .dbfunc e clearConfig _clearConfig fI
 0201           ;       response -> X+0
 0201           ;      module_id -> X-5
 0201           _clearConfig::
 0201                   .dbline -1
 0201 10                push X
 0202 4F                mov X,SP
 0203 3802              add SP,2
 0205                   .dbline 227
 0205           ; }
 0205           ; 
 0205           ; int clearConfig(int module_id)
 0205           ; {
 0205                   .dbline 228
 0205           ;       int response = 0;
 0205 560100            mov [X+1],0
 0208 560000            mov [X+0],0
 020B                   .dbline 230
 020B           ;       
 020B           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 020B 5000              mov A,0
 020D 08                push A
 020E 08                push A
 020F 7C0AEB            xcall _configToggle
 0212 38FE              add SP,-2
 0214                   .dbline 233
 0214           ;                       
 0214           ;       // Transmit a hello.
 0214           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0214 10                push X
 0215 50FC              mov A,-4
 0217 7C0000            xcall _TRANSMIT_PutChar
 021A 20                pop X
 021B                   .dbline 234
 021B           ;       TRANSMIT_PutChar(START_TRANSMIT);
 021B 10                push X
 021C 50FC              mov A,-4
 021E 7C0000            xcall _TRANSMIT_PutChar
 0221 20                pop X
 0222                   .dbline 235
 0222           ;       TRANSMIT_PutChar(MASTER_ID);
 0222 10                push X
 0223 5000              mov A,0
 0225 7C0000            xcall _TRANSMIT_PutChar
 0228 20                pop X
 0229                   .dbline 236
 0229           ;       TRANSMIT_PutChar(module_id);
 0229 62D000            mov REG[0xd0],>__r0
 022C 52FC              mov A,[X-4]
 022E 10                push X
 022F 7C0000            xcall _TRANSMIT_PutChar
 0232 20                pop X
 0233                   .dbline 237
 0233           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 0233 10                push X
 0234 50CC              mov A,-52
 0236 7C0000            xcall _TRANSMIT_PutChar
 0239 20                pop X
 023A                   .dbline 238
 023A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 023A 10                push X
 023B 50FD              mov A,-3
 023D 7C0000            xcall _TRANSMIT_PutChar
 0240 20                pop X
 0241                   .dbline 239
 0241           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0241 10                push X
 0242 50FD              mov A,-3
 0244 7C0000            xcall _TRANSMIT_PutChar
 0247 20                pop X
 0248           L40:
 0248                   .dbline 242
 0248           ;       
 0248           ;       // Wait for the transmission to finish.
 0248           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0248           L41:
 0248                   .dbline 242
 0248 10                push X
 0249 7C0000            xcall _TRANSMIT_bReadTxStatus
 024C 62D000            mov REG[0xd0],>__r0
 024F 20                pop X
 0250 5300              mov [__r0],A
 0252 470020            tst [__r0],32
 0255 AFF2              jz L40
 0257                   .dbline 244
 0257           ;       
 0257           ;       xmitWait();
 0257 7C0D96            xcall _xmitWait
 025A                   .dbline 246
 025A           ;       
 025A           ;       configToggle(RX_MODE);  // Listen for the response.
 025A 5000              mov A,0
 025C 08                push A
 025D 5001              mov A,1
 025F 08                push A
 0260 7C0AEB            xcall _configToggle
 0263 38FE              add SP,-2
 0265                   .dbline 248
 0265           ;       
 0265           ;       if(module_id != BROADCAST)
 0265 3DFB00            cmp [X-5],0
 0268 B006              jnz X9
 026A 3DFCFE            cmp [X-4],-2
 026D A07D              jz L43
 026F           X9:
 026F                   .dbline 249
 026F           ;       {
 026F                   .dbline 250
 026F           ;               RX_TIMEOUT_Stop();
 026F 10                push X
 0270 7C0000            xcall _RX_TIMEOUT_Stop
 0273 20                pop X
 0274                   .dbline 251
 0274           ;               TIMEOUT = 0;
 0274 62D000            mov REG[0xd0],>_TIMEOUT
 0277 550100            mov [_TIMEOUT+1],0
 027A 550000            mov [_TIMEOUT],0
 027D                   .dbline 252
 027D           ;               RX_TIMEOUT_Start();
 027D 10                push X
 027E 7C0000            xcall _RX_TIMEOUT_Start
 0281 20                pop X
 0282 803C              xjmp L46
 0284           L45:
 0284                   .dbline 255
 0284           ;               
 0284           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 0284           ;               {
 0284                   .dbline 256
 0284           ;                       if(validTransmission())
 0284 90CA              xcall _validTransmission
 0286 62D000            mov REG[0xd0],>__r0
 0289 3C0000            cmp [__r0],0
 028C B006              jnz X10
 028E 3C0000            cmp [__r1],0
 0291 A02D              jz L48
 0293           X10:
 0293                   .dbline 257
 0293           ;                       {
 0293                   .dbline 258
 0293           ;                               if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 0293 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0296 3C00CD            cmp [_COMMAND_TYPE],-51
 0299 B025              jnz L50
 029B                   .dbline 259
 029B           ;                               {
 029B                   .dbline 261
 029B           ;                                       // If this is for me, check who it was from.
 029B           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 029B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 029E 3C0000            cmp [_COMMAND_DESTINATION],0
 02A1 B01D              jnz L52
 02A3                   .dbline 262
 02A3           ;                                       {
 02A3                   .dbline 263
 02A3           ;                                               if(COMMAND_SOURCE == module_id)
 02A3 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02A6 5100              mov A,[_COMMAND_SOURCE]
 02A8 62D000            mov REG[0xd0],>__r0
 02AB 5300              mov [__r1],A
 02AD 5000              mov A,0
 02AF 3BFB              cmp A,[X-5]
 02B1 B00D              jnz L54
 02B3 5100              mov A,[__r1]
 02B5 3BFC              cmp A,[X-4]
 02B7 B007              jnz L54
 02B9           X11:
 02B9                   .dbline 264
 02B9           ;                                               {
 02B9                   .dbline 265
 02B9           ;                                                       response = 1;
 02B9 560101            mov [X+1],1
 02BC 560000            mov [X+0],0
 02BF                   .dbline 266
 02BF           ;                                               }
 02BF           L54:
 02BF                   .dbline 267
 02BF           ;                                       }
 02BF           L52:
 02BF                   .dbline 268
 02BF           ;                               }
 02BF           L50:
 02BF                   .dbline 269
 02BF           ;                       }
 02BF           L48:
 02BF                   .dbline 270
 02BF           ;               }
 02BF           L46:
 02BF                   .dbline 254
 02BF 62D000            mov REG[0xd0],>_TIMEOUT
 02C2 5101              mov A,[_TIMEOUT+1]
 02C4 1105              sub A,5
 02C6 5100              mov A,[_TIMEOUT]
 02C8 3180              xor A,-128
 02CA 1980              sbb A,(0 ^ 0x80)
 02CC D00B              jnc L56
 02CE           X12:
 02CE 3D0000            cmp [X+0],0
 02D1 B006              jnz X13
 02D3 3D0100            cmp [X+1],0
 02D6 AFAD              jz L45
 02D8           X13:
 02D8           L56:
 02D8                   .dbline 272
 02D8           ;               
 02D8           ;               RX_TIMEOUT_Stop();
 02D8 10                push X
 02D9 7C0000            xcall _RX_TIMEOUT_Stop
 02DC 20                pop X
 02DD                   .dbline 273
 02DD           ;               TIMEOUT = 0;
 02DD 62D000            mov REG[0xd0],>_TIMEOUT
 02E0 550100            mov [_TIMEOUT+1],0
 02E3 550000            mov [_TIMEOUT],0
 02E6                   .dbline 274
 02E6           ;               RX_TIMEOUT_Start();
 02E6 10                push X
 02E7 7C0000            xcall _RX_TIMEOUT_Start
 02EA 20                pop X
 02EB                   .dbline 275
 02EB           ;       }
 02EB           L43:
 02EB                   .dbline 277
 02EB           ;       
 02EB           ;       return response;
 02EB 62D000            mov REG[0xd0],>__r0
 02EE 5201              mov A,[X+1]
 02F0 5300              mov [__r1],A
 02F2 5200              mov A,[X+0]
 02F4 5300              mov [__r0],A
 02F6                   .dbline -2
 02F6           L39:
 02F6 38FE              add SP,-2
 02F8 20                pop X
 02F9                   .dbline 0 ; func end
 02F9 7F                ret
 02FA                   .dbsym l response 0 I
 02FA                   .dbsym l module_id -5 I
 02FA                   .dbend
 02FA                   .dbfunc e sayHello _sayHello fV
 02FA           _sayHello::
 02FA                   .dbline -1
 02FA                   .dbline 282
 02FA           ; }
 02FA           ; 
 02FA           ; // This function transmits a hello message.
 02FA           ; void sayHello(void)
 02FA           ; {
 02FA                   .dbline 283
 02FA           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 02FA 5000              mov A,0
 02FC 08                push A
 02FD 08                push A
 02FE 97EB              xcall _configToggle
 0300 38FE              add SP,-2
 0302                   .dbline 286
 0302           ;                       
 0302           ;       // Transmit a hello.
 0302           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0302 10                push X
 0303 50FC              mov A,-4
 0305 7C0000            xcall _TRANSMIT_PutChar
 0308 20                pop X
 0309                   .dbline 287
 0309           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0309 10                push X
 030A 50FC              mov A,-4
 030C 7C0000            xcall _TRANSMIT_PutChar
 030F 20                pop X
 0310                   .dbline 288
 0310           ;       TRANSMIT_PutChar(MASTER_ID);
 0310 10                push X
 0311 5000              mov A,0
 0313 7C0000            xcall _TRANSMIT_PutChar
 0316 20                pop X
 0317                   .dbline 289
 0317           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0317 10                push X
 0318 50FB              mov A,-5
 031A 7C0000            xcall _TRANSMIT_PutChar
 031D 20                pop X
 031E                   .dbline 290
 031E           ;       TRANSMIT_PutChar(HELLO_BYTE);
 031E 10                push X
 031F 50C8              mov A,-56
 0321 7C0000            xcall _TRANSMIT_PutChar
 0324 20                pop X
 0325                   .dbline 291
 0325           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0325 10                push X
 0326 50FD              mov A,-3
 0328 7C0000            xcall _TRANSMIT_PutChar
 032B 20                pop X
 032C                   .dbline 292
 032C           ;       TRANSMIT_PutChar(END_TRANSMIT);
 032C 10                push X
 032D 50FD              mov A,-3
 032F 7C0000            xcall _TRANSMIT_PutChar
 0332 20                pop X
 0333           L58:
 0333                   .dbline 295
 0333           ;       
 0333           ;       // Wait for the transmission to finish.
 0333           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0333           L59:
 0333                   .dbline 295
 0333 10                push X
 0334 7C0000            xcall _TRANSMIT_bReadTxStatus
 0337 62D000            mov REG[0xd0],>__r0
 033A 20                pop X
 033B 5300              mov [__r0],A
 033D 470020            tst [__r0],32
 0340 AFF2              jz L58
 0342                   .dbline 297
 0342           ;       
 0342           ;       xmitWait();
 0342 7C0D96            xcall _xmitWait
 0345                   .dbline 299
 0345           ;       
 0345           ;       configToggle(RX_MODE);                          // Listen for the response.
 0345 5000              mov A,0
 0347 08                push A
 0348 5001              mov A,1
 034A 08                push A
 034B 979E              xcall _configToggle
 034D 38FE              add SP,-2
 034F                   .dbline -2
 034F           L57:
 034F                   .dbline 0 ; func end
 034F 7F                ret
 0350                   .dbend
 0350                   .dbfunc e validTransmission _validTransmission fI
 0350           ; valid_transmit -> X+3
 0350           ;              i -> X+1
 0350           ;       tempByte -> X+0
 0350           _validTransmission::
 0350                   .dbline -1
 0350 10                push X
 0351 4F                mov X,SP
 0352 3805              add SP,5
 0354                   .dbline 304
 0354           ; }
 0354           ; 
 0354           ; // This function returns whether or not a valid transmission has been received.
 0354           ; int validTransmission(void)
 0354           ; {
 0354                   .dbline 305
 0354           ;       int valid_transmit = 0;
 0354 560400            mov [X+4],0
 0357 560300            mov [X+3],0
 035A                   .dbline 306
 035A           ;       int i = 0;
 035A 560200            mov [X+2],0
 035D 560100            mov [X+1],0
 0360                   .dbline 307
 0360           ;       char tempByte = 0;
 0360 560000            mov [X+0],0
 0363 80C2              xjmp L63
 0365           L62:
 0365                   .dbline 310
 0365           ;       
 0365           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0365           ;       {
 0365                   .dbline 311
 0365           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0365 10                push X
 0366 7C0000            xcall _RECEIVE_cReadChar
 0369 62D000            mov REG[0xd0],>__r0
 036C 20                pop X
 036D 39FC              cmp A,-4
 036F B0B6              jnz L65
 0371                   .dbline 312
 0371           ;               {
 0371 80A5              xjmp L68
 0373           L67:
 0373                   .dbline 314
 0373           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0373           ;                       {
 0373                   .dbline 315
 0373           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0373 10                push X
 0374 7C0000            xcall _RECEIVE_cReadChar
 0377 62D000            mov REG[0xd0],>__r0
 037A 20                pop X
 037B 39FC              cmp A,-4
 037D B099              jnz L70
 037F                   .dbline 316
 037F           ;                               {
 037F 8088              xjmp L73
 0381           L72:
 0381                   .dbline 318
 0381           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0381           ;                                       {
 0381                   .dbline 319
 0381           ;                                               if(tempByte = RECEIVE_cReadChar())
 0381 10                push X
 0382 7C0000            xcall _RECEIVE_cReadChar
 0385 20                pop X
 0386 5400              mov [X+0],A
 0388 3900              cmp A,0
 038A A07D              jz L75
 038C                   .dbline 320
 038C           ;                                               {
 038C                   .dbline 321
 038C           ;                                                       COMMAND_SOURCE = tempByte;
 038C 5200              mov A,[X+0]
 038E 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0391 5300              mov [_COMMAND_SOURCE],A
 0393 8065              xjmp L78
 0395           L77:
 0395                   .dbline 324
 0395           ;                                                       
 0395           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0395           ;                                                       {
 0395                   .dbline 325
 0395           ;                                                               if(tempByte = RECEIVE_cReadChar())
 0395 10                push X
 0396 7C0000            xcall _RECEIVE_cReadChar
 0399 62D000            mov REG[0xd0],>__r0
 039C 20                pop X
 039D 5400              mov [X+0],A
 039F 3900              cmp A,0
 03A1 A057              jz L80
 03A3                   .dbline 326
 03A3           ;                                                               {
 03A3                   .dbline 327
 03A3           ;                                                                       if(tempByte >= HELLO_BYTE)
 03A3 3D00C8            cmp [X+0],-56
 03A6 C052              jc L82
 03A8           X14:
 03A8                   .dbline 328
 03A8           ;                                                                       {
 03A8                   .dbline 329
 03A8           ;                                                                               COMMAND_TYPE = tempByte;
 03A8 5200              mov A,[X+0]
 03AA 62D000            mov REG[0xd0],>_COMMAND_TYPE
 03AD 5300              mov [_COMMAND_TYPE],A
 03AF 803A              xjmp L85
 03B1           L84:
 03B1                   .dbline 332
 03B1           ;                                                                               
 03B1           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 03B1           ;                                                                               {
 03B1                   .dbline 333
 03B1           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 03B1 10                push X
 03B2 7C0000            xcall _RECEIVE_cReadChar
 03B5 62D000            mov REG[0xd0],>__r0
 03B8 20                pop X
 03B9 5400              mov [X+0],A
 03BB 3900              cmp A,0
 03BD A02C              jz L87
 03BF                   .dbline 334
 03BF           ;                                                                                       {
 03BF                   .dbline 335
 03BF           ;                                                                                               if(tempByte != END_TRANSMIT)
 03BF 3D00FD            cmp [X+0],-3
 03C2 A018              jz L89
 03C4                   .dbline 336
 03C4           ;                                                                                               {
 03C4                   .dbline 337
 03C4           ;                                                                                                       PARAM[i] = tempByte;
 03C4 5202              mov A,[X+2]
 03C6 0100              add A,<_PARAM
 03C8 5300              mov [__r1],A
 03CA 5201              mov A,[X+1]
 03CC 0900              adc A,>_PARAM
 03CE 60D5              mov REG[0xd5],A
 03D0 5200              mov A,[X+0]
 03D2 3F00              mvi [__r1],A
 03D4                   .dbline 338
 03D4           ;                                                                                                       i++;
 03D4 7702              inc [X+2]
 03D6 0F0100            adc [X+1],0
 03D9                   .dbline 339
 03D9           ;                                                                                               }
 03D9 8010              xjmp L90
 03DB           L89:
 03DB                   .dbline 341
 03DB           ;                                                                                               else
 03DB           ;                                                                                               {
 03DB                   .dbline 342
 03DB           ;                                                                                                       valid_transmit = 1;
 03DB 560401            mov [X+4],1
 03DE 560300            mov [X+3],0
 03E1                   .dbline 343
 03E1           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 03E1 62D000            mov REG[0xd0],>_TIMEOUT
 03E4 550105            mov [_TIMEOUT+1],5
 03E7 550000            mov [_TIMEOUT],0
 03EA                   .dbline 344
 03EA           ;                                                                                               }
 03EA           L90:
 03EA                   .dbline 345
 03EA           ;                                                                                       }
 03EA           L87:
 03EA                   .dbline 346
 03EA           ;                                                                               }
 03EA           L85:
 03EA                   .dbline 331
 03EA 62D000            mov REG[0xd0],>_TIMEOUT
 03ED 5101              mov A,[_TIMEOUT+1]
 03EF 1105              sub A,5
 03F1 5100              mov A,[_TIMEOUT]
 03F3 3180              xor A,-128
 03F5 1980              sbb A,(0 ^ 0x80)
 03F7 CFB9              jc L84
 03F9           X15:
 03F9                   .dbline 347
 03F9           ;                                                                       }
 03F9           L82:
 03F9                   .dbline 348
 03F9           ;                                                               }
 03F9           L80:
 03F9                   .dbline 349
 03F9           ;                                                       }
 03F9           L78:
 03F9                   .dbline 323
 03F9 62D000            mov REG[0xd0],>_TIMEOUT
 03FC 5101              mov A,[_TIMEOUT+1]
 03FE 1105              sub A,5
 0400 5100              mov A,[_TIMEOUT]
 0402 3180              xor A,-128
 0404 1980              sbb A,(0 ^ 0x80)
 0406 CF8E              jc L77
 0408           X16:
 0408                   .dbline 350
 0408           ;                                               }
 0408           L75:
 0408                   .dbline 351
 0408           ;                                       }
 0408           L73:
 0408                   .dbline 317
 0408 62D000            mov REG[0xd0],>_TIMEOUT
 040B 5101              mov A,[_TIMEOUT+1]
 040D 1105              sub A,5
 040F 5100              mov A,[_TIMEOUT]
 0411 3180              xor A,-128
 0413 1980              sbb A,(0 ^ 0x80)
 0415 CF6B              jc L72
 0417           X17:
 0417                   .dbline 352
 0417           ;                               }
 0417           L70:
 0417                   .dbline 353
 0417           ;                       }
 0417           L68:
 0417                   .dbline 313
 0417 62D000            mov REG[0xd0],>_TIMEOUT
 041A 5101              mov A,[_TIMEOUT+1]
 041C 1105              sub A,5
 041E 5100              mov A,[_TIMEOUT]
 0420 3180              xor A,-128
 0422 1980              sbb A,(0 ^ 0x80)
 0424 CF4E              jc L67
 0426           X18:
 0426                   .dbline 354
 0426           ;               }
 0426           L65:
 0426                   .dbline 355
 0426           ;       }
 0426           L63:
 0426                   .dbline 309
 0426 62D000            mov REG[0xd0],>_TIMEOUT
 0429 5101              mov A,[_TIMEOUT+1]
 042B 1105              sub A,5
 042D 5100              mov A,[_TIMEOUT]
 042F 3180              xor A,-128
 0431 1980              sbb A,(0 ^ 0x80)
 0433 CF31              jc L62
 0435           X19:
 0435                   .dbline 357
 0435           ;       
 0435           ;       return valid_transmit;
 0435 62D000            mov REG[0xd0],>__r0
 0438 5204              mov A,[X+4]
 043A 5300              mov [__r1],A
 043C 5203              mov A,[X+3]
 043E 5300              mov [__r0],A
 0440                   .dbline -2
 0440           L61:
 0440 38FB              add SP,-5
 0442 20                pop X
 0443                   .dbline 0 ; func end
 0443 7F                ret
 0444                   .dbsym l valid_transmit 3 I
 0444                   .dbsym l i 1 I
 0444                   .dbsym l tempByte 0 c
 0444                   .dbend
 0444                   .dbfunc e decodeTransmission _decodeTransmission fV
 0444           ;       tempByte -> X+7
 0444           ;          angle -> X+5
 0444           ;             ID -> X+4
 0444           ;          total -> X+2
 0444           ;          param -> X+0
 0444           _decodeTransmission::
 0444                   .dbline -1
 0444 10                push X
 0445 4F                mov X,SP
 0446 3808              add SP,8
 0448                   .dbline 362
 0448           ; }
 0448           ; 
 0448           ; // This function decodes the transmission and takes the correct action.
 0448           ; void decodeTransmission(void)
 0448           ; {
 0448                   .dbline 367
 0448           ;       char* param;
 0448           ;       char ID;
 0448           ;       char tempByte;
 0448           ;       char angle[2];
 0448           ;       int total = 0;
 0448 560300            mov [X+3],0
 044B 560200            mov [X+2],0
 044E                   .dbline 369
 044E           ;       
 044E           ;       if(param = COMP_SERIAL_szGetParam())
 044E 10                push X
 044F 7C0000            xcall _COMP_SERIAL_szGetParam
 0452 62D000            mov REG[0xd0],>__r0
 0455 5300              mov [__r0],A
 0457 5A00              mov [__r1],X
 0459 20                pop X
 045A 5100              mov A,[__r1]
 045C 5401              mov [X+1],A
 045E 5100              mov A,[__r0]
 0460 5400              mov [X+0],A
 0462 3C0000            cmp [__r0],0
 0465 B006              jnz X20
 0467 3C0000            cmp [__r1],0
 046A A506              jz L92
 046C           X20:
 046C                   .dbline 370
 046C           ;       {
 046C                   .dbline 371
 046C           ;               if((param[0] == 'n') || (param[0] == 'N'))
 046C 62D000            mov REG[0xd0],>__r0
 046F 5201              mov A,[X+1]
 0471 5300              mov [__r1],A
 0473 5200              mov A,[X+0]
 0475 60D4              mov REG[0xd4],A
 0477 3E00              mvi A,[__r1]
 0479 5300              mov [__r1],A
 047B 550000            mov [__r0],0
 047E 3C0000            cmp [__r0],0
 0481 B005              jnz X21
 0483 396E              cmp A,110
 0485 A00E              jz L96
 0487           X21:
 0487 62D000            mov REG[0xd0],>__r0
 048A 3C0000            cmp [__r0],0
 048D B03A              jnz L94
 048F 3C004E            cmp [__r1],78
 0492 B035              jnz L94
 0494           X22:
 0494           L96:
 0494                   .dbline 372
 0494           ;               {
 0494                   .dbline 373
 0494           ;                       COMP_SERIAL_CmdReset();
 0494 10                push X
 0495 7C0000            xcall _COMP_SERIAL_CmdReset
 0498 20                pop X
 0499                   .dbline 374
 0499           ;                       itoa(param,NUM_MODULES,10);
 0499 5000              mov A,0
 049B 08                push A
 049C 500A              mov A,10
 049E 08                push A
 049F 62D000            mov REG[0xd0],>_NUM_MODULES
 04A2 5100              mov A,[_NUM_MODULES]
 04A4 08                push A
 04A5 5101              mov A,[_NUM_MODULES+1]
 04A7 08                push A
 04A8 5200              mov A,[X+0]
 04AA 08                push A
 04AB 5201              mov A,[X+1]
 04AD 08                push A
 04AE 7C0000            xcall _itoa
 04B1 38FA              add SP,-6
 04B3                   .dbline 375
 04B3           ;                       COMP_SERIAL_PutString(param);
 04B3 10                push X
 04B4 5200              mov A,[X+0]
 04B6 08                push A
 04B7 5201              mov A,[X+1]
 04B9 5C                mov X,A
 04BA 18                pop A
 04BB 7C0000            xcall _COMP_SERIAL_PutString
 04BE 20                pop X
 04BF                   .dbline 376
 04BF           ;                       COMP_SERIAL_PutChar('\n');
 04BF 10                push X
 04C0 500A              mov A,10
 04C2 7C0000            xcall _COMP_SERIAL_PutChar
 04C5 20                pop X
 04C6                   .dbline 377
 04C6           ;               }
 04C6 84AA              xjmp L95
 04C8           L94:
 04C8                   .dbline 378
 04C8           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04C8 62D000            mov REG[0xd0],>__r0
 04CB 5201              mov A,[X+1]
 04CD 5300              mov [__r1],A
 04CF 5200              mov A,[X+0]
 04D1 60D4              mov REG[0xd4],A
 04D3 3E00              mvi A,[__r1]
 04D5 5300              mov [__r1],A
 04D7 550000            mov [__r0],0
 04DA 3C0000            cmp [__r0],0
 04DD B005              jnz X23
 04DF 3977              cmp A,119
 04E1 A00E              jz L99
 04E3           X23:
 04E3 62D000            mov REG[0xd0],>__r0
 04E6 3C0000            cmp [__r0],0
 04E9 B16B              jnz L97
 04EB 3C0057            cmp [__r1],87
 04EE B166              jnz L97
 04F0           X24:
 04F0           L99:
 04F0                   .dbline 379
 04F0           ;               {
 04F0                   .dbline 380
 04F0           ;                       if(param = COMP_SERIAL_szGetParam())
 04F0 10                push X
 04F1 7C0000            xcall _COMP_SERIAL_szGetParam
 04F4 62D000            mov REG[0xd0],>__r0
 04F7 5300              mov [__r0],A
 04F9 5A00              mov [__r1],X
 04FB 20                pop X
 04FC 5100              mov A,[__r1]
 04FE 5401              mov [X+1],A
 0500 5100              mov A,[__r0]
 0502 5400              mov [X+0],A
 0504 3C0000            cmp [__r0],0
 0507 B006              jnz X25
 0509 3C0000            cmp [__r1],0
 050C A464              jz L98
 050E           X25:
 050E                   .dbline 381
 050E           ;                       {
 050E                   .dbline 382
 050E           ;                               ID = atoi(param);
 050E 5200              mov A,[X+0]
 0510 08                push A
 0511 5201              mov A,[X+1]
 0513 08                push A
 0514 7C0000            xcall _atoi
 0517 38FE              add SP,-2
 0519 62D000            mov REG[0xd0],>__r0
 051C 5100              mov A,[__r1]
 051E 5404              mov [X+4],A
 0520                   .dbline 383
 0520           ;                               if(param = COMP_SERIAL_szGetParam())
 0520 10                push X
 0521 7C0000            xcall _COMP_SERIAL_szGetParam
 0524 62D000            mov REG[0xd0],>__r0
 0527 5300              mov [__r0],A
 0529 5A00              mov [__r1],X
 052B 20                pop X
 052C 5100              mov A,[__r1]
 052E 5401              mov [X+1],A
 0530 5100              mov A,[__r0]
 0532 5400              mov [X+0],A
 0534 3C0000            cmp [__r0],0
 0537 B006              jnz X26
 0539 3C0000            cmp [__r1],0
 053C A434              jz L98
 053E           X26:
 053E                   .dbline 384
 053E           ;                               {
 053E                   .dbline 385
 053E           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 053E 62D000            mov REG[0xd0],>__r0
 0541 5201              mov A,[X+1]
 0543 5300              mov [__r1],A
 0545 5200              mov A,[X+0]
 0547 60D4              mov REG[0xd4],A
 0549 3E00              mvi A,[__r1]
 054B 5300              mov [__r1],A
 054D 550000            mov [__r0],0
 0550 3C0000            cmp [__r0],0
 0553 B005              jnz X27
 0555 3961              cmp A,97
 0557 A00E              jz L106
 0559           X27:
 0559 62D000            mov REG[0xd0],>__r0
 055C 3C0000            cmp [__r0],0
 055F B089              jnz L104
 0561 3C0041            cmp [__r1],65
 0564 B084              jnz L104
 0566           X28:
 0566           L106:
 0566                   .dbline 386
 0566           ;                                       {
 0566                   .dbline 387
 0566           ;                                               if(param = COMP_SERIAL_szGetParam())
 0566 10                push X
 0567 7C0000            xcall _COMP_SERIAL_szGetParam
 056A 62D000            mov REG[0xd0],>__r0
 056D 5300              mov [__r0],A
 056F 5A00              mov [__r1],X
 0571 20                pop X
 0572 5100              mov A,[__r1]
 0574 5401              mov [X+1],A
 0576 5100              mov A,[__r0]
 0578 5400              mov [X+0],A
 057A 3C0000            cmp [__r0],0
 057D B006              jnz X29
 057F 3C0000            cmp [__r1],0
 0582 A3EE              jz L98
 0584           X29:
 0584                   .dbline 388
 0584           ;                                               {
 0584                   .dbline 389
 0584           ;                                                       COMP_SERIAL_CmdReset();
 0584 10                push X
 0585 7C0000            xcall _COMP_SERIAL_CmdReset
 0588 20                pop X
 0589                   .dbline 390
 0589           ;                                                       total = atoi(param);
 0589 5200              mov A,[X+0]
 058B 08                push A
 058C 5201              mov A,[X+1]
 058E 08                push A
 058F 7C0000            xcall _atoi
 0592 38FE              add SP,-2
 0594 62D000            mov REG[0xd0],>__r0
 0597 5100              mov A,[__r1]
 0599 5403              mov [X+3],A
 059B 5100              mov A,[__r0]
 059D 5402              mov [X+2],A
 059F                   .dbline 391
 059F           ;                                                       angle[0] = total%256;
 059F 5001              mov A,1
 05A1 08                push A
 05A2 5000              mov A,0
 05A4 08                push A
 05A5 5202              mov A,[X+2]
 05A7 08                push A
 05A8 5203              mov A,[X+3]
 05AA 08                push A
 05AB 7C0000            xcall __divmod_16X16_16
 05AE 38FE              add SP,-2
 05B0 18                pop A
 05B1 5300              mov [__r1],A
 05B3 18                pop A
 05B4 5100              mov A,[__r1]
 05B6 5405              mov [X+5],A
 05B8                   .dbline 392
 05B8           ;                                                       angle[1] = total/256;
 05B8 5001              mov A,1
 05BA 08                push A
 05BB 5000              mov A,0
 05BD 08                push A
 05BE 5202              mov A,[X+2]
 05C0 08                push A
 05C1 5203              mov A,[X+3]
 05C3 08                push A
 05C4 7C0000            xcall __divmod_16X16_16
 05C7 18                pop A
 05C8 5300              mov [__r1],A
 05CA 18                pop A
 05CB 38FE              add SP,-2
 05CD 5100              mov A,[__r1]
 05CF 5406              mov [X+6],A
 05D1                   .dbline 393
 05D1           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05D1 5206              mov A,[X+6]
 05D3 08                push A
 05D4 5205              mov A,[X+5]
 05D6 08                push A
 05D7 501E              mov A,30
 05D9 08                push A
 05DA 5003              mov A,3
 05DC 08                push A
 05DD 5005              mov A,5
 05DF 08                push A
 05E0 5204              mov A,[X+4]
 05E2 08                push A
 05E3 9455              xcall _longServoInstruction
 05E5 38FA              add SP,-6
 05E7                   .dbline 394
 05E7           ;                                               }
 05E7                   .dbline 395
 05E7           ;                                       }
 05E7 8389              xjmp L98
 05E9           L104:
 05E9                   .dbline 396
 05E9           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 05E9 62D000            mov REG[0xd0],>__r0
 05EC 5201              mov A,[X+1]
 05EE 5300              mov [__r1],A
 05F0 5200              mov A,[X+0]
 05F2 60D4              mov REG[0xd4],A
 05F4 3E00              mvi A,[__r1]
 05F6 5300              mov [__r1],A
 05F8 550000            mov [__r0],0
 05FB 3C0000            cmp [__r0],0
 05FE B005              jnz X30
 0600 3970              cmp A,112
 0602 A00E              jz L113
 0604           X30:
 0604 62D000            mov REG[0xd0],>__r0
 0607 3C0000            cmp [__r0],0
 060A B366              jnz L98
 060C 3C0050            cmp [__r1],80
 060F B361              jnz L98
 0611           X31:
 0611           L113:
 0611                   .dbline 397
 0611           ;                                       {
 0611                   .dbline 398
 0611           ;                                               if(param = COMP_SERIAL_szGetParam())
 0611 10                push X
 0612 7C0000            xcall _COMP_SERIAL_szGetParam
 0615 62D000            mov REG[0xd0],>__r0
 0618 5300              mov [__r0],A
 061A 5A00              mov [__r1],X
 061C 20                pop X
 061D 5100              mov A,[__r1]
 061F 5401              mov [X+1],A
 0621 5100              mov A,[__r0]
 0623 5400              mov [X+0],A
 0625 3C0000            cmp [__r0],0
 0628 B006              jnz X32
 062A 3C0000            cmp [__r1],0
 062D A343              jz L98
 062F           X32:
 062F                   .dbline 399
 062F           ;                                               {
 062F                   .dbline 400
 062F           ;                                                       COMP_SERIAL_CmdReset();
 062F 10                push X
 0630 7C0000            xcall _COMP_SERIAL_CmdReset
 0633 20                pop X
 0634                   .dbline 401
 0634           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0634 5200              mov A,[X+0]
 0636 08                push A
 0637 5201              mov A,[X+1]
 0639 08                push A
 063A 7C0000            xcall _atoi
 063D 62D000            mov REG[0xd0],>__r0
 0640 5100              mov A,[__r1]
 0642 08                push A
 0643 5018              mov A,24
 0645 08                push A
 0646 5003              mov A,3
 0648 08                push A
 0649 5004              mov A,4
 064B 08                push A
 064C 5204              mov A,[X+4]
 064E 08                push A
 064F 9346              xcall _servoInstruction
 0651 38F9              add SP,-7
 0653                   .dbline 402
 0653           ;                                               }
 0653                   .dbline 403
 0653           ;                                       }
 0653                   .dbline 404
 0653           ;                               }
 0653                   .dbline 405
 0653           ;                       }
 0653                   .dbline 406
 0653           ;               }
 0653 831D              xjmp L98
 0655           L97:
 0655                   .dbline 407
 0655           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 0655 62D000            mov REG[0xd0],>__r0
 0658 5201              mov A,[X+1]
 065A 5300              mov [__r1],A
 065C 5200              mov A,[X+0]
 065E 60D4              mov REG[0xd4],A
 0660 3E00              mvi A,[__r1]
 0662 5300              mov [__r1],A
 0664 550000            mov [__r0],0
 0667 3C0000            cmp [__r0],0
 066A B005              jnz X33
 066C 3972              cmp A,114
 066E A00E              jz L118
 0670           X33:
 0670 62D000            mov REG[0xd0],>__r0
 0673 3C0000            cmp [__r0],0
 0676 B2FA              jnz L116
 0678 3C0052            cmp [__r1],82
 067B B2F5              jnz L116
 067D           X34:
 067D           L118:
 067D                   .dbline 408
 067D           ;               {                       
 067D                   .dbline 409
 067D           ;                       if(param = COMP_SERIAL_szGetParam())
 067D 10                push X
 067E 7C0000            xcall _COMP_SERIAL_szGetParam
 0681 62D000            mov REG[0xd0],>__r0
 0684 5300              mov [__r0],A
 0686 5A00              mov [__r1],X
 0688 20                pop X
 0689 5100              mov A,[__r1]
 068B 5401              mov [X+1],A
 068D 5100              mov A,[__r0]
 068F 5400              mov [X+0],A
 0691 3C0000            cmp [__r0],0
 0694 B006              jnz X35
 0696 3C0000            cmp [__r1],0
 0699 A2D7              jz L119
 069B           X35:
 069B                   .dbline 410
 069B           ;                       {
 069B                   .dbline 411
 069B           ;                               ID = atoi(param);
 069B 5200              mov A,[X+0]
 069D 08                push A
 069E 5201              mov A,[X+1]
 06A0 08                push A
 06A1 7C0000            xcall _atoi
 06A4 38FE              add SP,-2
 06A6 62D000            mov REG[0xd0],>__r0
 06A9 5100              mov A,[__r1]
 06AB 5404              mov [X+4],A
 06AD                   .dbline 412
 06AD           ;                               if(param = COMP_SERIAL_szGetParam())
 06AD 10                push X
 06AE 7C0000            xcall _COMP_SERIAL_szGetParam
 06B1 62D000            mov REG[0xd0],>__r0
 06B4 5300              mov [__r0],A
 06B6 5A00              mov [__r1],X
 06B8 20                pop X
 06B9 5100              mov A,[__r1]
 06BB 5401              mov [X+1],A
 06BD 5100              mov A,[__r0]
 06BF 5400              mov [X+0],A
 06C1 3C0000            cmp [__r0],0
 06C4 B006              jnz X36
 06C6 3C0000            cmp [__r1],0
 06C9 A2A7              jz L121
 06CB           X36:
 06CB                   .dbline 413
 06CB           ;                               {
 06CB                   .dbline 414
 06CB           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06CB 62D000            mov REG[0xd0],>__r0
 06CE 5201              mov A,[X+1]
 06D0 5300              mov [__r1],A
 06D2 5200              mov A,[X+0]
 06D4 60D4              mov REG[0xd4],A
 06D6 3E00              mvi A,[__r1]
 06D8 5300              mov [__r1],A
 06DA 550000            mov [__r0],0
 06DD 3C0000            cmp [__r0],0
 06E0 B005              jnz X37
 06E2 3961              cmp A,97
 06E4 A00E              jz L125
 06E6           X37:
 06E6 62D000            mov REG[0xd0],>__r0
 06E9 3C0000            cmp [__r0],0
 06EC B0CC              jnz L123
 06EE 3C0041            cmp [__r1],65
 06F1 B0C7              jnz L123
 06F3           X38:
 06F3           L125:
 06F3                   .dbline 415
 06F3           ;                                       {
 06F3                   .dbline 416
 06F3           ;                                               COMP_SERIAL_CmdReset();
 06F3 10                push X
 06F4 7C0000            xcall _COMP_SERIAL_CmdReset
 06F7 20                pop X
 06F8                   .dbline 417
 06F8           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 06F8 5002              mov A,2
 06FA 08                push A
 06FB 5024              mov A,36
 06FD 08                push A
 06FE 5002              mov A,2
 0700 08                push A
 0701 5004              mov A,4
 0703 08                push A
 0704 5204              mov A,[X+4]
 0706 08                push A
 0707 928E              xcall _servoInstruction
 0709                   .dbline 418
 0709           ;                                               configToggle(RX_MODE);
 0709 5000              mov A,0
 070B 08                push A
 070C 5001              mov A,1
 070E 08                push A
 070F 93DA              xcall _configToggle
 0711 38F9              add SP,-7
 0713 8094              xjmp L127
 0715           L126:
 0715                   .dbline 422
 0715           ;                                                       
 0715           ;                                               // Loop until we read a response or time out.
 0715           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0715           ;                                               {
 0715                   .dbline 423
 0715           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0715 10                push X
 0716 7C0000            xcall _RECEIVE_cReadChar
 0719 62D000            mov REG[0xd0],>__r0
 071C 20                pop X
 071D 39FF              cmp A,-1
 071F B088              jnz L129
 0721                   .dbline 424
 0721           ;                                                       {
 0721                   .dbline 425
 0721           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0721 10                push X
 0722 7C0000            xcall _RECEIVE_cGetChar
 0725 62D000            mov REG[0xd0],>__r0
 0728 20                pop X
 0729 39FF              cmp A,-1
 072B B07C              jnz L131
 072D                   .dbline 426
 072D           ;                                                               {
 072D                   .dbline 427
 072D           ;                                                                       if(RECEIVE_cGetChar() == ID)
 072D 10                push X
 072E 7C0000            xcall _RECEIVE_cGetChar
 0731 62D000            mov REG[0xd0],>__r0
 0734 20                pop X
 0735 3B04              cmp A,[X+4]
 0737 B070              jnz L133
 0739                   .dbline 428
 0739           ;                                                                       {
 0739                   .dbline 429
 0739           ;                                                                               if(RECEIVE_cGetChar() == 4)
 0739 10                push X
 073A 7C0000            xcall _RECEIVE_cGetChar
 073D 62D000            mov REG[0xd0],>__r0
 0740 20                pop X
 0741 3904              cmp A,4
 0743 B064              jnz L135
 0745                   .dbline 430
 0745           ;                                                                               {
 0745                   .dbline 431
 0745           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0745 10                push X
 0746 7C0000            xcall _RECEIVE_cGetChar
 0749 62D000            mov REG[0xd0],>__r0
 074C 20                pop X
 074D 3900              cmp A,0
 074F B058              jnz L137
 0751                   .dbline 432
 0751           ;                                                                                       {
 0751                   .dbline 433
 0751           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 0751 10                push X
 0752 7C0000            xcall _RECEIVE_cGetChar
 0755 62D000            mov REG[0xd0],>__r0
 0758 20                pop X
 0759 5405              mov [X+5],A
 075B                   .dbline 434
 075B           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 075B 10                push X
 075C 7C0000            xcall _RECEIVE_cGetChar
 075F 62D000            mov REG[0xd0],>__r0
 0762 20                pop X
 0763 5406              mov [X+6],A
 0765                   .dbline 436
 0765           ;                                                                                               
 0765           ;                                                                                               configToggle(PC_MODE);
 0765 5000              mov A,0
 0767 08                push A
 0768 5002              mov A,2
 076A 08                push A
 076B 937E              xcall _configToggle
 076D                   .dbline 438
 076D           ;                                                                                               
 076D           ;                                                                                               total = ((angle[1])*256) + angle[0];
 076D 5205              mov A,[X+5]
 076F 5403              mov [X+3],A
 0771 5206              mov A,[X+6]
 0773 5402              mov [X+2],A
 0775                   .dbline 439
 0775           ;                                                                                               itoa(param,total,10);
 0775 5000              mov A,0
 0777 08                push A
 0778 500A              mov A,10
 077A 08                push A
 077B 5202              mov A,[X+2]
 077D 08                push A
 077E 5203              mov A,[X+3]
 0780 08                push A
 0781 5200              mov A,[X+0]
 0783 08                push A
 0784 5201              mov A,[X+1]
 0786 08                push A
 0787 7C0000            xcall _itoa
 078A 38F8              add SP,-8
 078C                   .dbline 440
 078C           ;                                                                                               COMP_SERIAL_PutString(param);
 078C 10                push X
 078D 5200              mov A,[X+0]
 078F 08                push A
 0790 5201              mov A,[X+1]
 0792 5C                mov X,A
 0793 18                pop A
 0794 7C0000            xcall _COMP_SERIAL_PutString
 0797 20                pop X
 0798                   .dbline 441
 0798           ;                                                                                               COMP_SERIAL_PutChar('\n');
 0798 10                push X
 0799 500A              mov A,10
 079B 7C0000            xcall _COMP_SERIAL_PutChar
 079E 20                pop X
 079F                   .dbline 443
 079F           ; 
 079F           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 079F 62D000            mov REG[0xd0],>_TIMEOUT
 07A2 550105            mov [_TIMEOUT+1],5
 07A5 550000            mov [_TIMEOUT],0
 07A8                   .dbline 444
 07A8           ;                                                                                       }
 07A8           L137:
 07A8                   .dbline 445
 07A8           ;                                                                               }
 07A8           L135:
 07A8                   .dbline 446
 07A8           ;                                                                       }
 07A8           L133:
 07A8                   .dbline 447
 07A8           ;                                                               }
 07A8           L131:
 07A8                   .dbline 448
 07A8           ;                                                       }
 07A8           L129:
 07A8                   .dbline 449
 07A8           ;                                               }
 07A8           L127:
 07A8                   .dbline 421
 07A8 62D000            mov REG[0xd0],>_TIMEOUT
 07AB 5101              mov A,[_TIMEOUT+1]
 07AD 1105              sub A,5
 07AF 5100              mov A,[_TIMEOUT]
 07B1 3180              xor A,-128
 07B3 1980              sbb A,(0 ^ 0x80)
 07B5 CF5F              jc L126
 07B7           X39:
 07B7                   .dbline 450
 07B7           ;                                       }
 07B7 81B9              xjmp L124
 07B9           L123:
 07B9                   .dbline 451
 07B9           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07B9 62D000            mov REG[0xd0],>__r0
 07BC 5201              mov A,[X+1]
 07BE 5300              mov [__r1],A
 07C0 5200              mov A,[X+0]
 07C2 60D4              mov REG[0xd4],A
 07C4 3E00              mvi A,[__r1]
 07C6 5300              mov [__r1],A
 07C8 550000            mov [__r0],0
 07CB 3C0000            cmp [__r0],0
 07CE B005              jnz X40
 07D0 3970              cmp A,112
 07D2 A00E              jz L143
 07D4           X40:
 07D4 62D000            mov REG[0xd0],>__r0
 07D7 3C0000            cmp [__r0],0
 07DA B0A5              jnz L141
 07DC 3C0050            cmp [__r1],80
 07DF B0A0              jnz L141
 07E1           X41:
 07E1           L143:
 07E1                   .dbline 452
 07E1           ;                                       {
 07E1                   .dbline 453
 07E1           ;                                               COMP_SERIAL_CmdReset();
 07E1 10                push X
 07E2 7C0000            xcall _COMP_SERIAL_CmdReset
 07E5 20                pop X
 07E6                   .dbline 454
 07E6           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 07E6 5001              mov A,1
 07E8 08                push A
 07E9 5018              mov A,24
 07EB 08                push A
 07EC 5002              mov A,2
 07EE 08                push A
 07EF 5004              mov A,4
 07F1 08                push A
 07F2 5204              mov A,[X+4]
 07F4 08                push A
 07F5 91A0              xcall _servoInstruction
 07F7                   .dbline 455
 07F7           ;                                               configToggle(RX_MODE);
 07F7 5000              mov A,0
 07F9 08                push A
 07FA 5001              mov A,1
 07FC 08                push A
 07FD 92EC              xcall _configToggle
 07FF 38F9              add SP,-7
 0801 806D              xjmp L145
 0803           L144:
 0803                   .dbline 459
 0803           ;                                                       
 0803           ;                                               // Loop until we read a response or time out.
 0803           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0803           ;                                               {
 0803                   .dbline 460
 0803           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0803 10                push X
 0804 7C0000            xcall _RECEIVE_cReadChar
 0807 62D000            mov REG[0xd0],>__r0
 080A 20                pop X
 080B 39FF              cmp A,-1
 080D B061              jnz L147
 080F                   .dbline 461
 080F           ;                                                       {
 080F                   .dbline 462
 080F           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 080F 10                push X
 0810 7C0000            xcall _RECEIVE_cGetChar
 0813 62D000            mov REG[0xd0],>__r0
 0816 20                pop X
 0817 39FF              cmp A,-1
 0819 B055              jnz L149
 081B                   .dbline 463
 081B           ;                                                               {
 081B                   .dbline 464
 081B           ;                                                                       if(RECEIVE_cGetChar() == ID)
 081B 10                push X
 081C 7C0000            xcall _RECEIVE_cGetChar
 081F 62D000            mov REG[0xd0],>__r0
 0822 20                pop X
 0823 3B04              cmp A,[X+4]
 0825 B049              jnz L151
 0827                   .dbline 465
 0827           ;                                                                       {
 0827                   .dbline 466
 0827           ;                                                                               if(RECEIVE_cGetChar() == 3)
 0827 10                push X
 0828 7C0000            xcall _RECEIVE_cGetChar
 082B 62D000            mov REG[0xd0],>__r0
 082E 20                pop X
 082F 3903              cmp A,3
 0831 B03D              jnz L153
 0833                   .dbline 467
 0833           ;                                                                               {
 0833                   .dbline 468
 0833           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0833 10                push X
 0834 7C0000            xcall _RECEIVE_cGetChar
 0837 62D000            mov REG[0xd0],>__r0
 083A 20                pop X
 083B 3900              cmp A,0
 083D B031              jnz L155
 083F                   .dbline 469
 083F           ;                                                                                       {
 083F                   .dbline 470
 083F           ;                                                                                               tempByte = RECEIVE_cGetChar();
 083F 10                push X
 0840 7C0000            xcall _RECEIVE_cGetChar
 0843 62D000            mov REG[0xd0],>__r0
 0846 20                pop X
 0847 5407              mov [X+7],A
 0849                   .dbline 472
 0849           ;                                                                                               
 0849           ;                                                                                               configToggle(PC_MODE);
 0849 5000              mov A,0
 084B 08                push A
 084C 5002              mov A,2
 084E 08                push A
 084F 929A              xcall _configToggle
 0851 38FE              add SP,-2
 0853                   .dbline 475
 0853           ;                                                                                               
 0853           ;                                                                                               // Convert tempByte to an ascii value and send.
 0853           ;                                                                                               COMP_SERIAL_PutChar(tempByte + 48);
 0853 62D000            mov REG[0xd0],>__r0
 0856 5207              mov A,[X+7]
 0858 0130              add A,48
 085A 10                push X
 085B 7C0000            xcall _COMP_SERIAL_PutChar
 085E 20                pop X
 085F                   .dbline 476
 085F           ;                                                                                               COMP_SERIAL_PutChar('\n');
 085F 10                push X
 0860 500A              mov A,10
 0862 7C0000            xcall _COMP_SERIAL_PutChar
 0865 20                pop X
 0866                   .dbline 478
 0866           ; 
 0866           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 0866 62D000            mov REG[0xd0],>_TIMEOUT
 0869 550105            mov [_TIMEOUT+1],5
 086C 550000            mov [_TIMEOUT],0
 086F                   .dbline 479
 086F           ;                                                                                       }
 086F           L155:
 086F                   .dbline 480
 086F           ;                                                                               }
 086F           L153:
 086F                   .dbline 481
 086F           ;                                                                       }
 086F           L151:
 086F                   .dbline 482
 086F           ;                                                               }
 086F           L149:
 086F                   .dbline 483
 086F           ;                                                       }
 086F           L147:
 086F                   .dbline 484
 086F           ;                                               }
 086F           L145:
 086F                   .dbline 458
 086F 62D000            mov REG[0xd0],>_TIMEOUT
 0872 5101              mov A,[_TIMEOUT+1]
 0874 1105              sub A,5
 0876 5100              mov A,[_TIMEOUT]
 0878 3180              xor A,-128
 087A 1980              sbb A,(0 ^ 0x80)
 087C CF86              jc L144
 087E           X42:
 087E                   .dbline 485
 087E           ;                                       }
 087E 80F2              xjmp L142
 0880           L141:
 0880                   .dbline 486
 0880           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 0880 62D000            mov REG[0xd0],>__r0
 0883 5201              mov A,[X+1]
 0885 5300              mov [__r1],A
 0887 5200              mov A,[X+0]
 0889 60D4              mov REG[0xd4],A
 088B 3E00              mvi A,[__r1]
 088D 5300              mov [__r1],A
 088F 550000            mov [__r0],0
 0892 3C0000            cmp [__r0],0
 0895 B005              jnz X43
 0897 3974              cmp A,116
 0899 A00E              jz L159
 089B           X43:
 089B 62D000            mov REG[0xd0],>__r0
 089E 3C0000            cmp [__r0],0
 08A1 B068              jnz L157
 08A3 3C0054            cmp [__r1],84
 08A6 B063              jnz L157
 08A8           X44:
 08A8           L159:
 08A8                   .dbline 487
 08A8           ;                                       {
 08A8                   .dbline 488
 08A8           ;                                               COMP_SERIAL_CmdReset();
 08A8 10                push X
 08A9 7C0000            xcall _COMP_SERIAL_CmdReset
 08AC 20                pop X
 08AD                   .dbline 489
 08AD           ;                                               if(pingModule(ID))
 08AD 62D000            mov REG[0xd0],>__r0
 08B0 5204              mov A,[X+4]
 08B2 5300              mov [__r1],A
 08B4 5000              mov A,0
 08B6 08                push A
 08B7 5100              mov A,[__r1]
 08B9 08                push A
 08BA 7C001C            xcall _pingModule
 08BD 38FE              add SP,-2
 08BF 62D000            mov REG[0xd0],>__r0
 08C2 3C0000            cmp [__r0],0
 08C5 B006              jnz X45
 08C7 3C0000            cmp [__r1],0
 08CA A0A6              jz L158
 08CC           X45:
 08CC                   .dbline 490
 08CC           ;                                               {
 08CC                   .dbline 491
 08CC           ;                                                       configToggle(PC_MODE);
 08CC 5000              mov A,0
 08CE 08                push A
 08CF 5002              mov A,2
 08D1 08                push A
 08D2 9217              xcall _configToggle
 08D4                   .dbline 493
 08D4           ;                                                                                               
 08D4           ;                                                       total = PARAM[0];
 08D4 62D000            mov REG[0xd0],>_PARAM
 08D7 5100              mov A,[_PARAM]
 08D9 5403              mov [X+3],A
 08DB 560200            mov [X+2],0
 08DE                   .dbline 494
 08DE           ;                                                       itoa(param,total,10);
 08DE 5000              mov A,0
 08E0 08                push A
 08E1 500A              mov A,10
 08E3 08                push A
 08E4 5202              mov A,[X+2]
 08E6 08                push A
 08E7 5203              mov A,[X+3]
 08E9 08                push A
 08EA 5200              mov A,[X+0]
 08EC 08                push A
 08ED 5201              mov A,[X+1]
 08EF 08                push A
 08F0 7C0000            xcall _itoa
 08F3 38F8              add SP,-8
 08F5                   .dbline 495
 08F5           ;                                                       COMP_SERIAL_PutString(param);
 08F5 10                push X
 08F6 5200              mov A,[X+0]
 08F8 08                push A
 08F9 5201              mov A,[X+1]
 08FB 5C                mov X,A
 08FC 18                pop A
 08FD 7C0000            xcall _COMP_SERIAL_PutString
 0900 20                pop X
 0901                   .dbline 496
 0901           ;                                                       COMP_SERIAL_PutChar('\n');
 0901 10                push X
 0902 500A              mov A,10
 0904 7C0000            xcall _COMP_SERIAL_PutChar
 0907 20                pop X
 0908                   .dbline 497
 0908           ;                                               }
 0908                   .dbline 498
 0908           ;                                       }
 0908 8068              xjmp L158
 090A           L157:
 090A                   .dbline 499
 090A           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 090A 62D000            mov REG[0xd0],>__r0
 090D 5201              mov A,[X+1]
 090F 5300              mov [__r1],A
 0911 5200              mov A,[X+0]
 0913 60D4              mov REG[0xd4],A
 0915 3E00              mvi A,[__r1]
 0917 5300              mov [__r1],A
 0919 550000            mov [__r0],0
 091C 3C0000            cmp [__r0],0
 091F B005              jnz X46
 0921 3963              cmp A,99
 0923 A00E              jz L164
 0925           X46:
 0925 62D000            mov REG[0xd0],>__r0
 0928 3C0000            cmp [__r0],0
 092B B045              jnz L162
 092D 3C0043            cmp [__r1],67
 0930 B040              jnz L162
 0932           X47:
 0932           L164:
 0932                   .dbline 500
 0932           ;                                       {
 0932                   .dbline 501
 0932           ;                                               COMP_SERIAL_CmdReset();
 0932 10                push X
 0933 7C0000            xcall _COMP_SERIAL_CmdReset
 0936 20                pop X
 0937                   .dbline 502
 0937           ;                                               if(pingModule(ID))
 0937 62D000            mov REG[0xd0],>__r0
 093A 5204              mov A,[X+4]
 093C 5300              mov [__r1],A
 093E 5000              mov A,0
 0940 08                push A
 0941 5100              mov A,[__r1]
 0943 08                push A
 0944 7C001C            xcall _pingModule
 0947 38FE              add SP,-2
 0949 62D000            mov REG[0xd0],>__r0
 094C 3C0000            cmp [__r0],0
 094F B006              jnz X48
 0951 3C0000            cmp [__r1],0
 0954 A01C              jz L165
 0956           X48:
 0956                   .dbline 503
 0956           ;                                               {       
 0956                   .dbline 504
 0956           ;                                                       configToggle(PC_MODE);
 0956 5000              mov A,0
 0958 08                push A
 0959 5002              mov A,2
 095B 08                push A
 095C 918D              xcall _configToggle
 095E 38FE              add SP,-2
 0960                   .dbline 506
 0960           ;                                                                                               
 0960           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 0960 10                push X
 0961 62D000            mov REG[0xd0],>_PARAM
 0964 5101              mov A,[_PARAM+1]
 0966 7C0000            xcall _COMP_SERIAL_PutChar
 0969 20                pop X
 096A                   .dbline 507
 096A           ;                                                       COMP_SERIAL_PutChar('\n');
 096A 10                push X
 096B 500A              mov A,10
 096D 7C0000            xcall _COMP_SERIAL_PutChar
 0970 20                pop X
 0971                   .dbline 508
 0971           ;                                               }
 0971           L165:
 0971                   .dbline 509
 0971           ;                                       }
 0971           L162:
 0971           L158:
 0971           L142:
 0971           L124:
 0971                   .dbline 510
 0971           ;                               }
 0971           L121:
 0971                   .dbline 511
 0971           ;                       }
 0971           L119:
 0971                   .dbline 512
 0971           ;               }
 0971           L116:
 0971           L98:
 0971           L95:
 0971                   .dbline 513
 0971           ;       }
 0971           L92:
 0971                   .dbline 515
 0971           ;       
 0971           ;       if(STATE != PC_MODE)
 0971 62D000            mov REG[0xd0],>_STATE
 0974 3C0000            cmp [_STATE],0
 0977 B006              jnz X49
 0979 3C0102            cmp [_STATE+1],2
 097C A00D              jz L168
 097E           X49:
 097E                   .dbline 516
 097E           ;       {
 097E                   .dbline 517
 097E           ;               configToggle(PC_MODE);
 097E 5000              mov A,0
 0980 08                push A
 0981 5002              mov A,2
 0983 08                push A
 0984 9165              xcall _configToggle
 0986 38FE              add SP,-2
 0988                   .dbline 518
 0988           ;       }
 0988 800A              xjmp L169
 098A           L168:
 098A                   .dbline 520
 098A           ;       else
 098A           ;       {
 098A                   .dbline 521
 098A           ;               TIMEOUT = 0;
 098A 62D000            mov REG[0xd0],>_TIMEOUT
 098D 550100            mov [_TIMEOUT+1],0
 0990 550000            mov [_TIMEOUT],0
 0993                   .dbline 522
 0993           ;       }
 0993           L169:
 0993                   .dbline -2
 0993           L91:
 0993 38F8              add SP,-8
 0995 20                pop X
 0996                   .dbline 0 ; func end
 0996 7F                ret
 0997                   .dbsym l tempByte 7 c
 0997                   .dbsym l angle 5 A[2:2]c
 0997                   .dbsym l ID 4 c
 0997                   .dbsym l total 2 I
 0997                   .dbsym l param 0 pc
 0997                   .dbend
 0997                   .dbfunc e servoInstruction _servoInstruction fV
 0997           ;          total -> X+1
 0997           ;       checksum -> X+0
 0997           ;          value -> X-8
 0997           ;        address -> X-7
 0997           ;    instruction -> X-6
 0997           ;         length -> X-5
 0997           ;             id -> X-4
 0997           _servoInstruction::
 0997                   .dbline -1
 0997 10                push X
 0998 4F                mov X,SP
 0999 3803              add SP,3
 099B                   .dbline 528
 099B           ; }
 099B           ; 
 099B           ; // This function receives a destination, command length, instruction type, address, and value.
 099B           ; // With these parameters, the function sends a packet to the communication bus.
 099B           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 099B           ; {
 099B                   .dbline 532
 099B           ;       char checksum;
 099B           ;       int total;
 099B           ;       
 099B           ;       total = id + length + instruction + address + value;
 099B 62D000            mov REG[0xd0],>__r0
 099E 52FB              mov A,[X-5]
 09A0 5300              mov [__r1],A
 09A2 550000            mov [__r0],0
 09A5 52FC              mov A,[X-4]
 09A7 0200              add A,[__r1]
 09A9 5300              mov [__r1],A
 09AB 5000              mov A,0
 09AD 0A00              adc A,[__r0]
 09AF 5300              mov [__r0],A
 09B1 52FA              mov A,[X-6]
 09B3 0400              add [__r1],A
 09B5 0E0000            adc [__r0],0
 09B8 52F9              mov A,[X-7]
 09BA 0400              add [__r1],A
 09BC 0E0000            adc [__r0],0
 09BF 52F8              mov A,[X-8]
 09C1 5300              mov [__r3],A
 09C3 550000            mov [__r2],0
 09C6 5100              mov A,[__r1]
 09C8 0200              add A,[__r3]
 09CA 5402              mov [X+2],A
 09CC 5100              mov A,[__r0]
 09CE 0A00              adc A,[__r2]
 09D0 5401              mov [X+1],A
 09D2                   .dbline 535
 09D2           ;       
 09D2           ;       // Calculate the checksum value for our servo communication.
 09D2           ;       checksum = 255-(total%256);
 09D2 5001              mov A,1
 09D4 08                push A
 09D5 5000              mov A,0
 09D7 08                push A
 09D8 5201              mov A,[X+1]
 09DA 08                push A
 09DB 5202              mov A,[X+2]
 09DD 08                push A
 09DE 7C0000            xcall __divmod_16X16_16
 09E1 38FE              add SP,-2
 09E3 18                pop A
 09E4 5300              mov [__r1],A
 09E6 18                pop A
 09E7 50FF              mov A,-1
 09E9 1200              sub A,[__r1]
 09EB 5400              mov [X+0],A
 09ED                   .dbline 538
 09ED           ;       
 09ED           ;       // Talk to the servo.
 09ED           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 09ED 10                push X
 09EE 50FF              mov A,-1
 09F0 7C0000            xcall _TX_REPEATER_PutChar
 09F3 20                pop X
 09F4                   .dbline 539
 09F4           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 09F4 10                push X
 09F5 50FF              mov A,-1
 09F7 7C0000            xcall _TX_REPEATER_PutChar
 09FA 20                pop X
 09FB                   .dbline 540
 09FB           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 09FB 10                push X
 09FC 52FC              mov A,[X-4]
 09FE 7C0000            xcall _TX_REPEATER_PutChar
 0A01 20                pop X
 0A02                   .dbline 541
 0A02           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0A02 10                push X
 0A03 52FB              mov A,[X-5]
 0A05 7C0000            xcall _TX_REPEATER_PutChar
 0A08 20                pop X
 0A09                   .dbline 542
 0A09           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0A09 10                push X
 0A0A 52FA              mov A,[X-6]
 0A0C 7C0000            xcall _TX_REPEATER_PutChar
 0A0F 20                pop X
 0A10                   .dbline 543
 0A10           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0A10 10                push X
 0A11 52F9              mov A,[X-7]
 0A13 7C0000            xcall _TX_REPEATER_PutChar
 0A16 20                pop X
 0A17                   .dbline 544
 0A17           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0A17 10                push X
 0A18 52F8              mov A,[X-8]
 0A1A 7C0000            xcall _TX_REPEATER_PutChar
 0A1D 20                pop X
 0A1E                   .dbline 545
 0A1E           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0A1E 10                push X
 0A1F 5200              mov A,[X+0]
 0A21 7C0000            xcall _TX_REPEATER_PutChar
 0A24 20                pop X
 0A25           L171:
 0A25                   .dbline 548
 0A25           ;       
 0A25           ;       // Wait for the transmission to finish.
 0A25           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0A25           L172:
 0A25                   .dbline 548
 0A25 10                push X
 0A26 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0A29 62D000            mov REG[0xd0],>__r0
 0A2C 20                pop X
 0A2D 5300              mov [__r0],A
 0A2F 470020            tst [__r0],32
 0A32 AFF2              jz L171
 0A34                   .dbline 551
 0A34           ;       
 0A34           ;       // Make completely sure we're done.
 0A34           ;       xmitWait();
 0A34 9360              xcall _xmitWait
 0A36                   .dbline -2
 0A36           L170:
 0A36 38FD              add SP,-3
 0A38 20                pop X
 0A39                   .dbline 0 ; func end
 0A39 7F                ret
 0A3A                   .dbsym l total 1 I
 0A3A                   .dbsym l checksum 0 c
 0A3A                   .dbsym l value -8 c
 0A3A                   .dbsym l address -7 c
 0A3A                   .dbsym l instruction -6 c
 0A3A                   .dbsym l length -5 c
 0A3A                   .dbsym l id -4 c
 0A3A                   .dbend
 0A3A                   .dbfunc e longServoInstruction _longServoInstruction fV
 0A3A           ;          total -> X+1
 0A3A           ;       checksum -> X+0
 0A3A           ;         value2 -> X-9
 0A3A           ;         value1 -> X-8
 0A3A           ;        address -> X-7
 0A3A           ;    instruction -> X-6
 0A3A           ;         length -> X-5
 0A3A           ;             id -> X-4
 0A3A           _longServoInstruction::
 0A3A                   .dbline -1
 0A3A 10                push X
 0A3B 4F                mov X,SP
 0A3C 3803              add SP,3
 0A3E                   .dbline 556
 0A3E           ; }
 0A3E           ; 
 0A3E           ; // This function receives a destination, command length, instruction type, address, and two values.
 0A3E           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0A3E           ; {
 0A3E                   .dbline 560
 0A3E           ;       char checksum;
 0A3E           ;       int total;
 0A3E           ;       
 0A3E           ;       total = id + length + instruction + address + value1 + value2;
 0A3E 62D000            mov REG[0xd0],>__r0
 0A41 52FB              mov A,[X-5]
 0A43 5300              mov [__r1],A
 0A45 550000            mov [__r0],0
 0A48 52FC              mov A,[X-4]
 0A4A 0200              add A,[__r1]
 0A4C 5300              mov [__r1],A
 0A4E 5000              mov A,0
 0A50 0A00              adc A,[__r0]
 0A52 5300              mov [__r0],A
 0A54 52FA              mov A,[X-6]
 0A56 0400              add [__r1],A
 0A58 0E0000            adc [__r0],0
 0A5B 52F9              mov A,[X-7]
 0A5D 0400              add [__r1],A
 0A5F 0E0000            adc [__r0],0
 0A62 52F8              mov A,[X-8]
 0A64 0400              add [__r1],A
 0A66 0E0000            adc [__r0],0
 0A69 52F7              mov A,[X-9]
 0A6B 5300              mov [__r3],A
 0A6D 550000            mov [__r2],0
 0A70 5100              mov A,[__r1]
 0A72 0200              add A,[__r3]
 0A74 5402              mov [X+2],A
 0A76 5100              mov A,[__r0]
 0A78 0A00              adc A,[__r2]
 0A7A 5401              mov [X+1],A
 0A7C                   .dbline 563
 0A7C           ;       
 0A7C           ;       // Calculate the checksum value for our servo communication.
 0A7C           ;       checksum = 255-(total%256);
 0A7C 5001              mov A,1
 0A7E 08                push A
 0A7F 5000              mov A,0
 0A81 08                push A
 0A82 5201              mov A,[X+1]
 0A84 08                push A
 0A85 5202              mov A,[X+2]
 0A87 08                push A
 0A88 7C0000            xcall __divmod_16X16_16
 0A8B 38FE              add SP,-2
 0A8D 18                pop A
 0A8E 5300              mov [__r1],A
 0A90 18                pop A
 0A91 50FF              mov A,-1
 0A93 1200              sub A,[__r1]
 0A95 5400              mov [X+0],A
 0A97                   .dbline 566
 0A97           ;       
 0A97           ;       // Talk to the servo.
 0A97           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0A97 10                push X
 0A98 50FF              mov A,-1
 0A9A 7C0000            xcall _TX_REPEATER_PutChar
 0A9D 20                pop X
 0A9E                   .dbline 567
 0A9E           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0A9E 10                push X
 0A9F 50FF              mov A,-1
 0AA1 7C0000            xcall _TX_REPEATER_PutChar
 0AA4 20                pop X
 0AA5                   .dbline 568
 0AA5           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0AA5 10                push X
 0AA6 52FC              mov A,[X-4]
 0AA8 7C0000            xcall _TX_REPEATER_PutChar
 0AAB 20                pop X
 0AAC                   .dbline 569
 0AAC           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0AAC 10                push X
 0AAD 52FB              mov A,[X-5]
 0AAF 7C0000            xcall _TX_REPEATER_PutChar
 0AB2 20                pop X
 0AB3                   .dbline 570
 0AB3           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0AB3 10                push X
 0AB4 52FA              mov A,[X-6]
 0AB6 7C0000            xcall _TX_REPEATER_PutChar
 0AB9 20                pop X
 0ABA                   .dbline 571
 0ABA           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0ABA 10                push X
 0ABB 52F9              mov A,[X-7]
 0ABD 7C0000            xcall _TX_REPEATER_PutChar
 0AC0 20                pop X
 0AC1                   .dbline 572
 0AC1           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0AC1 10                push X
 0AC2 52F8              mov A,[X-8]
 0AC4 7C0000            xcall _TX_REPEATER_PutChar
 0AC7 20                pop X
 0AC8                   .dbline 573
 0AC8           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0AC8 10                push X
 0AC9 52F7              mov A,[X-9]
 0ACB 7C0000            xcall _TX_REPEATER_PutChar
 0ACE 20                pop X
 0ACF                   .dbline 574
 0ACF           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0ACF 10                push X
 0AD0 5200              mov A,[X+0]
 0AD2 7C0000            xcall _TX_REPEATER_PutChar
 0AD5 20                pop X
 0AD6           L175:
 0AD6                   .dbline 577
 0AD6           ;       
 0AD6           ;       // Wait for the transmission to finish.
 0AD6           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0AD6           L176:
 0AD6                   .dbline 577
 0AD6 10                push X
 0AD7 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0ADA 62D000            mov REG[0xd0],>__r0
 0ADD 20                pop X
 0ADE 5300              mov [__r0],A
 0AE0 470020            tst [__r0],32
 0AE3 AFF2              jz L175
 0AE5                   .dbline 580
 0AE5           ;       
 0AE5           ;       // Make completely sure we're done.
 0AE5           ;       xmitWait();
 0AE5 92AF              xcall _xmitWait
 0AE7                   .dbline -2
 0AE7           L174:
 0AE7 38FD              add SP,-3
 0AE9 20                pop X
 0AEA                   .dbline 0 ; func end
 0AEA 7F                ret
 0AEB                   .dbsym l total 1 I
 0AEB                   .dbsym l checksum 0 c
 0AEB                   .dbsym l value2 -9 c
 0AEB                   .dbsym l value1 -8 c
 0AEB                   .dbsym l address -7 c
 0AEB                   .dbsym l instruction -6 c
 0AEB                   .dbsym l length -5 c
 0AEB                   .dbsym l id -4 c
 0AEB                   .dbend
 0AEB                   .dbfunc e configToggle _configToggle fV
 0AEB           ;           mode -> X-5
 0AEB           _configToggle::
 0AEB                   .dbline -1
 0AEB 10                push X
 0AEC 4F                mov X,SP
 0AED                   .dbline 586
 0AED           ; }
 0AED           ; 
 0AED           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0AED           ; // half duplex UART serial communication line.
 0AED           ; void configToggle(int mode)
 0AED           ; {
 0AED                   .dbline 588
 0AED           ;       // Disconnect from the global bus and leave the pin high.
 0AED           ;       PRT0DR |= 0b11111111;
 0AED 4300FF            or REG[0],-1
 0AF0                   .dbline 589
 0AF0           ;       PRT0GS &= 0b00000000;
 0AF0 620200            mov REG[0x2],0
 0AF3                   .dbline 593
 0AF3           ; 
 0AF3           ;       // Unload the configuration of the current state.
 0AF3           ;       // If there is no state, blindly wipe all configurations.
 0AF3           ;       if(STATE)
 0AF3 62D000            mov REG[0xd0],>_STATE
 0AF6 3C0000            cmp [_STATE],0
 0AF9 B006              jnz X50
 0AFB 3C0100            cmp [_STATE+1],0
 0AFE A010              jz L179
 0B00           X50:
 0B00                   .dbline 594
 0B00           ;       {
 0B00                   .dbline 595
 0B00           ;               unloadConfig(STATE);
 0B00 62D000            mov REG[0xd0],>_STATE
 0B03 5100              mov A,[_STATE]
 0B05 08                push A
 0B06 5101              mov A,[_STATE+1]
 0B08 08                push A
 0B09 90C4              xcall _unloadConfig
 0B0B 38FE              add SP,-2
 0B0D                   .dbline 596
 0B0D           ;       }
 0B0D 8003              xjmp L180
 0B0F           L179:
 0B0F                   .dbline 598
 0B0F           ;       else
 0B0F           ;       {
 0B0F                   .dbline 599
 0B0F           ;               unloadAllConfigs();
 0B0F 90B4              xcall _unloadAllConfigs
 0B11                   .dbline 600
 0B11           ;       }
 0B11           L180:
 0B11                   .dbline 602
 0B11           ;       
 0B11           ;       if(mode == PC_MODE)
 0B11 3DFB00            cmp [X-5],0
 0B14 B032              jnz L181
 0B16 3DFC02            cmp [X-4],2
 0B19 B02D              jnz L181
 0B1B           X51:
 0B1B                   .dbline 603
 0B1B           ;       {
 0B1B                   .dbline 604
 0B1B           ;               LoadConfig_pc_listener();
 0B1B 7C0000            xcall _LoadConfig_pc_listener
 0B1E                   .dbline 606
 0B1E           ; 
 0B1E           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0B1E 10                push X
 0B1F 5001              mov A,1
 0B21 7C0000            xcall _COMP_SERIAL_IntCntl
 0B24 20                pop X
 0B25                   .dbline 607
 0B25           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0B25 10                push X
 0B26 5000              mov A,0
 0B28 7C0000            xcall _COMP_SERIAL_Start
 0B2B 20                pop X
 0B2C                   .dbline 609
 0B2C           ;               
 0B2C           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0B2C 10                push X
 0B2D 5000              mov A,0
 0B2F 7C0000            xcall _TX_REPEATER_Start
 0B32 20                pop X
 0B33                   .dbline 611
 0B33           ;               
 0B33           ;               TIMEOUT = 0;
 0B33 62D000            mov REG[0xd0],>_TIMEOUT
 0B36 550100            mov [_TIMEOUT+1],0
 0B39 550000            mov [_TIMEOUT],0
 0B3C                   .dbline 612
 0B3C           ;               STATE = PC_MODE;
 0B3C 62D000            mov REG[0xd0],>_STATE
 0B3F 550102            mov [_STATE+1],2
 0B42 550000            mov [_STATE],0
 0B45                   .dbline 613
 0B45           ;       }
 0B45 807A              xjmp L182
 0B47           L181:
 0B47                   .dbline 614
 0B47           ;       else if(mode == RX_MODE)
 0B47 3DFB00            cmp [X-5],0
 0B4A B02C              jnz L183
 0B4C 3DFC01            cmp [X-4],1
 0B4F B027              jnz L183
 0B51           X52:
 0B51                   .dbline 615
 0B51           ;       {
 0B51                   .dbline 616
 0B51           ;               LoadConfig_receiver_config();
 0B51 7C0000            xcall _LoadConfig_receiver_config
 0B54                   .dbline 619
 0B54           ;               
 0B54           ;               // Start the receiver.
 0B54           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0B54 10                push X
 0B55 5000              mov A,0
 0B57 7C0000            xcall _RECEIVE_Start
 0B5A 20                pop X
 0B5B                   .dbline 622
 0B5B           ;               
 0B5B           ;               // Start response timeout timer and enable its interrupt routine.
 0B5B           ;               TIMEOUT = 0;
 0B5B 62D000            mov REG[0xd0],>_TIMEOUT
 0B5E 550100            mov [_TIMEOUT+1],0
 0B61 550000            mov [_TIMEOUT],0
 0B64                   .dbline 623
 0B64           ;               RX_TIMEOUT_EnableInt();
 0B64 10                push X
 0B65 7C0000            xcall _RX_TIMEOUT_EnableInt
 0B68                   .dbline 624
 0B68           ;               RX_TIMEOUT_Start();
 0B68 7C0000            xcall _RX_TIMEOUT_Start
 0B6B 20                pop X
 0B6C                   .dbline 626
 0B6C           ;               
 0B6C           ;               STATE = RX_MODE;
 0B6C 62D000            mov REG[0xd0],>_STATE
 0B6F 550101            mov [_STATE+1],1
 0B72 550000            mov [_STATE],0
 0B75                   .dbline 627
 0B75           ;       }
 0B75 804A              xjmp L184
 0B77           L183:
 0B77                   .dbline 628
 0B77           ;       else if(mode == TX_MODE)
 0B77 3DFB00            cmp [X-5],0
 0B7A B045              jnz L185
 0B7C 3DFC00            cmp [X-4],0
 0B7F B040              jnz L185
 0B81           X53:
 0B81                   .dbline 629
 0B81           ;       {
 0B81                   .dbline 630
 0B81           ;               LoadConfig_transmitter_config();
 0B81 7C0000            xcall _LoadConfig_transmitter_config
 0B84                   .dbline 632
 0B84           ;               // Start the transmitter.
 0B84           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0B84 10                push X
 0B85 5000              mov A,0
 0B87 7C0000            xcall _TRANSMIT_Start
 0B8A 20                pop X
 0B8B                   .dbline 634
 0B8B           ;               
 0B8B           ;               TIMEOUT = 0;
 0B8B 62D000            mov REG[0xd0],>_TIMEOUT
 0B8E 550100            mov [_TIMEOUT+1],0
 0B91 550000            mov [_TIMEOUT],0
 0B94                   .dbline 635
 0B94           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0B94 10                push X
 0B95 7C0000            xcall _TX_TIMEOUT_EnableInt
 0B98                   .dbline 636
 0B98           ;               TX_TIMEOUT_Start();             // Start the timer.
 0B98 7C0000            xcall _TX_TIMEOUT_Start
 0B9B 20                pop X
 0B9C           L187:
 0B9C                   .dbline 639
 0B9C           ;               
 0B9C           ;               while(!TIMEOUT)
 0B9C           ;               {
 0B9C                   .dbline 642
 0B9C           ;                       // Do nothing while we wait for one timeout period.
 0B9C           ;                       // This is to allow everyone to get in the right configuration.
 0B9C           ;               }
 0B9C           L188:
 0B9C                   .dbline 638
 0B9C 62D000            mov REG[0xd0],>_TIMEOUT
 0B9F 3C0000            cmp [_TIMEOUT],0
 0BA2 B006              jnz X54
 0BA4 3C0100            cmp [_TIMEOUT+1],0
 0BA7 AFF4              jz L187
 0BA9           X54:
 0BA9                   .dbline 644
 0BA9           ;               
 0BA9           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0BA9 10                push X
 0BAA 7C0000            xcall _TX_TIMEOUT_Stop
 0BAD 20                pop X
 0BAE                   .dbline 645
 0BAE           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0BAE 62D000            mov REG[0xd0],>_TIMEOUT
 0BB1 550100            mov [_TIMEOUT+1],0
 0BB4 550000            mov [_TIMEOUT],0
 0BB7                   .dbline 647
 0BB7           ;               
 0BB7           ;               STATE = TX_MODE;
 0BB7 62D000            mov REG[0xd0],>_STATE
 0BBA 550100            mov [_STATE+1],0
 0BBD 550000            mov [_STATE],0
 0BC0                   .dbline 648
 0BC0           ;       }
 0BC0           L185:
 0BC0           L184:
 0BC0           L182:
 0BC0                   .dbline 651
 0BC0           ;       
 0BC0           ;       // Reconnect to the global bus.
 0BC0           ;       PRT0GS |= 0b11111111;
 0BC0 4302FF            or REG[0x2],-1
 0BC3                   .dbline -2
 0BC3           L178:
 0BC3 20                pop X
 0BC4                   .dbline 0 ; func end
 0BC4 7F                ret
 0BC5                   .dbsym l mode -5 I
 0BC5                   .dbend
 0BC5                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0BC5           _unloadAllConfigs::
 0BC5                   .dbline -1
 0BC5                   .dbline 657
 0BC5           ; }
 0BC5           ; 
 0BC5           ; // This function blindly unloads all user configurations. This will be called once,
 0BC5           ; // when the system initially has no known state.
 0BC5           ; void unloadAllConfigs(void)
 0BC5           ; {
 0BC5                   .dbline 658
 0BC5           ;       UnloadConfig_pc_listener();
 0BC5 7C0000            xcall _UnloadConfig_pc_listener
 0BC8                   .dbline 659
 0BC8           ;       UnloadConfig_receiver_config();
 0BC8 7C0000            xcall _UnloadConfig_receiver_config
 0BCB                   .dbline 660
 0BCB           ;       UnloadConfig_transmitter_config();
 0BCB 7C0000            xcall _UnloadConfig_transmitter_config
 0BCE                   .dbline -2
 0BCE           L190:
 0BCE                   .dbline 0 ; func end
 0BCE 7F                ret
 0BCF                   .dbend
 0BCF                   .dbfunc e unloadConfig _unloadConfig fV
 0BCF           ;     config_num -> X-5
 0BCF           _unloadConfig::
 0BCF                   .dbline -1
 0BCF 10                push X
 0BD0 4F                mov X,SP
 0BD1                   .dbline 666
 0BD1           ; }
 0BD1           ; 
 0BD1           ; // This function unloads the configuration corresponding to the config number passed to it.
 0BD1           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0BD1           ; void unloadConfig(int config_num)
 0BD1           ; {
 0BD1                   .dbline 667
 0BD1           ;       if(config_num == PC_MODE)
 0BD1 3DFB00            cmp [X-5],0
 0BD4 B00B              jnz L192
 0BD6 3DFC02            cmp [X-4],2
 0BD9 B006              jnz L192
 0BDB           X55:
 0BDB                   .dbline 668
 0BDB           ;       {
 0BDB                   .dbline 669
 0BDB           ;               UnloadConfig_pc_listener();
 0BDB 7C0000            xcall _UnloadConfig_pc_listener
 0BDE                   .dbline 670
 0BDE           ;       }
 0BDE 801D              xjmp L193
 0BE0           L192:
 0BE0                   .dbline 671
 0BE0           ;       else if(config_num == RX_MODE)
 0BE0 3DFB00            cmp [X-5],0
 0BE3 B00B              jnz L194
 0BE5 3DFC01            cmp [X-4],1
 0BE8 B006              jnz L194
 0BEA           X56:
 0BEA                   .dbline 672
 0BEA           ;       {
 0BEA                   .dbline 673
 0BEA           ;               UnloadConfig_receiver_config();
 0BEA 7C0000            xcall _UnloadConfig_receiver_config
 0BED                   .dbline 674
 0BED           ;       }
 0BED 800E              xjmp L195
 0BEF           L194:
 0BEF                   .dbline 675
 0BEF           ;       else if(config_num == TX_MODE)
 0BEF 3DFB00            cmp [X-5],0
 0BF2 B009              jnz L196
 0BF4 3DFC00            cmp [X-4],0
 0BF7 B004              jnz L196
 0BF9           X57:
 0BF9                   .dbline 676
 0BF9           ;       {
 0BF9                   .dbline 677
 0BF9           ;               UnloadConfig_transmitter_config();
 0BF9 7C0000            xcall _UnloadConfig_transmitter_config
 0BFC                   .dbline 678
 0BFC           ;       }
 0BFC           L196:
 0BFC           L195:
 0BFC           L193:
 0BFC                   .dbline -2
 0BFC           L191:
 0BFC 20                pop X
 0BFD                   .dbline 0 ; func end
 0BFD 7F                ret
 0BFE                   .dbsym l config_num -5 I
 0BFE                   .dbend
 0BFE                   .dbfunc e busListen _busListen fV
 0BFE           _busListen::
 0BFE                   .dbline -1
 0BFE                   .dbline 682
 0BFE           ; }
 0BFE           ; 
 0BFE           ; void busListen(void)
 0BFE           ; {
 0BFE                   .dbline 683
 0BFE           ;       configToggle(RX_MODE);
 0BFE 5000              mov A,0
 0C00 08                push A
 0C01 5001              mov A,1
 0C03 08                push A
 0C04 9EE5              xcall _configToggle
 0C06 38FE              add SP,-2
 0C08 8013              xjmp L200
 0C0A           L199:
 0C0A                   .dbline 687
 0C0A           ; 
 0C0A           ;       // Wait for the first byte.
 0C0A           ;       while(TIMEOUT < BOOT_TIMEOUT)
 0C0A           ;       {       
 0C0A                   .dbline 688
 0C0A           ;               if(RECEIVE_cGetChar())
 0C0A 10                push X
 0C0B 7C0000            xcall _RECEIVE_cGetChar
 0C0E 20                pop X
 0C0F 3900              cmp A,0
 0C11 A00A              jz L202
 0C13                   .dbline 689
 0C13           ;               {
 0C13                   .dbline 690
 0C13           ;                       TIMEOUT = BOOT_TIMEOUT;
 0C13 62D000            mov REG[0xd0],>_TIMEOUT
 0C16 55012C            mov [_TIMEOUT+1],44
 0C19 550001            mov [_TIMEOUT],1
 0C1C                   .dbline 691
 0C1C           ;               }
 0C1C           L202:
 0C1C                   .dbline 692
 0C1C           ;       }
 0C1C           L200:
 0C1C                   .dbline 686
 0C1C 62D000            mov REG[0xd0],>_TIMEOUT
 0C1F 5101              mov A,[_TIMEOUT+1]
 0C21 112C              sub A,44
 0C23 5100              mov A,[_TIMEOUT]
 0C25 3180              xor A,-128
 0C27 1981              sbb A,(1 ^ 0x80)
 0C29 CFE0              jc L199
 0C2B           X58:
 0C2B                   .dbline 695
 0C2B           ;       
 0C2B           ;       // Clear the timeout flag.
 0C2B           ;       TIMEOUT = 0;
 0C2B 62D000            mov REG[0xd0],>_TIMEOUT
 0C2E 550100            mov [_TIMEOUT+1],0
 0C31 550000            mov [_TIMEOUT],0
 0C34 8013              xjmp L205
 0C36           L204:
 0C36                   .dbline 699
 0C36           ;       
 0C36           ;       // Wait for BUS_CLEAR_TIME to pass without hearing a byte.
 0C36           ;       while(TIMEOUT < BUS_CLEAR_TIME)
 0C36           ;       {       
 0C36                   .dbline 700
 0C36           ;               if(RECEIVE_cReadChar())
 0C36 10                push X
 0C37 7C0000            xcall _RECEIVE_cReadChar
 0C3A 20                pop X
 0C3B 3900              cmp A,0
 0C3D A00A              jz L207
 0C3F                   .dbline 701
 0C3F           ;               {
 0C3F                   .dbline 702
 0C3F           ;                       TIMEOUT = 0;    
 0C3F 62D000            mov REG[0xd0],>_TIMEOUT
 0C42 550100            mov [_TIMEOUT+1],0
 0C45 550000            mov [_TIMEOUT],0
 0C48                   .dbline 703
 0C48           ;               }
 0C48           L207:
 0C48                   .dbline 704
 0C48           ;       }
 0C48           L205:
 0C48                   .dbline 698
 0C48 62D000            mov REG[0xd0],>_TIMEOUT
 0C4B 5101              mov A,[_TIMEOUT+1]
 0C4D 1164              sub A,100
 0C4F 5100              mov A,[_TIMEOUT]
 0C51 3180              xor A,-128
 0C53 1980              sbb A,(0 ^ 0x80)
 0C55 CFE0              jc L204
 0C57           X59:
 0C57                   .dbline -2
 0C57           L198:
 0C57                   .dbline 0 ; func end
 0C57 7F                ret
 0C58                   .dbend
 0C58                   .dbfunc e initializeSlaves _initializeSlaves fV
 0C58           ;   num_timeouts -> X+0
 0C58           _initializeSlaves::
 0C58                   .dbline -1
 0C58 10                push X
 0C59 4F                mov X,SP
 0C5A 3802              add SP,2
 0C5C                   .dbline 708
 0C5C           ; }
 0C5C           ; 
 0C5C           ; void initializeSlaves(void)
 0C5C           ; {
 0C5C                   .dbline 709
 0C5C           ;       int num_timeouts = 0;
 0C5C 560100            mov [X+1],0
 0C5F 560000            mov [X+0],0
 0C62                   .dbline 712
 0C62           ;       
 0C62           ;       // Set num modules to zero.
 0C62           ;       NUM_MODULES = 0;
 0C62 62D000            mov REG[0xd0],>_NUM_MODULES
 0C65 550100            mov [_NUM_MODULES+1],0
 0C68 550000            mov [_NUM_MODULES],0
 0C6B                   .dbline 715
 0C6B           ;       
 0C6B           ;       // Block and wait for the bus to be clear.
 0C6B           ;       busListen();
 0C6B 9F91              xcall _busListen
 0C6D                   .dbline 717
 0C6D           ;       
 0C6D           ;       sayHello();
 0C6D 7C02FA            xcall _sayHello
 0C70 810B              xjmp L211
 0C72           L210:
 0C72                   .dbline 722
 0C72           ;       
 0C72           ;       // This loop continuously probes and listens at intervals
 0C72           ;       // set by the RX_TIMEOUT_DURATION variable.
 0C72           ;       while(num_timeouts < MAX_TIMEOUTS)
 0C72           ;       {       
 0C72                   .dbline 723
 0C72           ;               if(validTransmission())
 0C72 7C0350            xcall _validTransmission
 0C75 62D000            mov REG[0xd0],>__r0
 0C78 3C0000            cmp [__r0],0
 0C7B B006              jnz X60
 0C7D 3C0000            cmp [__r1],0
 0C80 A0C8              jz L213
 0C82           X60:
 0C82                   .dbline 724
 0C82           ;               {
 0C82                   .dbline 725
 0C82           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0C82 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0C85 3C00C8            cmp [_COMMAND_TYPE],-56
 0C88 B0F3              jnz L214
 0C8A                   .dbline 726
 0C8A           ;                       {
 0C8A                   .dbline 728
 0C8A           ;                               // If this is for me, assign them an ID.
 0C8A           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0C8A 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0C8D 3C0000            cmp [_COMMAND_DESTINATION],0
 0C90 B0EB              jnz L214
 0C92                   .dbline 729
 0C92           ;                               {
 0C92                   .dbline 730
 0C92           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0C92 62D000            mov REG[0xd0],>_NUM_MODULES
 0C95 7601              inc [_NUM_MODULES+1]
 0C97 0E0000            adc [_NUM_MODULES],0
 0C9A                   .dbline 731
 0C9A           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0C9A 560100            mov [X+1],0
 0C9D 560000            mov [X+0],0
 0CA0                   .dbline 733
 0CA0           ;               
 0CA0           ;                                       if(!assignID(NUM_MODULES))
 0CA0 5100              mov A,[_NUM_MODULES]
 0CA2 08                push A
 0CA3 5101              mov A,[_NUM_MODULES+1]
 0CA5 08                push A
 0CA6 7C010B            xcall _assignID
 0CA9 38FE              add SP,-2
 0CAB 62D000            mov REG[0xd0],>__r0
 0CAE 3C0000            cmp [__r0],0
 0CB1 B0CA              jnz L214
 0CB3 3C0000            cmp [__r1],0
 0CB6 B0C5              jnz L214
 0CB8           X61:
 0CB8                   .dbline 734
 0CB8           ;                                       {
 0CB8                   .dbline 738
 0CB8           ;                                               // If the module did not respond that the ID was assigned,
 0CB8           ;                                               // make an effort to ping it in case that transmission was lost
 0CB8           ;                                               // before ultimately deciding that the module didn't configure.
 0CB8           ;                                               if(!pingModule(NUM_MODULES))
 0CB8 62D000            mov REG[0xd0],>_NUM_MODULES
 0CBB 5100              mov A,[_NUM_MODULES]
 0CBD 08                push A
 0CBE 5101              mov A,[_NUM_MODULES+1]
 0CC0 08                push A
 0CC1 7C001C            xcall _pingModule
 0CC4 38FE              add SP,-2
 0CC6 62D000            mov REG[0xd0],>__r0
 0CC9 3C0000            cmp [__r0],0
 0CCC B0AF              jnz L214
 0CCE 3C0000            cmp [__r1],0
 0CD1 B0AA              jnz L214
 0CD3           X62:
 0CD3                   .dbline 739
 0CD3           ;                                               {
 0CD3                   .dbline 740
 0CD3           ;                                                       if(!pingModule(NUM_MODULES))
 0CD3 62D000            mov REG[0xd0],>_NUM_MODULES
 0CD6 5100              mov A,[_NUM_MODULES]
 0CD8 08                push A
 0CD9 5101              mov A,[_NUM_MODULES+1]
 0CDB 08                push A
 0CDC 7C001C            xcall _pingModule
 0CDF 38FE              add SP,-2
 0CE1 62D000            mov REG[0xd0],>__r0
 0CE4 3C0000            cmp [__r0],0
 0CE7 B094              jnz L214
 0CE9 3C0000            cmp [__r1],0
 0CEC B08F              jnz L214
 0CEE           X63:
 0CEE                   .dbline 741
 0CEE           ;                                                       {
 0CEE                   .dbline 742
 0CEE           ;                                                               if(!pingModule(NUM_MODULES))
 0CEE 62D000            mov REG[0xd0],>_NUM_MODULES
 0CF1 5100              mov A,[_NUM_MODULES]
 0CF3 08                push A
 0CF4 5101              mov A,[_NUM_MODULES+1]
 0CF6 08                push A
 0CF7 7C001C            xcall _pingModule
 0CFA 38FE              add SP,-2
 0CFC 62D000            mov REG[0xd0],>__r0
 0CFF 3C0000            cmp [__r0],0
 0D02 B079              jnz L214
 0D04 3C0000            cmp [__r1],0
 0D07 B074              jnz L214
 0D09           X64:
 0D09                   .dbline 743
 0D09           ;                                                               {
 0D09                   .dbline 744
 0D09           ;                                                                       if(!pingModule(NUM_MODULES))
 0D09 62D000            mov REG[0xd0],>_NUM_MODULES
 0D0C 5100              mov A,[_NUM_MODULES]
 0D0E 08                push A
 0D0F 5101              mov A,[_NUM_MODULES+1]
 0D11 08                push A
 0D12 7C001C            xcall _pingModule
 0D15 38FE              add SP,-2
 0D17 62D000            mov REG[0xd0],>__r0
 0D1A 3C0000            cmp [__r0],0
 0D1D B05E              jnz L214
 0D1F 3C0000            cmp [__r1],0
 0D22 B059              jnz L214
 0D24           X65:
 0D24                   .dbline 745
 0D24           ;                                                                       {
 0D24                   .dbline 746
 0D24           ;                                                                               if(!pingModule(NUM_MODULES))
 0D24 62D000            mov REG[0xd0],>_NUM_MODULES
 0D27 5100              mov A,[_NUM_MODULES]
 0D29 08                push A
 0D2A 5101              mov A,[_NUM_MODULES+1]
 0D2C 08                push A
 0D2D 7C001C            xcall _pingModule
 0D30 38FE              add SP,-2
 0D32 62D000            mov REG[0xd0],>__r0
 0D35 3C0000            cmp [__r0],0
 0D38 B043              jnz L214
 0D3A 3C0000            cmp [__r1],0
 0D3D B03E              jnz L214
 0D3F           X66:
 0D3F                   .dbline 747
 0D3F           ;                                                                               {
 0D3F                   .dbline 748
 0D3F           ;                                                                                       NUM_MODULES--;
 0D3F 62D000            mov REG[0xd0],>_NUM_MODULES
 0D42 7A01              dec [_NUM_MODULES+1]
 0D44 1E0000            sbb [_NUM_MODULES],0
 0D47                   .dbline 749
 0D47           ;                                                                               }
 0D47                   .dbline 750
 0D47           ;                                                                       }
 0D47                   .dbline 751
 0D47           ;                                                               }
 0D47                   .dbline 752
 0D47           ;                                                       }
 0D47                   .dbline 753
 0D47           ;                                               }
 0D47                   .dbline 754
 0D47           ;                                       }
 0D47                   .dbline 755
 0D47           ;                               }
 0D47                   .dbline 756
 0D47           ;                       }
 0D47                   .dbline 757
 0D47           ;               }
 0D47 8034              xjmp L214
 0D49           L213:
 0D49                   .dbline 758
 0D49           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0D49 62D000            mov REG[0xd0],>_TIMEOUT
 0D4C 5101              mov A,[_TIMEOUT+1]
 0D4E 1105              sub A,5
 0D50 5100              mov A,[_TIMEOUT]
 0D52 3180              xor A,-128
 0D54 1980              sbb A,(0 ^ 0x80)
 0D56 C025              jc L231
 0D58           X67:
 0D58                   .dbline 759
 0D58           ;               {       
 0D58                   .dbline 761
 0D58           ;                       // Only count timeouts if we've found at least one module.
 0D58           ;                       if(NUM_MODULES)
 0D58 62D000            mov REG[0xd0],>_NUM_MODULES
 0D5B 3C0000            cmp [_NUM_MODULES],0
 0D5E B006              jnz X68
 0D60 3C0100            cmp [_NUM_MODULES+1],0
 0D63 A006              jz L233
 0D65           X68:
 0D65                   .dbline 762
 0D65           ;                       {
 0D65                   .dbline 763
 0D65           ;                               num_timeouts++;
 0D65 7701              inc [X+1]
 0D67 0F0000            adc [X+0],0
 0D6A                   .dbline 764
 0D6A           ;                       }
 0D6A           L233:
 0D6A                   .dbline 767
 0D6A           ;                       
 0D6A           ;                       // If we are not maxed out on modules, look for more.
 0D6A           ;                       if(NUM_MODULES < MAX_MODULES)
 0D6A 62D000            mov REG[0xd0],>_NUM_MODULES
 0D6D 5101              mov A,[_NUM_MODULES+1]
 0D6F 11FA              sub A,-6
 0D71 5100              mov A,[_NUM_MODULES]
 0D73 3180              xor A,-128
 0D75 1980              sbb A,(0 ^ 0x80)
 0D77 D004              jnc L235
 0D79           X69:
 0D79                   .dbline 768
 0D79           ;                       {
 0D79                   .dbline 769
 0D79           ;                               sayHello();
 0D79 7C02FA            xcall _sayHello
 0D7C                   .dbline 770
 0D7C           ;                       }
 0D7C           L235:
 0D7C                   .dbline 771
 0D7C           ;               }
 0D7C           L231:
 0D7C           L214:
 0D7C                   .dbline 772
 0D7C           ;       }
 0D7C           L211:
 0D7C                   .dbline 721
 0D7C 5201              mov A,[X+1]
 0D7E 1132              sub A,50
 0D80 5200              mov A,[X+0]
 0D82 3180              xor A,-128
 0D84 1980              sbb A,(0 ^ 0x80)
 0D86 CEEB              jc L210
 0D88           X70:
 0D88                   .dbline 775
 0D88           ;       
 0D88           ;       // Switch back to PC mode.
 0D88           ;       configToggle(PC_MODE);
 0D88 5000              mov A,0
 0D8A 08                push A
 0D8B 5002              mov A,2
 0D8D 08                push A
 0D8E 9D5B              xcall _configToggle
 0D90 38FE              add SP,-2
 0D92                   .dbline -2
 0D92           L209:
 0D92 38FE              add SP,-2
 0D94 20                pop X
 0D95                   .dbline 0 ; func end
 0D95 7F                ret
 0D96                   .dbsym l num_timeouts 0 I
 0D96                   .dbend
 0D96                   .dbfunc e xmitWait _xmitWait fV
 0D96           ;              i -> X+0
 0D96           _xmitWait::
 0D96                   .dbline -1
 0D96 10                push X
 0D97 4F                mov X,SP
 0D98 3802              add SP,2
 0D9A                   .dbline 779
 0D9A           ; }
 0D9A           ; 
 0D9A           ; void xmitWait(void)
 0D9A           ; {
 0D9A                   .dbline 782
 0D9A           ;       int i;
 0D9A           ;       
 0D9A           ;       for(i = 0; i < 25; i++)
 0D9A 560100            mov [X+1],0
 0D9D 560000            mov [X+0],0
 0DA0           L238:
 0DA0                   .dbline 783
 0DA0           ;       {
 0DA0                   .dbline 785
 0DA0           ;               // Sit here and spin for about 50 microseconds.
 0DA0           ;       }
 0DA0           L239:
 0DA0                   .dbline 782
 0DA0 7701              inc [X+1]
 0DA2 0F0000            adc [X+0],0
 0DA5                   .dbline 782
 0DA5 5201              mov A,[X+1]
 0DA7 1119              sub A,25
 0DA9 5200              mov A,[X+0]
 0DAB 3180              xor A,-128
 0DAD 1980              sbb A,(0 ^ 0x80)
 0DAF CFF0              jc L238
 0DB1           X71:
 0DB1                   .dbline -2
 0DB1           L237:
 0DB1 38FE              add SP,-2
 0DB3 20                pop X
 0DB4                   .dbline 0 ; func end
 0DB4 7F                ret
 0DB5                   .dbsym l i 0 I
 0DB5                   .dbend
 0DB5                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0DB5           _TX_TIMEOUT_ISR::
 0DB5                   .dbline -1
 0DB5 71C0              or F,-64
 0DB7 08                push A
 0DB8 5DD0              mov A,REG[0xd0]
 0DBA 08                push A
 0DBB                   .dbline 789
 0DBB           ; }
 0DBB           ; 
 0DBB           ; void TX_TIMEOUT_ISR(void)
 0DBB           ; {     
 0DBB                   .dbline 790
 0DBB           ;       TIMEOUT++;
 0DBB 62D000            mov REG[0xd0],>_TIMEOUT
 0DBE 7601              inc [_TIMEOUT+1]
 0DC0 0E0000            adc [_TIMEOUT],0
 0DC3                   .dbline 792
 0DC3           ;       
 0DC3           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0DC3 62DAFD            mov REG[0xda],-3
 0DC6                   .dbline -2
 0DC6           L242:
 0DC6 18                pop A
 0DC7 60D0              mov REG[208],A
 0DC9 18                pop A
 0DCA                   .dbline 0 ; func end
 0DCA 7E                reti
 0DCB                   .dbend
 0DCB                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0DCB           _RX_TIMEOUT_ISR::
 0DCB                   .dbline -1
 0DCB 71C0              or F,-64
 0DCD 08                push A
 0DCE 5DD0              mov A,REG[0xd0]
 0DD0 08                push A
 0DD1                   .dbline 796
 0DD1           ; }
 0DD1           ; 
 0DD1           ; void RX_TIMEOUT_ISR(void)
 0DD1           ; {     
 0DD1                   .dbline 797
 0DD1           ;       TIMEOUT++;
 0DD1 62D000            mov REG[0xd0],>_TIMEOUT
 0DD4 7601              inc [_TIMEOUT+1]
 0DD6 0E0000            adc [_TIMEOUT],0
 0DD9                   .dbline 799
 0DD9           ;       
 0DD9           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0DD9 62DAFD            mov REG[0xda],-3
 0DDC                   .dbline -2
 0DDC           L243:
 0DDC 18                pop A
 0DDD 60D0              mov REG[208],A
 0DDF 18                pop A
 0DE0                   .dbline 0 ; func end
 0DE0 7E                reti
 0DE1                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~4\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
